<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>tf.applib.display API documentation</title>
<meta name="description" content="Display â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.applib.display</code></h1>
</header>
<section id="section-intro">
<h1 id="display">Display</h1>
<p>Where the advanced API really shines is in displaying nodes.
There are basically two ways of displaying a node:</p>
<ul>
<li><em>plain</em>: just the associated text of a node, or if that would be too much,
an identifying label of that node (e.g. for books, chapters and lexemes).</li>
<li><em>pretty</em>: a display of the internal structure of the textual object a node
stands for. That structure is adorned with relevant feature values.</li>
</ul>
<p>These display methods are available for nodes, tuples of nodes, and iterables
of tuples of nodes (think: query results).
The names of these methods are</p>
<ul>
<li><code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a></code>, <code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple()</a></code>, and <code><a title="tf.applib.display.table" href="#tf.applib.display.table">table()</a></code>;</li>
<li><code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code>, <code><a title="tf.applib.display.prettyTuple" href="#tf.applib.display.prettyTuple">prettyTuple()</a></code> and <code><a title="tf.applib.display.show" href="#tf.applib.display.show">show()</a></code>.</li>
</ul>
<p>In plain and pretty displays, certain parts can be <em>highlighted</em>, which is
good for displaying query results where the parts that correspond directly to the
search template are highlighted.</p>
<h2 id="display-parameters">Display parameters</h2>
<p>There is a bunch of parameters that govern how the display functions arrive at their
results. You can pass them as optional arguments to these functions,
or you can set up them in advance, and reset them to their original state
when you are done.</p>
<p>All calls to the display functions look for the values for these parameters in the
following order:</p>
<ul>
<li>optional parameters passed directly to the function,</li>
<li>values as set up by previous calls to <code><a title="tf.applib.display.displaySetup" href="#tf.applib.display.displaySetup">displaySetup()</a></code>,</li>
<li>corpus dependent default values configured by the advanced API.</li>
</ul>
<p>See <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code> for a list of display parameters.</p>
<h2 id="display-algorithm">Display algorithm</h2>
<p>Both <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code> and <code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a></code> depend on an algorithm to <em>unravel</em> nodes to other nodes.</p>
<p>For example, when we display a sentence, we also display its clauses and phrases and words,
which all correspond to nodes.</p>
<p>Here is a top-level sketchy description of the <em>unravel</em> algorithm.</p>
<h3 id="descendant-types">Descendant types</h3>
<p>Node types are ranked: node types whose nodes occupy more slots on average have a higher rank
than types whose nodes occupy less slots on average.
You can inspect the ranking of the types in your dataset by <code><a title="tf.core.nodes.Nodes.otypeRank" href="../core/nodes.html#tf.core.nodes.Nodes.otypeRank">Nodes.otypeRank</a></code>.</p>
<p>For each node type, we collect the set of descendant types: the types with lower or equal rank.
So each type is its own descendant. But we prevent the slot type from being its own
descendant.</p>
<h3 id="chunkify">Chunkify</h3>
<p>Every node is linked to a set of slots. These slots may or may not form a contiguous chunk.
For the purposes of displaying nodes, we divide each node into maximal contiguous chunks.
Such a chunk is specified by a tuple <code>(n, slots)</code>, where <code>n</code> is the node (an integer),
and <code>slots</code> is a frozen set of slots (also integers).</p>
<p>The unravel algorithm takes a sequence of chunks and
unravels them to another sequence of chunks.</p>
<p>See <code><a title="tf.applib.displaylib.chunkify" href="displaylib.html#tf.applib.displaylib.chunkify">chunkify()</a></code>.</p>
<h3 id="intersecting-nodes">Intersecting nodes</h3>
<p>Nodes or chunks whose slot sets intersect, are intersecting nodes, except the node itself.</p>
<h3 id="canonical-order">Canonical order</h3>
<p>Before we feed chunks to the display, we sort them in <em>canonical order</em>, based on their
slots and node type.</p>
<ul>
<li>Chunks with earlier first slots come before chunks with later first slots.</li>
<li>For chunks that have the same first slots: look at the slots they do <em>not</em> have in common.
The chunk with the earlier such slot comes before the chunk with the later such slot.</li>
<li>For chunks that have the same sets of slots: look at their node type.
Different node types: the chunk with the higher ranked
node type comes before the one with the lower ranked node type.</li>
<li>For chunks that have the same sets of slots and the same node type:
the chunk whose node (as integer) comes before the node of the other chunk, comes before.</li>
</ul>
<p>See <code><a title="tf.core.nodes" href="../core/nodes.html">tf.core.nodes</a></code>.</p>
<h3 id="substrate">Substrate</h3>
<p>Sometimes we do not want to display a node completely, but restricted to a set of slots.
We call this set the <em>substrate</em>.</p>
<p>It typically happens in a node is contained in a parent node that has multiple chunks.
The child node should be displayed in parts: in each chunk of the parent node, the child node
should be displayed in as far its slots are contained in that chunk.</p>
<h3 id="output">Output</h3>
<p>When we unravel a list of chunks, we produce output for the chunks, one by one.
For each chunk, the output consists of a contribution by the node of the chunk, followed
by the result of unraveling the chunk into related chunks and collecting their output.</p>
<h3 id="called-and-done">Called and done</h3>
<p>During the process of unraveling chunks, we may encounter chunks that we have met before,
and may or may not have produced their output already.</p>
<p>More precisely, for each node we keep track of the chunks related to that node:</p>
<dl>
<dt><strong>called</strong></dt>
<dd>maps each node to the set of its chunks that are being processed but have not finished yet</dd>
<dt><strong>done</strong></dt>
<dd>the set of slots that already occur in the output.</dd>
</dl>
<h3 id="all-pieces-together">All pieces together</h3>
<p>In order to display node <code>n</code> the algorithm works as follows:</p>
<ol>
<li>Set the <strong>substrate</strong> to all slots of the node.</li>
<li>Chunkify the node in a <strong>canonically sorted</strong> list of its chunks</li>
<li>Display the list of these chunks on this substrate.</li>
</ol>
<p>Now we describe recursively how to display a list of chunks on a substrate.</p>
<p>Set <strong>done</strong> to the empty set, <strong>called</strong> to the empty mapping.</p>
<p>Work through the chunks in that order, for each chunk:</p>
<ol>
<li>Take the intersection of the slots of the chunk with the substrate.
This will be the new slot set of this chunk.</li>
<li>If the intersection is empty: skip this chunk.</li>
<li>If the node of the chunk is already in <strong>called</strong>, mapped to a slot set
that encompasses the slot set of this chunk: skip this chunk.</li>
<li>If all the slots of the chunk are already in <strong>done</strong>: skip this chunk.</li>
<li>Add the chunk to <strong>called</strong>, mapped to its slot set.</li>
<li>Produce output for the node of the chunk.</li>
<li>Unravel the chunk: get the all <em>intersecting</em> <em>descendant</em> nodes of the node of the chunk.</li>
<li><strong>chunkify</strong> these nodes into a canonically order list of chunks.</li>
<li>Recursively work through the descendant chunks but on a different substrate:
the slots of the (parent) chunk minus the slots already done.</li>
<li>Add all the slots of the chunk to the <strong>done</strong> set.</li>
<li>Process the new chunk.</li>
</ol>
<h3 id="notes">Notes</h3>
<p>When nodes represent textual objects that intersect with each other, it is possible that
slots are contained in several of such objects.
The algorithm takes care that they will not be output twice
(by means of <strong>called</strong> and <strong>done</strong>).</p>
<p>When textual objects have gaps, it is wrong to process each object completely before
going to the next one. Because then the slots will be displayed in the wrong order.</p>
<p>By chunkifying and sorting the chunks in canonical order, this is prevented.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L0-L835" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../../docs/applib/display.md
&#34;&#34;&#34;


import os
import types

from ..parameters import DOWNLOADS, SERVER_DISPLAY, SERVER_DISPLAY_BASE
from ..core.helpers import mdEsc, flattenToSet
from .helpers import getResultsX, tupleEnum, RESULT, dh
from .condense import condense, condenseSet
from .highlight import getTupleHighlights
from .displaysettings import DisplaySettings
from .displaylib import (
    OuterContext,
    _doPlain,
    _doPretty,
    _getPassage,
    _getRefMember,
    _getLtr,
    _getTextCls,
    _doPassage,
)

LIMIT_SHOW = 100
LIMIT_TABLE = 2000


def displayApi(app, silent):
    &#34;&#34;&#34;Produce the display API.

    The display API provides methods to generate styled representations
    of pieces of corpus texts in their relevant structures.
    The main end-user functions are `plain(node)` and `pretty(node)`.

    `plain()` focuses on the plain text, `pretty()` focuses on structure
    and feature display.

    Related are `plainTuple()` and `prettyTuple()` that work for tuples
    instead of nodes.

    And further there are `show()` and `table()`, that work
    with iterables of tuples of nodes (e.g. query results).

    Parameters
    ----------
    app: obj
        The high-level API object
    silent:
        The verbosity mode to perform this operation in.
        Normally it is the same as for the app, but when we do an `A.reuse()`
        we force `silent=True`.
    &#34;&#34;&#34;

    app.export = types.MethodType(export, app)
    app.table = types.MethodType(table, app)
    app.plainTuple = types.MethodType(plainTuple, app)
    app.plain = types.MethodType(plain, app)
    app.show = types.MethodType(show, app)
    app.prettyTuple = types.MethodType(prettyTuple, app)
    app.pretty = types.MethodType(pretty, app)
    app.loadCss = types.MethodType(loadCss, app)
    app.displaySetup = types.MethodType(displaySetup, app)
    app.displayReset = types.MethodType(displayReset, app)

    app.display = DisplaySettings(app)
    if not app._browse:
        app.loadCss()


def displaySetup(app, **options):
    &#34;&#34;&#34;Set up all display parameters.

    Assigns working values to display parameters.
    All subsequent calls to display functions such as `plain` and `pretty`
    will use these values, unless they themselves are passed overriding
    values as arguments.

    These working values remain in effect until a new call to `displaySetup()`
    assigns new values, or a call to `displayReset()` resets the values to the
    defaults.

    !!! hint &#34;corpus settings&#34;
        The defaults themselves come from the corpus settings, which are influenced
        by its `config.yaml` file, if it exists. See `tf.applib.settings`.

    Parameters
    ----------
    options: dict
        Explicit values for selected options that act as overrides of the defaults.
        A list of all available options is in `tf.applib.displaysettings`.
    &#34;&#34;&#34;

    display = app.display

    display.setup(**options)


def displayReset(app, *options):
    &#34;&#34;&#34;Restore display parameters to their defaults.

    Reset the given display parameters to their default value and let the others
    retain their current value.

    So you can reset the display parameters selectively.

    Parameters
    ----------
    options: list, optional `[]`
        If present, only restore these options to their defaults.
        Otherwise, restore all display settings.
    &#34;&#34;&#34;

    display = app.display

    display.reset(*options)
    # if not app._browse:
    #    app.loadCss()


def loadCss(app):
    &#34;&#34;&#34;The CSS is looked up and then loaded into a notebook if we are not
    running in the TF browser,
    else the CSS is returned.
    &#34;&#34;&#34;

    _browse = app._browse
    aContext = app.context
    css = aContext.css

    if _browse:
        return css

    cssPath = (
        f&#34;{os.path.dirname(os.path.dirname(os.path.abspath(__file__)))}&#34;
        f&#34;{SERVER_DISPLAY_BASE}&#34;
    )
    genericCss = &#34;&#34;
    for cssFile in SERVER_DISPLAY:
        with open(f&#34;{cssPath}/{cssFile}&#34;, encoding=&#34;utf8&#34;) as fh:
            genericCss += fh.read()

    tableCss = &#34;tr.tf, td.tf, th.tf { text-align: left ! important;}&#34;
    dh(f&#34;&lt;style&gt;&#34; + tableCss + genericCss + css + &#34;&lt;/style&gt;&#34;)


def export(app, tuples, toDir=None, toFile=&#34;results.tsv&#34;, **options):
    &#34;&#34;&#34;Exports an iterable of tuples of nodes to an Excel friendly `.tsv` file.

    !!! hint &#34;Examples&#34;
        See for detailed examples the
        [exportExcel](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/bhsa/exportExcel.ipynb)
        and
        [exportExcel](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/oldbabylonian/exportExcel.ipynb)
        notebooks.

    Parameters
    ----------
    tuples: iterable of tuples of integer
        The integers are the nodes, together they form a table.
    toDir: string, optional `None`
        The destination directory for the exported file.
        By default it is your Downloads folder.

        If the directory does not exist, it will be created.
    toFile: boolean, optional `results.tsv`
        The name of the exported file.
    options: dict
        Display options, see `tf.applib.displaysettings`.

        !!! note &#34;details&#34;
            * `condensed`
              Has no effect. Exports to Excel will not be condensed, because the
              number of columns is variable per row in that case.
              Excel itself has nice possibilities for grouping rows.
              You can also filter your tuples by means of hand-coding
              before exporting them.
            * `condenseType`
              The condense type influences for which nodes
              the full text will be exported.
              Only nodes that are &#34;smaller&#34; than the condense type will have
              their full text exported.
            * `fmt`
              This display parameter specifies the text format for any nodes
              that trigger a text value to be exported.
            * `tupleFeatures`
              This is a display parameter that steers which features are exported
              with each member of the tuples in the list.

              If the iterable of tuples are the results of a query you have just
              run, then an appropriate call to `displaySetup(tupleFeatures=...)`
              has already been issued, so you can just say:

              ```python
              results = A.search(query)
              A.export(results)
              ```

    Results
    -------
    A file *toFile* in directory *toDir* with the following content:

    There will be a row for each tuple.
    The columns are:

    * **R** the sequence number of the result tuple in the result list
    * **S1 S2 S3** the section as book, chapter, verse, in separate columns;
      the section is the section of the first non book/chapter node in the tuple
    * **NODEi TYPEi** the node and its type,
      for each node **i** in the result tuple
    * **TEXTi** the full text of node **i**,
      if the node type admits a concise text representation;
      the criterion is whether the node type has a type not bigger than the
      default condense type, which is app specific.
      If you pass an explicit `condenseType=`*xxx* as display parameter,
      then this is the reference condenseType on which the decision is based.
    * **XFi** the value of extra feature **XF** for node **i**,
      where these features have been declared by a previous
      displaySetup(tupleFeatures=...)`

    !!! caution &#34;Encoding&#34;
        The exported file is written in the `utf_16_le` encoding.
        This ensures that Excel can open it without hassle, even if there
        are non-latin characters inside.

        When you want to read the exported file programmatically,
        open it with `encoding=utf_16`.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    fmt = dContext.fmt
    condenseType = dContext.condenseType
    tupleFeatures = dContext.tupleFeatures

    if toDir is None:
        toDir = os.path.expanduser(DOWNLOADS)
        if not os.path.exists(toDir):
            os.makedirs(toDir, exist_ok=True)
    toPath = f&#34;{toDir}/{toFile}&#34;

    resultsX = getResultsX(app, tuples, tupleFeatures, condenseType, fmt=fmt,)

    with open(toPath, &#34;w&#34;, encoding=&#34;utf_16_le&#34;) as fh:
        fh.write(
            &#34;\ufeff&#34;
            + &#34;&#34;.join(
                (&#34;\t&#34;.join(&#34;&#34; if t is None else str(t) for t in tup) + &#34;\n&#34;)
                for tup in resultsX
            )
        )


# PLAIN and FRIENDS


def table(app, tuples, _asString=False, **options):
    &#34;&#34;&#34;Plain displays of an iterable of tuples of nodes in a table.

    The list is displayed as a compact markdown table.
    Every row is prepended with the sequence number in the iterable,
    and then displayed by `plainTuple`

    !!! hint &#34;condense, condenseType&#34;
        You can condense the list first to containers of `condenseType`,
        before displaying the list.
        Pass the display parameters `condense` and `condenseType`.
        See `tf.applib.displaysettings`.

    Parameters
    ----------
    tuples: iterable of tuples of integer
        The integers are the nodes, together they form a table.
    options: dict
        Display options, see `tf.applib.displaysettings`.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    fOtype = F.otype.v

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    withPassage = dContext.withPassage
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;

    html = []
    one = True

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_TABLE, item):
        if one:
            heads = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
            html.append(
                f&#39;&lt;tr class=&#34;tf&#34;&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;{heads}&lt;/th&gt;&#39;
                f&#34;&lt;/tr&gt;&#34;
            )
            one = False
        html.append(
            plainTuple(
                app,
                tup,
                i,
                item=item,
                position=None,
                opened=False,
                _asString=True,
                skipCols=set(),
                **newOptions,
            )
        )
    html = &#34;&lt;table&gt;&#34; + &#34;\n&#34;.join(html) + &#34;&lt;/table&gt;&#34;
    if _asString:
        return html
    dh(html)


def plainTuple(
    app, tup, seq, item=RESULT, position=None, opened=False, _asString=False, **options
):
    &#34;&#34;&#34;Display the plain text of a tuple of nodes.

    Displays the material that corresponds to a tuple of nodes
    as a row of cells,
    each displaying a member of the tuple by means of `plain`.

    Parameters
    ----------
    tup: iterable of integer
        The members of the tuple can be arbitrary nodes.
    seq: integer
        an arbitrary number which will be displayed in the first cell.
        This prepares the way for displaying query results, which come as
        a sequence of tuples of nodes.
    item: string, optional `result`
        A name for the tuple: it could be a result, or a chapter, or a line.
    position: integer, optional `None`
        Which position counts as the focus position.
        If *seq* equals *position*, the tuple is in focus.
        The effect is to add the CSS class *focus* to the output HTML
        for the row of this tuple.
    opened:  booolean, optional `False`
        Whether this tuple should be expandable to a `pretty` display.
        The normal output of this row will be wrapped in a

        ``` html
        &lt;details&gt;&lt;summary&gt;plain&lt;/summary&gt;pretty&lt;/details&gt;
        ```

        pattern, so that the user can click a triangle to switch between plain
        and pretty display.

        !!! caution
            This option has only effect when used in the TF browser.
    options: dict
        Display options, see `tf.applib.displaysettings`.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.

    Result
    ------
    html string or `None`
        Depending on *asString* above.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;plainTuple&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    fOtype = F.otype.v
    _browse = app._browse

    dContext = display.get(options)
    condenseType = dContext.condenseType
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    withPassage = dContext.withPassage
    skipCols = dContext.skipCols

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if withPassage is True:
        passageNode = _getRefMember(app, tup, dContext)
        passageRef = (
            &#34;&#34;
            if passageNode is None
            else app._sectionLink(passageNode)
            if _browse
            else app.webLink(passageNode, _asString=True)
        )
        passageRef = f&#39;&lt;span class=&#34;section ltr&#34;&gt;{passageRef}&lt;/span&gt;&#39;
    else:
        passageRef = &#34;&#34;

    newOptions = display.consume(options, &#34;withPassage&#34;)
    newOptionsH = display.consume(options, &#34;withPassage&#34;, &#34;highlights&#34;)

    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if _browse:
        prettyRep = (
            prettyTuple(app, tup, seq, withPassage=False, **newOptions)
            if opened
            else &#34;&#34;
        )
        current = &#34;focus&#34; if seq == position else &#34;&#34;
        attOpen = &#34;open &#34; if opened else &#34;&#34;
        tupSeq = &#34;,&#34;.join(str(n) for n in tup)
        if withPassage is True:
            sparts = T.sectionFromNode(passageNode, fillup=True)
            passageAtt = &#34; &#34;.join(
                f&#39;sec{i}=&#34;{sparts[i] if i &lt; len(sparts) else &#34;&#34;}&#34;&#39; for i in range(3)
            )
        else:
            passageAtt = &#34;&#34;

        plainRep = &#34;&#34;.join(
            &#34;&lt;span&gt;&#34;
            + mdEsc(
                app.plain(
                    n,
                    _inTuple=True,
                    withPassage=_doPassage(dContext, i),
                    highlights=highlights,
                    **newOptionsH,
                )
            )
            + &#34;&lt;/span&gt;&#34;
            for (i, n) in enumerate(tup)
        )
        html = (
            f&#39;&lt;details class=&#34;pretty dtrow {current}&#34; seq=&#34;{seq}&#34; {attOpen}&gt;&#39;
            f&#34;&lt;summary&gt;&#34;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;pq fa fa-solar-panel fa-xs&#34;&#39;
            f&#39; title=&#34;show in context&#34; {passageAtt}&gt;&lt;/a&gt;&#39;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;sq&#34; tup=&#34;{tupSeq}&#34;&gt;{seq}&lt;/a&gt;&#39;
            f&#34; {passageRef} {plainRep}&#34;
            f&#34;&lt;/summary&gt;&#34;
            f&#39;&lt;div class=&#34;pretty&#34;&gt;{prettyRep}&lt;/div&gt;&#39;
            f&#34;&lt;/details&gt;&#34;
        )
        return html

    html = [str(seq)]
    if withPassage is True:
        html.append(passageRef)
    for (i, n) in enumerate(tup):
        html.append(
            app.plain(
                n,
                _inTuple=True,
                _asString=True,
                withPassage=_doPassage(dContext, i),
                highlights=highlights,
                **newOptionsH,
            )
        )
    html = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;td class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/td&gt;&lt;td class=&#34;tf&#34;&gt;&#39;.join(html)
        + &#34;&lt;/td&gt;&lt;/tr&gt;&#34;
    )
    if _asString:
        return html

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;
    head = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
        + f&#34;&lt;/th&gt;&lt;/tr&gt;&#34;
    )
    html = f&#34;&lt;table&gt;&#34; + head + &#34;&#34;.join(html) + &#34;&lt;/table&gt;&#34;

    dh(html)


def plain(app, n, _inTuple=False, _asString=False, explain=False, **options):
    &#34;&#34;&#34;Display the plain text of a node.

    Displays the material that corresponds to a node in a compact way.
    Nodes with little content will be represented by their text content,
    nodes with large content will be represented by an identifying label.

    Parameters
    ----------
    n: integer
        Node
    options: dict
        Display options, see `tf.applib.displaysettings`.
    _inTuple: boolean, optional `False`
        Whether the result is meant too end up in a table cell produced by
        `plainTuple`. In that case some extra node types count as big and will
        not be displayed in full.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.

    Result
    ------
    html string or `None`
        Depending on *asString* above.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;plain&#34;, options):
        return &#34;&#34;

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml

    _browse = app._browse
    api = app.api
    E = api.E

    ltr = _getLtr(app, dContext)
    textCls = _getTextCls(app, fmt)
    slots = frozenset(E.oslots.s(n))

    oContext = OuterContext(ltr, textCls, slots, _inTuple, not not explain)
    passage = _getPassage(app, True, dContext, oContext, n)
    boundaryCls = &#34;&#34;
    rep = _doPlain(
        app,
        dContext,
        oContext,
        n,
        slots,
        boundaryCls,
        True,
        True,
        True,
        0,
        passage,
        [],
        set(),
        {},
    )
    sep = &#34; &#34; if passage and rep else &#34;&#34;

    result = passage + sep + rep

    if _browse or _asString:
        return result
    dh(result)


# PRETTY and FRIENDS


def show(app, tuples, **options):
    &#34;&#34;&#34;Displays an iterable of tuples of nodes.

    The elements of the list are displayed by `A.prettyTuple()`.

    !!! hint &#34;condense, condenseType&#34;
        You can condense the list first to containers of `condenseType`,
        before displaying the list.
        Pass the display parameters `condense` and `condenseType`.
        See `tf.applib.displaysettings`.

    Parameters
    ----------
    tuples: iterable of tuples of integer
        The integers are the nodes, together they form a table.
    options: dict
        Display options, see `tf.applib.displaysettings`.

    Result
    ------
    html string or `None`
        When used for the TF browser (`app._browse` is true), the result is returned
        as HTML. Otherwise the result is directly displayed in a notebook.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;show&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    api = app.api
    F = api.F

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_SHOW, item):
        item = F.otype.v(tup[0]) if condensed and condenseType else RESULT
        prettyTuple(app, tup, i, item=item, skipCols=set(), **newOptions)


def prettyTuple(app, tup, seq, item=RESULT, **options):
    &#34;&#34;&#34;Displays the material that corresponds to a tuple of nodes in a graphical way.

    The member nodes of the tuple will be collected into containers, which
    will be displayed with `pretty()`, and the nodes of the tuple
    will be highlighted in the containers.

    Parameters
    ----------
    tup: iterable of integer
        The members of the tuple can be arbitrary nodes.
    seq: integer
        an arbitrary number which will be displayed in the heading.
        This prepares the way for displaying query results, which come as
        a sequence of tuples of nodes.
    item: string, optional `result`
        A name for the tuple: it could be a result, or a chapter, or a line.
    options: dict
        Display options, see `tf.applib.displaysettings`.

    Result
    ------
    html string or `None`
        When used for the TF browser (`app._browse` is true), the result is returned
        as HTML. Otherwise the result is directly displayed in a notebook.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;prettyTuple&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    skipCols = dContext.skipCols

    _browse = app._browse

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if len(tup) == 0:
        if _browse:
            return &#34;&#34;
        else:
            return

    api = app.api
    N = api.N
    sortKey = N.sortKey

    containers = {tup[0]} if condensed else condenseSet(api, tup, condenseType)
    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if not _browse:
        dh(f&#34;&lt;p&gt;&lt;b&gt;{item}&lt;/b&gt; &lt;i&gt;{seq}&lt;/i&gt;&lt;/p&gt;&#34;)
    if _browse:
        html = []
    for t in sorted(containers, key=sortKey):
        h = app.pretty(
            t, highlights=highlights, **display.consume(options, &#34;highlights&#34;),
        )
        if _browse:
            html.append(h)
    if _browse:
        return &#34;&#34;.join(html)


def pretty(app, n, explain=False, **options):
    &#34;&#34;&#34;Displays the material that corresponds to a node in a graphical way.

    The internal structure of the nodes that are involved is also revealed.
    In addition, extra features and their values are displayed with the nodes.

    !!! hint &#34;Controlling pretty displays&#34;
        The following `tf.applib.displaysettings`
        are particularly relevant to pretty displays:

        * `condenseType`: the standard container to display nodes in;
        * `full`: whether to display a reference to the material or the material itself;
        * `extraFeatures`: additional features to  display
        * `tupleFeatures`: additional features to  display (primarily for `export`.

    Parameters
    ----------
    n: integer
        Node
    options: dict
        Display options, see `tf.applib.displaysettings`.
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.

    Result
    ------
    html string or `None`
        When used for the TF browser (`app._browse` is true), the result is returned
        as HTML. Otherwise the result is directly displayed in a notebook.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;pretty&#34;, options):
        return &#34;&#34;

    _browse = app._browse

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    tupleFeatures = dContext.tupleFeatures
    extraFeatures = dContext.extraFeatures
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml
    dContext.features = sorted(
        flattenToSet(extraFeatures[0]) | flattenToSet(tupleFeatures)
    )
    dContext.featuresIndirect = extraFeatures[1]

    api = app.api
    F = api.F
    E = api.E
    L = api.L
    N = api.N
    otypeRank = N.otypeRank

    ltr = _getLtr(app, dContext)
    textCls = _getTextCls(app, fmt)

    containerN = None

    nType = F.otype.v(n)
    if condensed and condenseType:
        if nType == condenseType:
            containerN = n
        elif otypeRank[nType] &lt; otypeRank[condenseType]:
            ups = L.u(n, otype=condenseType)
            if ups:
                containerN = ups[0]

    slots = frozenset(
        E.oslots.s(
            n if not condensed or not condenseType or containerN is None else containerN
        )
    )

    oContext = OuterContext(ltr, textCls, slots, False, not not explain)
    passage = _getPassage(app, False, dContext, oContext, n)

    html = []

    boundaryCls = &#34;&#34;
    _doPretty(
        app,
        dContext,
        oContext,
        n,
        slots,
        boundaryCls,
        True,
        True,
        True,
        0,
        html,
        set(),
        {},
    )

    htmlStr = passage + &#34;&#34;.join(html)
    if _browse:
        return htmlStr
    dh(htmlStr)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.applib.display.displayApi"><code class="name flex">
<span>def <span class="ident">displayApi</span></span>(<span>app, silent)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the display API.</p>
<p>The display API provides methods to generate styled representations
of pieces of corpus texts in their relevant structures.
The main end-user functions are <code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a>(node)</code> and <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a>(node)</code>.</p>
<p><code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a></code> focuses on the plain text, <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code> focuses on structure
and feature display.</p>
<p>Related are <code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple()</a></code> and <code><a title="tf.applib.display.prettyTuple" href="#tf.applib.display.prettyTuple">prettyTuple()</a></code> that work for tuples
instead of nodes.</p>
<p>And further there are <code><a title="tf.applib.display.show" href="#tf.applib.display.show">show()</a></code> and <code><a title="tf.applib.display.table" href="#tf.applib.display.table">table()</a></code>, that work
with iterables of tuples of nodes (e.g. query results).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>obj</code></dt>
<dd>The high-level API object</dd>
</dl>
<p>silent:
The verbosity mode to perform this operation in.
Normally it is the same as for the app, but when we do an <code>A.reuse()</code>
we force <code>silent=True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L30-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def displayApi(app, silent):
    &#34;&#34;&#34;Produce the display API.

    The display API provides methods to generate styled representations
    of pieces of corpus texts in their relevant structures.
    The main end-user functions are `plain(node)` and `pretty(node)`.

    `plain()` focuses on the plain text, `pretty()` focuses on structure
    and feature display.

    Related are `plainTuple()` and `prettyTuple()` that work for tuples
    instead of nodes.

    And further there are `show()` and `table()`, that work
    with iterables of tuples of nodes (e.g. query results).

    Parameters
    ----------
    app: obj
        The high-level API object
    silent:
        The verbosity mode to perform this operation in.
        Normally it is the same as for the app, but when we do an `A.reuse()`
        we force `silent=True`.
    &#34;&#34;&#34;

    app.export = types.MethodType(export, app)
    app.table = types.MethodType(table, app)
    app.plainTuple = types.MethodType(plainTuple, app)
    app.plain = types.MethodType(plain, app)
    app.show = types.MethodType(show, app)
    app.prettyTuple = types.MethodType(prettyTuple, app)
    app.pretty = types.MethodType(pretty, app)
    app.loadCss = types.MethodType(loadCss, app)
    app.displaySetup = types.MethodType(displaySetup, app)
    app.displayReset = types.MethodType(displayReset, app)

    app.display = DisplaySettings(app)
    if not app._browse:
        app.loadCss()</code></pre>
</details>
</dd>
<dt id="tf.applib.display.displayReset"><code class="name flex">
<span>def <span class="ident">displayReset</span></span>(<span>app, *options)</span>
</code></dt>
<dd>
<div class="desc"><p>Restore display parameters to their defaults.</p>
<p>Reset the given display parameters to their default value and let the others
retain their current value.</p>
<p>So you can reset the display parameters selectively.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>list</code>, optional <code>[]</code></dt>
<dd>If present, only restore these options to their defaults.
Otherwise, restore all display settings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L100-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def displayReset(app, *options):
    &#34;&#34;&#34;Restore display parameters to their defaults.

    Reset the given display parameters to their default value and let the others
    retain their current value.

    So you can reset the display parameters selectively.

    Parameters
    ----------
    options: list, optional `[]`
        If present, only restore these options to their defaults.
        Otherwise, restore all display settings.
    &#34;&#34;&#34;

    display = app.display

    display.reset(*options)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.displaySetup"><code class="name flex">
<span>def <span class="ident">displaySetup</span></span>(<span>app, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up all display parameters.</p>
<p>Assigns working values to display parameters.
All subsequent calls to display functions such as <code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a></code> and <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code>
will use these values, unless they themselves are passed overriding
values as arguments.</p>
<p>These working values remain in effect until a new call to <code><a title="tf.applib.display.displaySetup" href="#tf.applib.display.displaySetup">displaySetup()</a></code>
assigns new values, or a call to <code><a title="tf.applib.display.displayReset" href="#tf.applib.display.displayReset">displayReset()</a></code> resets the values to the
defaults.</p>
<div class="admonition hint">
<p class="admonition-title">corpus settings</p>
<p>The defaults themselves come from the corpus settings, which are influenced
by its <code>config.yaml</code> file, if it exists. See <code><a title="tf.applib.settings" href="settings.html">tf.applib.settings</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Explicit values for selected options that act as overrides of the defaults.
A list of all available options is in <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L72-L97" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def displaySetup(app, **options):
    &#34;&#34;&#34;Set up all display parameters.

    Assigns working values to display parameters.
    All subsequent calls to display functions such as `plain` and `pretty`
    will use these values, unless they themselves are passed overriding
    values as arguments.

    These working values remain in effect until a new call to `displaySetup()`
    assigns new values, or a call to `displayReset()` resets the values to the
    defaults.

    !!! hint &#34;corpus settings&#34;
        The defaults themselves come from the corpus settings, which are influenced
        by its `config.yaml` file, if it exists. See `tf.applib.settings`.

    Parameters
    ----------
    options: dict
        Explicit values for selected options that act as overrides of the defaults.
        A list of all available options is in `tf.applib.displaysettings`.
    &#34;&#34;&#34;

    display = app.display

    display.setup(**options)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>app, tuples, toDir=None, toFile='results.tsv', **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports an iterable of tuples of nodes to an Excel friendly <code>.tsv</code> file.</p>
<div class="admonition hint">
<p class="admonition-title">Examples</p>
<p>See for detailed examples the
<a href="https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/bhsa/exportExcel.ipynb">exportExcel</a>
and
<a href="https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/oldbabylonian/exportExcel.ipynb">exportExcel</a>
notebooks.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tuples</code></strong> :&ensp;<code>iterable</code> of <code>tuples</code> of <code>integer</code></dt>
<dd>The integers are the nodes, together they form a table.</dd>
<dt><strong><code>toDir</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p>The destination directory for the exported file.
By default it is your Downloads folder.</p>
<p>If the directory does not exist, it will be created.</p>
</dd>
<dt><strong><code>toFile</code></strong> :&ensp;<code>boolean</code>, optional <code>results.tsv</code></dt>
<dd>The name of the exported file.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Display options, see <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</p>
<div class="admonition note">
<p class="admonition-title">details</p>
<ul>
<li><code>condensed</code>
Has no effect. Exports to Excel will not be condensed, because the
number of columns is variable per row in that case.
Excel itself has nice possibilities for grouping rows.
You can also filter your tuples by means of hand-coding
before exporting them.</li>
<li><code>condenseType</code>
The condense type influences for which nodes
the full text will be exported.
Only nodes that are "smaller" than the condense type will have
their full text exported.</li>
<li><code>fmt</code>
This display parameter specifies the text format for any nodes
that trigger a text value to be exported.</li>
<li><code>tupleFeatures</code>
This is a display parameter that steers which features are exported
with each member of the tuples in the list.</li>
</ul>
<p>If the iterable of tuples are the results of a query you have just
run, then an appropriate call to <code>displaySetup(tupleFeatures=...)</code>
has already been issued, so you can just say:</p>
<p><code>python
results = A.search(query)
A.export(results)</code></p>
</div>
</dd>
</dl>
<h2 id="results">Results</h2>
<p>A file <em>toFile</em> in directory <em>toDir</em> with the following content:</p>
<p>There will be a row for each tuple.
The columns are:</p>
<ul>
<li><strong>R</strong> the sequence number of the result tuple in the result list</li>
<li><strong>S1 S2 S3</strong> the section as book, chapter, verse, in separate columns;
the section is the section of the first non book/chapter node in the tuple</li>
<li><strong>NODEi TYPEi</strong> the node and its type,
for each node <strong>i</strong> in the result tuple</li>
<li><strong>TEXTi</strong> the full text of node <strong>i</strong>,
if the node type admits a concise text representation;
the criterion is whether the node type has a type not bigger than the
default condense type, which is app specific.
If you pass an explicit <code>condenseType=</code><em>xxx</em> as display parameter,
then this is the reference condenseType on which the decision is based.</li>
<li><strong>XFi</strong> the value of extra feature <strong>XF</strong> for node <strong>i</strong>,
where these features have been declared by a previous
displaySetup(tupleFeatures=&hellip;)`</li>
</ul>
<div class="admonition caution">
<p class="admonition-title">Encoding</p>
<p>The exported file is written in the <code>utf_16_le</code> encoding.
This ensures that Excel can open it without hassle, even if there
are non-latin characters inside.</p>
<p>When you want to read the exported file programmatically,
open it with <code>encoding=utf_16</code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L148-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def export(app, tuples, toDir=None, toFile=&#34;results.tsv&#34;, **options):
    &#34;&#34;&#34;Exports an iterable of tuples of nodes to an Excel friendly `.tsv` file.

    !!! hint &#34;Examples&#34;
        See for detailed examples the
        [exportExcel](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/bhsa/exportExcel.ipynb)
        and
        [exportExcel](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/oldbabylonian/exportExcel.ipynb)
        notebooks.

    Parameters
    ----------
    tuples: iterable of tuples of integer
        The integers are the nodes, together they form a table.
    toDir: string, optional `None`
        The destination directory for the exported file.
        By default it is your Downloads folder.

        If the directory does not exist, it will be created.
    toFile: boolean, optional `results.tsv`
        The name of the exported file.
    options: dict
        Display options, see `tf.applib.displaysettings`.

        !!! note &#34;details&#34;
            * `condensed`
              Has no effect. Exports to Excel will not be condensed, because the
              number of columns is variable per row in that case.
              Excel itself has nice possibilities for grouping rows.
              You can also filter your tuples by means of hand-coding
              before exporting them.
            * `condenseType`
              The condense type influences for which nodes
              the full text will be exported.
              Only nodes that are &#34;smaller&#34; than the condense type will have
              their full text exported.
            * `fmt`
              This display parameter specifies the text format for any nodes
              that trigger a text value to be exported.
            * `tupleFeatures`
              This is a display parameter that steers which features are exported
              with each member of the tuples in the list.

              If the iterable of tuples are the results of a query you have just
              run, then an appropriate call to `displaySetup(tupleFeatures=...)`
              has already been issued, so you can just say:

              ```python
              results = A.search(query)
              A.export(results)
              ```

    Results
    -------
    A file *toFile* in directory *toDir* with the following content:

    There will be a row for each tuple.
    The columns are:

    * **R** the sequence number of the result tuple in the result list
    * **S1 S2 S3** the section as book, chapter, verse, in separate columns;
      the section is the section of the first non book/chapter node in the tuple
    * **NODEi TYPEi** the node and its type,
      for each node **i** in the result tuple
    * **TEXTi** the full text of node **i**,
      if the node type admits a concise text representation;
      the criterion is whether the node type has a type not bigger than the
      default condense type, which is app specific.
      If you pass an explicit `condenseType=`*xxx* as display parameter,
      then this is the reference condenseType on which the decision is based.
    * **XFi** the value of extra feature **XF** for node **i**,
      where these features have been declared by a previous
      displaySetup(tupleFeatures=...)`

    !!! caution &#34;Encoding&#34;
        The exported file is written in the `utf_16_le` encoding.
        This ensures that Excel can open it without hassle, even if there
        are non-latin characters inside.

        When you want to read the exported file programmatically,
        open it with `encoding=utf_16`.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    fmt = dContext.fmt
    condenseType = dContext.condenseType
    tupleFeatures = dContext.tupleFeatures

    if toDir is None:
        toDir = os.path.expanduser(DOWNLOADS)
        if not os.path.exists(toDir):
            os.makedirs(toDir, exist_ok=True)
    toPath = f&#34;{toDir}/{toFile}&#34;

    resultsX = getResultsX(app, tuples, tupleFeatures, condenseType, fmt=fmt,)

    with open(toPath, &#34;w&#34;, encoding=&#34;utf_16_le&#34;) as fh:
        fh.write(
            &#34;\ufeff&#34;
            + &#34;&#34;.join(
                (&#34;\t&#34;.join(&#34;&#34; if t is None else str(t) for t in tup) + &#34;\n&#34;)
                for tup in resultsX
            )
        )</code></pre>
</details>
</dd>
<dt id="tf.applib.display.loadCss"><code class="name flex">
<span>def <span class="ident">loadCss</span></span>(<span>app)</span>
</code></dt>
<dd>
<div class="desc"><p>The CSS is looked up and then loaded into a notebook if we are not
running in the TF browser,
else the CSS is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L122-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadCss(app):
    &#34;&#34;&#34;The CSS is looked up and then loaded into a notebook if we are not
    running in the TF browser,
    else the CSS is returned.
    &#34;&#34;&#34;

    _browse = app._browse
    aContext = app.context
    css = aContext.css

    if _browse:
        return css

    cssPath = (
        f&#34;{os.path.dirname(os.path.dirname(os.path.abspath(__file__)))}&#34;
        f&#34;{SERVER_DISPLAY_BASE}&#34;
    )
    genericCss = &#34;&#34;
    for cssFile in SERVER_DISPLAY:
        with open(f&#34;{cssPath}/{cssFile}&#34;, encoding=&#34;utf8&#34;) as fh:
            genericCss += fh.read()

    tableCss = &#34;tr.tf, td.tf, th.tf { text-align: left ! important;}&#34;
    dh(f&#34;&lt;style&gt;&#34; + tableCss + genericCss + css + &#34;&lt;/style&gt;&#34;)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.plain"><code class="name flex">
<span>def <span class="ident">plain</span></span>(<span>app, n, explain=False, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the plain text of a node.</p>
<p>Displays the material that corresponds to a node in a compact way.
Nodes with little content will be represented by their text content,
nodes with large content will be represented by an identifying label.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>Node</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</dd>
<dt><strong><code>_inTuple</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the result is meant too end up in a table cell produced by
<code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple()</a></code>. In that case some extra node types count as big and will
not be displayed in full.</dd>
<dt><strong><code>_asString</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to deliver the result as a HTML string or to display it directly
inside a notebook. When the TF-browser uses this function it needs the
HTML string.</dd>
<dt><strong><code>explain</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to print a trace of which nodes have been visited and how these
calls have contributed to the end result.</dd>
</dl>
<h2 id="result">Result</h2>
<p>html string or <code>None</code>
Depending on <em>asString</em> above.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L517-L594" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plain(app, n, _inTuple=False, _asString=False, explain=False, **options):
    &#34;&#34;&#34;Display the plain text of a node.

    Displays the material that corresponds to a node in a compact way.
    Nodes with little content will be represented by their text content,
    nodes with large content will be represented by an identifying label.

    Parameters
    ----------
    n: integer
        Node
    options: dict
        Display options, see `tf.applib.displaysettings`.
    _inTuple: boolean, optional `False`
        Whether the result is meant too end up in a table cell produced by
        `plainTuple`. In that case some extra node types count as big and will
        not be displayed in full.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.

    Result
    ------
    html string or `None`
        Depending on *asString* above.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;plain&#34;, options):
        return &#34;&#34;

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml

    _browse = app._browse
    api = app.api
    E = api.E

    ltr = _getLtr(app, dContext)
    textCls = _getTextCls(app, fmt)
    slots = frozenset(E.oslots.s(n))

    oContext = OuterContext(ltr, textCls, slots, _inTuple, not not explain)
    passage = _getPassage(app, True, dContext, oContext, n)
    boundaryCls = &#34;&#34;
    rep = _doPlain(
        app,
        dContext,
        oContext,
        n,
        slots,
        boundaryCls,
        True,
        True,
        True,
        0,
        passage,
        [],
        set(),
        {},
    )
    sep = &#34; &#34; if passage and rep else &#34;&#34;

    result = passage + sep + rep

    if _browse or _asString:
        return result
    dh(result)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.plainTuple"><code class="name flex">
<span>def <span class="ident">plainTuple</span></span>(<span>app, tup, seq, item='result', position=None, opened=False, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the plain text of a tuple of nodes.</p>
<p>Displays the material that corresponds to a tuple of nodes
as a row of cells,
each displaying a member of the tuple by means of <code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tup</code></strong> :&ensp;<code>iterable</code> of <code>integer</code></dt>
<dd>The members of the tuple can be arbitrary nodes.</dd>
<dt><strong><code>seq</code></strong> :&ensp;<code>integer</code></dt>
<dd>an arbitrary number which will be displayed in the first cell.
This prepares the way for displaying query results, which come as
a sequence of tuples of nodes.</dd>
<dt><strong><code>item</code></strong> :&ensp;<code>string</code>, optional <code>result</code></dt>
<dd>A name for the tuple: it could be a result, or a chapter, or a line.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>Which position counts as the focus position.
If <em>seq</em> equals <em>position</em>, the tuple is in focus.
The effect is to add the CSS class <em>focus</em> to the output HTML
for the row of this tuple.</dd>
<dt><strong><code>opened</code></strong> :&ensp;<code> booolean</code>, optional <code>False</code></dt>
<dd>
<p>Whether this tuple should be expandable to a <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code> display.
The normal output of this row will be wrapped in a</p>
<p><code>html
&lt;details&gt;&lt;summary&gt;plain&lt;/summary&gt;pretty&lt;/details&gt;</code></p>
<p>pattern, so that the user can click a triangle to switch between plain
and pretty display.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>This option has only effect when used in the TF browser.</p>
</div>
</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</dd>
<dt><strong><code>_asString</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to deliver the result as a HTML string or to display it directly
inside a notebook. When the TF-browser uses this function it needs the
HTML string.</dd>
</dl>
<h2 id="result">Result</h2>
<p>html string or <code>None</code>
Depending on <em>asString</em> above.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L351-L514" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plainTuple(
    app, tup, seq, item=RESULT, position=None, opened=False, _asString=False, **options
):
    &#34;&#34;&#34;Display the plain text of a tuple of nodes.

    Displays the material that corresponds to a tuple of nodes
    as a row of cells,
    each displaying a member of the tuple by means of `plain`.

    Parameters
    ----------
    tup: iterable of integer
        The members of the tuple can be arbitrary nodes.
    seq: integer
        an arbitrary number which will be displayed in the first cell.
        This prepares the way for displaying query results, which come as
        a sequence of tuples of nodes.
    item: string, optional `result`
        A name for the tuple: it could be a result, or a chapter, or a line.
    position: integer, optional `None`
        Which position counts as the focus position.
        If *seq* equals *position*, the tuple is in focus.
        The effect is to add the CSS class *focus* to the output HTML
        for the row of this tuple.
    opened:  booolean, optional `False`
        Whether this tuple should be expandable to a `pretty` display.
        The normal output of this row will be wrapped in a

        ``` html
        &lt;details&gt;&lt;summary&gt;plain&lt;/summary&gt;pretty&lt;/details&gt;
        ```

        pattern, so that the user can click a triangle to switch between plain
        and pretty display.

        !!! caution
            This option has only effect when used in the TF browser.
    options: dict
        Display options, see `tf.applib.displaysettings`.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.

    Result
    ------
    html string or `None`
        Depending on *asString* above.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;plainTuple&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    fOtype = F.otype.v
    _browse = app._browse

    dContext = display.get(options)
    condenseType = dContext.condenseType
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    withPassage = dContext.withPassage
    skipCols = dContext.skipCols

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if withPassage is True:
        passageNode = _getRefMember(app, tup, dContext)
        passageRef = (
            &#34;&#34;
            if passageNode is None
            else app._sectionLink(passageNode)
            if _browse
            else app.webLink(passageNode, _asString=True)
        )
        passageRef = f&#39;&lt;span class=&#34;section ltr&#34;&gt;{passageRef}&lt;/span&gt;&#39;
    else:
        passageRef = &#34;&#34;

    newOptions = display.consume(options, &#34;withPassage&#34;)
    newOptionsH = display.consume(options, &#34;withPassage&#34;, &#34;highlights&#34;)

    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if _browse:
        prettyRep = (
            prettyTuple(app, tup, seq, withPassage=False, **newOptions)
            if opened
            else &#34;&#34;
        )
        current = &#34;focus&#34; if seq == position else &#34;&#34;
        attOpen = &#34;open &#34; if opened else &#34;&#34;
        tupSeq = &#34;,&#34;.join(str(n) for n in tup)
        if withPassage is True:
            sparts = T.sectionFromNode(passageNode, fillup=True)
            passageAtt = &#34; &#34;.join(
                f&#39;sec{i}=&#34;{sparts[i] if i &lt; len(sparts) else &#34;&#34;}&#34;&#39; for i in range(3)
            )
        else:
            passageAtt = &#34;&#34;

        plainRep = &#34;&#34;.join(
            &#34;&lt;span&gt;&#34;
            + mdEsc(
                app.plain(
                    n,
                    _inTuple=True,
                    withPassage=_doPassage(dContext, i),
                    highlights=highlights,
                    **newOptionsH,
                )
            )
            + &#34;&lt;/span&gt;&#34;
            for (i, n) in enumerate(tup)
        )
        html = (
            f&#39;&lt;details class=&#34;pretty dtrow {current}&#34; seq=&#34;{seq}&#34; {attOpen}&gt;&#39;
            f&#34;&lt;summary&gt;&#34;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;pq fa fa-solar-panel fa-xs&#34;&#39;
            f&#39; title=&#34;show in context&#34; {passageAtt}&gt;&lt;/a&gt;&#39;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;sq&#34; tup=&#34;{tupSeq}&#34;&gt;{seq}&lt;/a&gt;&#39;
            f&#34; {passageRef} {plainRep}&#34;
            f&#34;&lt;/summary&gt;&#34;
            f&#39;&lt;div class=&#34;pretty&#34;&gt;{prettyRep}&lt;/div&gt;&#39;
            f&#34;&lt;/details&gt;&#34;
        )
        return html

    html = [str(seq)]
    if withPassage is True:
        html.append(passageRef)
    for (i, n) in enumerate(tup):
        html.append(
            app.plain(
                n,
                _inTuple=True,
                _asString=True,
                withPassage=_doPassage(dContext, i),
                highlights=highlights,
                **newOptionsH,
            )
        )
    html = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;td class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/td&gt;&lt;td class=&#34;tf&#34;&gt;&#39;.join(html)
        + &#34;&lt;/td&gt;&lt;/tr&gt;&#34;
    )
    if _asString:
        return html

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;
    head = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
        + f&#34;&lt;/th&gt;&lt;/tr&gt;&#34;
    )
    html = f&#34;&lt;table&gt;&#34; + head + &#34;&#34;.join(html) + &#34;&lt;/table&gt;&#34;

    dh(html)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.pretty"><code class="name flex">
<span>def <span class="ident">pretty</span></span>(<span>app, n, explain=False, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the material that corresponds to a node in a graphical way.</p>
<p>The internal structure of the nodes that are involved is also revealed.
In addition, extra features and their values are displayed with the nodes.</p>
<div class="admonition hint">
<p class="admonition-title">Controlling pretty displays</p>
<p>The following <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>
are particularly relevant to pretty displays:</p>
<ul>
<li><code>condenseType</code>: the standard container to display nodes in;</li>
<li><code>full</code>: whether to display a reference to the material or the material itself;</li>
<li><code>extraFeatures</code>: additional features to
display</li>
<li><code>tupleFeatures</code>: additional features to
display (primarily for <code><a title="tf.applib.display.export" href="#tf.applib.display.export">export()</a></code>.</li>
</ul>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>Node</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</dd>
<dt><strong><code>explain</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to print a trace of which nodes have been visited and how these
calls have contributed to the end result.</dd>
</dl>
<h2 id="result">Result</h2>
<p>html string or <code>None</code>
When used for the TF browser (<code>app._browse</code> is true), the result is returned
as HTML. Otherwise the result is directly displayed in a notebook.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L729-L836" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pretty(app, n, explain=False, **options):
    &#34;&#34;&#34;Displays the material that corresponds to a node in a graphical way.

    The internal structure of the nodes that are involved is also revealed.
    In addition, extra features and their values are displayed with the nodes.

    !!! hint &#34;Controlling pretty displays&#34;
        The following `tf.applib.displaysettings`
        are particularly relevant to pretty displays:

        * `condenseType`: the standard container to display nodes in;
        * `full`: whether to display a reference to the material or the material itself;
        * `extraFeatures`: additional features to  display
        * `tupleFeatures`: additional features to  display (primarily for `export`.

    Parameters
    ----------
    n: integer
        Node
    options: dict
        Display options, see `tf.applib.displaysettings`.
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.

    Result
    ------
    html string or `None`
        When used for the TF browser (`app._browse` is true), the result is returned
        as HTML. Otherwise the result is directly displayed in a notebook.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;pretty&#34;, options):
        return &#34;&#34;

    _browse = app._browse

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    tupleFeatures = dContext.tupleFeatures
    extraFeatures = dContext.extraFeatures
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml
    dContext.features = sorted(
        flattenToSet(extraFeatures[0]) | flattenToSet(tupleFeatures)
    )
    dContext.featuresIndirect = extraFeatures[1]

    api = app.api
    F = api.F
    E = api.E
    L = api.L
    N = api.N
    otypeRank = N.otypeRank

    ltr = _getLtr(app, dContext)
    textCls = _getTextCls(app, fmt)

    containerN = None

    nType = F.otype.v(n)
    if condensed and condenseType:
        if nType == condenseType:
            containerN = n
        elif otypeRank[nType] &lt; otypeRank[condenseType]:
            ups = L.u(n, otype=condenseType)
            if ups:
                containerN = ups[0]

    slots = frozenset(
        E.oslots.s(
            n if not condensed or not condenseType or containerN is None else containerN
        )
    )

    oContext = OuterContext(ltr, textCls, slots, False, not not explain)
    passage = _getPassage(app, False, dContext, oContext, n)

    html = []

    boundaryCls = &#34;&#34;
    _doPretty(
        app,
        dContext,
        oContext,
        n,
        slots,
        boundaryCls,
        True,
        True,
        True,
        0,
        html,
        set(),
        {},
    )

    htmlStr = passage + &#34;&#34;.join(html)
    if _browse:
        return htmlStr
    dh(htmlStr)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.prettyTuple"><code class="name flex">
<span>def <span class="ident">prettyTuple</span></span>(<span>app, tup, seq, item='result', **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the material that corresponds to a tuple of nodes in a graphical way.</p>
<p>The member nodes of the tuple will be collected into containers, which
will be displayed with <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code>, and the nodes of the tuple
will be highlighted in the containers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tup</code></strong> :&ensp;<code>iterable</code> of <code>integer</code></dt>
<dd>The members of the tuple can be arbitrary nodes.</dd>
<dt><strong><code>seq</code></strong> :&ensp;<code>integer</code></dt>
<dd>an arbitrary number which will be displayed in the heading.
This prepares the way for displaying query results, which come as
a sequence of tuples of nodes.</dd>
<dt><strong><code>item</code></strong> :&ensp;<code>string</code>, optional <code>result</code></dt>
<dd>A name for the tuple: it could be a result, or a chapter, or a line.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</dd>
</dl>
<h2 id="result">Result</h2>
<p>html string or <code>None</code>
When used for the TF browser (<code>app._browse</code> is true), the result is returned
as HTML. Otherwise the result is directly displayed in a notebook.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L658-L726" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def prettyTuple(app, tup, seq, item=RESULT, **options):
    &#34;&#34;&#34;Displays the material that corresponds to a tuple of nodes in a graphical way.

    The member nodes of the tuple will be collected into containers, which
    will be displayed with `pretty()`, and the nodes of the tuple
    will be highlighted in the containers.

    Parameters
    ----------
    tup: iterable of integer
        The members of the tuple can be arbitrary nodes.
    seq: integer
        an arbitrary number which will be displayed in the heading.
        This prepares the way for displaying query results, which come as
        a sequence of tuples of nodes.
    item: string, optional `result`
        A name for the tuple: it could be a result, or a chapter, or a line.
    options: dict
        Display options, see `tf.applib.displaysettings`.

    Result
    ------
    html string or `None`
        When used for the TF browser (`app._browse` is true), the result is returned
        as HTML. Otherwise the result is directly displayed in a notebook.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;prettyTuple&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    skipCols = dContext.skipCols

    _browse = app._browse

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if len(tup) == 0:
        if _browse:
            return &#34;&#34;
        else:
            return

    api = app.api
    N = api.N
    sortKey = N.sortKey

    containers = {tup[0]} if condensed else condenseSet(api, tup, condenseType)
    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if not _browse:
        dh(f&#34;&lt;p&gt;&lt;b&gt;{item}&lt;/b&gt; &lt;i&gt;{seq}&lt;/i&gt;&lt;/p&gt;&#34;)
    if _browse:
        html = []
    for t in sorted(containers, key=sortKey):
        h = app.pretty(
            t, highlights=highlights, **display.consume(options, &#34;highlights&#34;),
        )
        if _browse:
            html.append(h)
    if _browse:
        return &#34;&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>app, tuples, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays an iterable of tuples of nodes.</p>
<p>The elements of the list are displayed by <code>A.prettyTuple()</code>.</p>
<div class="admonition hint">
<p class="admonition-title">condense, condenseType</p>
<p>You can condense the list first to containers of <code>condenseType</code>,
before displaying the list.
Pass the display parameters <code>condense</code> and <code>condenseType</code>.
See <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tuples</code></strong> :&ensp;<code>iterable</code> of <code>tuples</code> of <code>integer</code></dt>
<dd>The integers are the nodes, together they form a table.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</dd>
</dl>
<h2 id="result">Result</h2>
<p>html string or <code>None</code>
When used for the TF browser (<code>app._browse</code> is true), the result is returned
as HTML. Otherwise the result is directly displayed in a notebook.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L600-L655" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(app, tuples, **options):
    &#34;&#34;&#34;Displays an iterable of tuples of nodes.

    The elements of the list are displayed by `A.prettyTuple()`.

    !!! hint &#34;condense, condenseType&#34;
        You can condense the list first to containers of `condenseType`,
        before displaying the list.
        Pass the display parameters `condense` and `condenseType`.
        See `tf.applib.displaysettings`.

    Parameters
    ----------
    tuples: iterable of tuples of integer
        The integers are the nodes, together they form a table.
    options: dict
        Display options, see `tf.applib.displaysettings`.

    Result
    ------
    html string or `None`
        When used for the TF browser (`app._browse` is true), the result is returned
        as HTML. Otherwise the result is directly displayed in a notebook.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;show&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    api = app.api
    F = api.F

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_SHOW, item):
        item = F.otype.v(tup[0]) if condensed and condenseType else RESULT
        prettyTuple(app, tup, i, item=item, skipCols=set(), **newOptions)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.table"><code class="name flex">
<span>def <span class="ident">table</span></span>(<span>app, tuples, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Plain displays of an iterable of tuples of nodes in a table.</p>
<p>The list is displayed as a compact markdown table.
Every row is prepended with the sequence number in the iterable,
and then displayed by <code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple()</a></code></p>
<div class="admonition hint">
<p class="admonition-title">condense, condenseType</p>
<p>You can condense the list first to containers of <code>condenseType</code>,
before displaying the list.
Pass the display parameters <code>condense</code> and <code>condenseType</code>.
See <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tuples</code></strong> :&ensp;<code>iterable</code> of <code>tuples</code> of <code>integer</code></dt>
<dd>The integers are the nodes, together they form a table.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see <code><a title="tf.applib.displaysettings" href="displaysettings.html">tf.applib.displaysettings</a></code>.</dd>
<dt><strong><code>_asString</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to deliver the result as a HTML string or to display it directly
inside a notebook. When the TF-browser uses this function it needs the
HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/9fe4ffc86ce466d0085ac02e20e14e8f04ade33b/tf/applib/display.py#L262-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def table(app, tuples, _asString=False, **options):
    &#34;&#34;&#34;Plain displays of an iterable of tuples of nodes in a table.

    The list is displayed as a compact markdown table.
    Every row is prepended with the sequence number in the iterable,
    and then displayed by `plainTuple`

    !!! hint &#34;condense, condenseType&#34;
        You can condense the list first to containers of `condenseType`,
        before displaying the list.
        Pass the display parameters `condense` and `condenseType`.
        See `tf.applib.displaysettings`.

    Parameters
    ----------
    tuples: iterable of tuples of integer
        The integers are the nodes, together they form a table.
    options: dict
        Display options, see `tf.applib.displaysettings`.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    fOtype = F.otype.v

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    withPassage = dContext.withPassage
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;

    html = []
    one = True

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_TABLE, item):
        if one:
            heads = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
            html.append(
                f&#39;&lt;tr class=&#34;tf&#34;&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;{heads}&lt;/th&gt;&#39;
                f&#34;&lt;/tr&gt;&#34;
            )
            one = False
        html.append(
            plainTuple(
                app,
                tup,
                i,
                item=item,
                position=None,
                opened=False,
                _asString=True,
                skipCols=set(),
                **newOptions,
            )
        )
    html = &#34;&lt;table&gt;&#34; + &#34;\n&#34;.join(html) + &#34;&lt;/table&gt;&#34;
    if _asString:
        return html
    dh(html)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="/text-fabric/images/tf-small.png"></a></p>
<p><a href="/text-fabric/index.html">tf home</a> - <a href="/text-fabric/cheatsheet.html">cheat sheet</a></p>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/annotation site:annotation.github.io site:www.annotation.nl"
data-gaCategoryParameter="tf.applib.display">
</div>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#display">Display</a><ul>
<li><a href="#display-parameters">Display parameters</a></li>
<li><a href="#display-algorithm">Display algorithm</a><ul>
<li><a href="#descendant-types">Descendant types</a></li>
<li><a href="#chunkify">Chunkify</a></li>
<li><a href="#intersecting-nodes">Intersecting nodes</a></li>
<li><a href="#canonical-order">Canonical order</a></li>
<li><a href="#substrate">Substrate</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#called-and-done">Called and done</a></li>
<li><a href="#all-pieces-together">All pieces together</a></li>
<li><a href="#notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.applib" href="index.html">tf.applib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.applib.display.displayApi" href="#tf.applib.display.displayApi">displayApi</a></code></li>
<li><code><a title="tf.applib.display.displayReset" href="#tf.applib.display.displayReset">displayReset</a></code></li>
<li><code><a title="tf.applib.display.displaySetup" href="#tf.applib.display.displaySetup">displaySetup</a></code></li>
<li><code><a title="tf.applib.display.export" href="#tf.applib.display.export">export</a></code></li>
<li><code><a title="tf.applib.display.loadCss" href="#tf.applib.display.loadCss">loadCss</a></code></li>
<li><code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain</a></code></li>
<li><code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple</a></code></li>
<li><code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty</a></code></li>
<li><code><a title="tf.applib.display.prettyTuple" href="#tf.applib.display.prettyTuple">prettyTuple</a></code></li>
<li><code><a title="tf.applib.display.show" href="#tf.applib.display.show">show</a></code></li>
<li><code><a title="tf.applib.display.table" href="#tf.applib.display.table">table</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://www.annotation.nl">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="/text-fabric/images/DANS-logo.png" width=200></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>