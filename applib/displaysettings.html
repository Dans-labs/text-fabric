<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>tf.applib.displaysettings API documentation</title>
<meta name="description" content="Display Settings â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.applib.displaysettings</code></h1>
</header>
<section id="section-intro">
<h1 id="display-settings">Display Settings.</h1>
<p>Display options are used by
<code><a title="tf.applib.display.plain" href="display.html#tf.applib.display.plain">plain()</a></code>
and
<code><a title="tf.applib.display.pretty" href="display.html#tf.applib.display.pretty">pretty()</a></code>
and other display functions.</p>
<p>This class manages</p>
<ul>
<li>the provisining of options with defaults,</li>
<li>the overriding options by passing options as arguments to display functions</li>
<li>the retrieval of option values by the rest of the application.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">distinction between interface options and display options</p>
<ul>
<li>all interface options are also display options and can be passed as arguments
to display functions</li>
<li>interface options have a checkbox in the TF browser</li>
</ul>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lineNumbers</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p><strong>interface option</strong>
indicates whether line numbers should be displayed.</p>
<div class="admonition note">
<p class="admonition-title">source data</p>
<p>Line numbers are with respect to the source data file that is contains the
origin material of the node in question, if a datasource provides
a feature that contains line numbers.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">configuration</p>
<p>Whether a corpus has line numbers, and in which feature they are stored
for which node types is configured in a corpus dependent app.</p>
</div>
</dd>
<dt><strong><code>prettyTypes</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd><strong>interface option</strong>
indicates whether node types should always be displayed in pretty displays.
The node type of slot nodes is never displayed.</dd>
<dt><strong><code>queryFeatures</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd><strong>interface option</strong>
indicates whether pretty displays should show the features
mentioned in the last query and their values.</dd>
<dt><strong><code>showChunks</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd><strong>interface option</strong>
The corpus data may contain nodes that represent discontinuous pieces of text.
Some corpora also offer node types that represent all continuous chunks of those
nodes.
By default, the advanced API, will
show those chunks with the original nodes wrapped around them, with dotted borders
indicating the discontinuities..
When pretty-displaying such structures, the display of the chunks themselves can be
reduced, because they tend to make displays unwieldy.</dd>
<dt><strong><code>showGraphics</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd><strong>interface option</strong>
indicates whether plain and pretty displays should include associated
graphic elements,
provided the corpus offers those elements, and the advanced API has found a way to
locate those elements.</dd>
<dt><strong><code>standardFeatures</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd><strong>interface option</strong>
indicates whether pretty displays should show standard features and their values.</dd>
<dt><strong><code>withNodes</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p><strong>interface option</strong>
indicates whether node numbers should be displayed.</p>
<div class="admonition hint">
<p class="admonition-title">zooming in</p>
<p>If you are in a Jupyter notebook, you can inspect in a powerful way by
setting <code>withNodes=True</code>. Then every part of a pretty display shows
its node number, and you can use the following APIs
to look up all information
about each node that the corpus has to offer:</p>
<ul>
<li><strong>F</strong>: <code><a title="tf.core.api.NodeFeature" href="../core/api.html#tf.core.api.NodeFeature">NodeFeature</a></code></li>
<li><strong>E</strong>: <code><a title="tf.core.api.EdgeFeature" href="../core/api.html#tf.core.api.EdgeFeature">EdgeFeature</a></code></li>
<li><strong>L</strong>: <code><a title="tf.core.locality.Locality" href="../core/locality.html#tf.core.locality.Locality">Locality</a></code></li>
<li><strong>T</strong>: <code><a title="tf.core.text.Text" href="../core/text.html#tf.core.text.Text">Text</a></code></li>
</ul>
</div>
</dd>
<dt><strong><code>withTypes</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd><strong>interface option</strong>
indicates whether node types should be displayed.
The node type of slot nodes is never displayed.</dd>
<dt><strong><code>baseTypes</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>
<p>Node types at the bottom of pretty displays.
They are also the node type that receive the primary highlights
(colored backgrounds), whereas the highlights for other node types
are colored boxes.</p>
<p>The default is app dependent, usually the slot type of the corpus.</p>
</dd>
<dt><strong><code>colorMap</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>
<p>Which nodes of a tuple (or list of tuples) will be highlighted.
If <code>colorMap</code> is <code>None</code> or missing, all nodes will be highlighted with
the default highlight color, which is yellow.</p>
<p>But you can assign different colors to the members of the tuple:
<code>colorMap</code> must be a dictionary that maps the positions in a tuple
to a color.</p>
<ul>
<li>If a position is not mapped, it will not be highlighted.</li>
<li>If it is mapped to the empty string, it gets the default highlight color.</li>
<li>Otherwise, it should be mapped to a string that is a valid
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value">CSS color</a>.</li>
</ul>
<div class="admonition hint">
<p class="admonition-title">color names</p>
<p>The link above points to a series of handy color names and their previews.</p>
</div>
<div class="admonition note">
<p class="admonition-title">highlights takes precedence over colorMap</p>
<p>If both <code>highlights</code> and <code>colorMap</code> are given, <code>colorMap</code> is ignored.</p>
<p>If you need to micro-manage, <code>highlights</code> is your thing.
Whenever possible, use <code>colorMap</code>.</p>
</div>
</dd>
<dt><strong><code>condensed</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p>indicates one of two modes of displaying the result list:</p>
<ul>
<li><code>True</code>: instead of showing all results one by one,
we show container nodes with all results in it highlighted.
That way, we blur the distinction between the individual results,
but it is easier to oversee where the results are.
This is how SHEBANQ displays its query results.
<strong>See also the parameter <code>condenseType</code></strong>.</li>
<li><code>False</code>: make a separate display for each result tuple.
This gives the best account of the exact result set.</li>
</ul>
<div class="admonition caution">
<p class="admonition-title">mixing up highlights</p>
<p>Condensing may mix-up the highlight coloring.
If a node occurs in two results, at different positions
in the tuple, the <code>colorMap</code> wants to assign it two colors!
Yet one color will be chosen, and it is unpredictable which one.</p>
</div>
</dd>
<dt><strong><code>condenseType</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The type of container to be used for condensing results.
The default is app dependent, usually <code>verse</code> or <code>tablet</code>.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>int</code>, optional <code>None</code></dt>
<dd><code>end</code> is the end point in the iterable of results.
If <code>None</code>, displaying will stop after the end of the iterable.</dd>
<dt><strong><code>extraFeatures</code></strong> :&ensp;<code>string | iterable</code>, optional <code>()</code></dt>
<dd>
<p>A string or iterable of feature names.
These features will be loaded automatically.
In pretty displays these features will show up as <code>feature=value</code>,
provided the value is not <code>None</code>, or something like None.</p>
<div class="admonition hint">
<p class="admonition-title">Automatic loading</p>
<p>These features will load automatically, no explicit loading is
necessary.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">values from other nodes</p>
<p>Suppose you want to display a value from a related node, e.g. a <code>gloss</code>
that is available on <code>lex</code> nodes but not on <code>word</code> nodes, and you
want to show it on the word nodes.
Then you may specifiy <code>lex:gloss</code>, meaning that Text-Fabric will
look up a <code>lex</code> node from the current node (by means of <code>L.u(w, otype='lex')</code>,
and if it finds one, it will read the <code>gloss</code> feature from it.</p>
</div>
</dd>
<dt><strong><code>full</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p>For pretty displays: indicates that the whole object should be
displayed, even if it is big.</p>
<div class="admonition hint">
<p class="admonition-title">Big objects</p>
<p>Big objects are objects of a type that is bigger than the default condense type.</p>
</div>
</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p><code>fmt</code> is the text format that will be used for the representation.
E.g. <code>text-orig-full</code>.</p>
<div class="admonition hint">
<p class="admonition-title">Text formats</p>
<p>Use <code>T.formats</code> to inspect what text formats are available in your corpus.</p>
</div>
</dd>
<dt><strong><code>highlights</code></strong> :&ensp;<code>dict | set</code>, optional <code>{}</code></dt>
<dd>
<p>When nodes such as verses and sentences and lines and cases are displayed
by <code>plain()</code> or <code>pretty()</code>,
their contents is also displayed. You can selectively highlight
those parts.</p>
<p><code>highlights={}</code> is a set or mapping of nodes that should be highlighted.
Only nodes that are involved in the display will be highlighted.</p>
<p>If <code>highlights</code> is a set, its nodes will be highlighted
with a default color (yellow).</p>
<p>If it is a dictionary, it should map nodes to colors.
Any color that is a valid
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value">CSS color</a>
qualifies.</p>
<p>If you map a node to the empty string, it will get the default highlight color.</p>
<div class="admonition note">
<p class="admonition-title">one big highlights dictionary</p>
<p>It is OK to first compose a big highlights dictionary
for many tuples of nodes,
and then run <code>prettyTuple()</code> for many different tuples
with the same <code>highlights</code>.
It does not harm performance if <code>highlights</code> maps
lots of nodes outside the tuple as well.</p>
</div>
</dd>
<dt><strong><code>noneValues</code></strong> :&ensp;<code>set</code>, optional <code>None</code></dt>
<dd>
<p>A set of values for which no display should be generated.
The default set is <code>None</code> and the strings <code>NA</code>, <code>none</code>, <code>unknown</code>.</p>
<div class="admonition hint">
<p class="admonition-title">None is useful</p>
<p>Keep <code>None</code> in the set. If not, all custom features will be displayed
for all kinds of nodes. So you will see clause types on words,
and part of speech on clause atoms, al with value <code>None</code>.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Suppress common values</p>
<p>You can use <code>noneValues</code> also to suppress the normal values of a feature,
in order to attract attention to the more special values, e.g.</p>
<p><code>python
noneValues={None, 'NA', 'unknown', 'm', 'sg', 'p3'}</code></p>
</div>
<div class="admonition caution">
<p class="admonition-title">None values affect all features</p>
<p>Beware of putting to much in <code>noneValues</code>.
The contents of <code>noneValues</code> affect the display of
all features, not only the custom features.</p>
</div>
</dd>
<dt><strong><code>skipCols</code></strong> :&ensp;<code>set</code>, optional <code>set()</code></dt>
<dd>indicates columns to skip in <code>show()</code>, <code>table()</code>, <code>prettyTuple()</code> and <code>plainTuple()</code>.
Maybe a space-separated string of numbers, or an iterable of integers.
Columns start at 1.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd><code>start</code> is the starting point for displaying the iterable of results.
(1 is the first one).
If <code>None</code>, displaying starts at the first element of the iterable.</dd>
<dt><strong><code>suppress</code></strong> :&ensp;<code>set</code>, optional <code>set()</code></dt>
<dd>a set of names of features that should NOT be displayed.
By default, quite a number of features is displayed for a node.
If you find they clutter the display, you can turn them off
selectively.</dd>
<dt><strong><code>tupleFeatures</code></strong> :&ensp;<code>iterable</code> of <code>2-tuples</code>, optional <code>()</code></dt>
<dd>
<p>A bit like "extraFeatures" above, but more intricate.
Only meant to steer the
<code>A.export()</code> function below into outputting the
features you choose.</p>
<p>It should be a tuple of pairs
<code>(i, features)</code>
which means that to member <code>i</code> of a result tuple we assign extra <code>features</code>.</p>
<p><code>features</code> may be given as an iterable or a space separated string of feature names.</p>
</dd>
<dt><strong><code>withPassage</code></strong> :&ensp;<code>boolean</code> or <code>set</code>, optional <code>True</code></dt>
<dd>indicates whether a passage label should be put next to a displayed node
or tuple of nodes.
When passed with <code>table()</code>, or <code>plainTuple()</code>,
the value may also be a set of integers, indicating the columns whose
nodes will be linked with a web link
(the first column is column 1).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L0-L241" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../../docs/applib/displaysettings.md
&#34;&#34;&#34;

from ..core.helpers import setFromValue
from .helpers import parseFeatures, SEQ_TYPES1, SEQ_TYPES2


INTERFACE_OPTIONS = (
    (
        &#34;withNodes&#34;,
        False,
        &#34;withn&#34;,
        &#34;show nodes&#34;,
        &#34;Show the node number for every node in the results.&#34;
        &#34; The node number is your access to all information about that node.&#34;
        &#34; If you click on it, it will be copied to the &lt;i&gt;node pad&lt;/i&gt;&#34;,
    ),
    (
        &#34;withTypes&#34;,
        False,
        &#34;witht&#34;,
        &#34;show types&#34;,
        &#34;Show the node type for every node in the results&#34;,
    ),
    (
        &#34;prettyTypes&#34;,
        True,
        &#34;withtp&#34;,
        &#34;always show types when expanded&#34;,
        &#34;Show the node type for every node in the expanded view, even if &lt;b&gt;show types&lt;/b&gt; is off&#34;,
    ),
    (
        &#34;standardFeatures&#34;,
        False,
        &#34;showf&#34;,
        &#34;show features&#34;,
        &#34;Show the standard feature values for every node in the results&#34;,
    ),
    (
        &#34;queryFeatures&#34;,
        True,
        &#34;showf&#34;,
        &#34;show features&#34;,
        &#34;Show the features mentioned in the last query for every node in the results&#34;,
    ),
    (
        &#34;showChunks&#34;,
        False,
        &#34;showc&#34;,
        &#34;show chunks&#34;,
        &#34;Show chunk types fully. Only if the TF data has node types and companion chunked node types&#34;,
    ),
    (
        &#34;lineNumbers&#34;,
        False,
        &#34;linen&#34;,
        &#34;source lines&#34;,
        &#34;Show source line numbers with the nodes. Only if the TF data has a feature for line numbers.&#34;,
    ),
    (
        &#34;showGraphics&#34;,
        True,
        &#34;graphics&#34;,
        &#34;graphic elements&#34;,
        &#34;Show graphical companion elements with the nodes.&#34;
        &#34; Only if the data set implements the logic for it&#34;,
    ),
)


# &lt;p&gt;&lt;b title=&#34;withTypes&#34;&gt;Show types&lt;/b&gt;{longDesc}&lt;/p&gt;

DISPLAY_OPTIONS = dict(
    baseTypes=None,
    colorMap=None,
    condensed=False,
    condenseType=None,
    end=None,
    extraFeatures=((), {}),
    full=False,
    fmt=None,
    highlights={},
    noneValues={None},
    skipCols=set(),
    start=None,
    suppress=set(),
    tupleFeatures=(),
    withPassage=True,
)

DISPLAY_OPTIONS.update({o[0]: o[1] for o in INTERFACE_OPTIONS})


class DisplayCurrent:
    def __init__(self, options):
        for (k, v) in options.items():
            setattr(self, k, v)


class DisplaySettings:

    def __init__(self, app):
        self.app = app

        aContext = app.context
        interfaceDefaults = aContext.interfaceDefaults

        self.displayDefaults = {}
        displayDefaults = self.displayDefaults

        for (k, v) in DISPLAY_OPTIONS.items():
            value = (
                interfaceDefaults[k] if k in interfaceDefaults else aContext.get(k, v)
            )
            displayDefaults[k] = value

        self.reset()

    def reset(self, *options):
        api = self.app.api
        error = api.error

        for option in options:
            if option not in self.displayDefaults:
                error(f&#39;WARNING: unknown display option &#34;{option}&#34; will be ignored&#39;)
                continue
            self.displaySettings[option] = self.displayDefaults[option]
        if not options:
            self.displaySettings = {k: v for (k, v) in self.displayDefaults.items()}

    def setup(self, **options):
        for (option, value) in options.items():
            normValue = self.normalize(option, value)
            if not normValue:
                continue
            self.displaySettings[option] = normValue[1]

    def normalize(self, option, value):
        api = self.app.api
        error = api.error

        if option not in self.displayDefaults:
            error(f&#39;WARNING: unknown display option &#34;{option}&#34; will be ignored&#39;)
            return None

        if option == &#34;extraFeatures&#34;:
            (bare, indirect) = parseFeatures(value)
            api.ensureLoaded(bare)
            value = (bare, indirect)
        elif option == &#34;tupleFeatures&#34;:
            api.ensureLoaded(value)
            if type(value) is str:
                value = value.split() if value else []
        elif option in {&#34;suppress&#34;}:
            if type(value) is str:
                value = set(value.split()) if value else set()
        elif option in {&#34;skipCols&#34;}:
            if not value:
                value = set()
            elif type(value) is str:
                value = set(int(v) for v in value.split()) if value else set()
            elif type(value) not in {set, frozenset}:
                value = set(value)
        elif option in {&#34;withPassage&#34;}:
            if not value:
                value = False
            elif type(value) is str:
                value = set(int(v) for v in value.split()) if value else set()
            elif type(value) in {list, tuple, dict}:
                value = set(value)
            else:
                value = True
        elif option == &#34;highlights&#34;:
            if value is not None and type(value) is not dict:
                value = {m: &#34;&#34; for m in value}
        elif option == &#34;baseTypes&#34;:
            value = setFromValue(value)
        return (True, value)

    def check(self, msg, options):
        api = self.app.api
        Fotype = api.F.otype
        sectionTypeSet = api.T.sectionTypeSet
        error = api.error

        good = True
        for (option, value) in options.items():
            if option not in self.displaySettings:
                error(f&#39;ERROR in {msg}(): unknown display option &#34;{option}={value}&#34;&#39;)
                good = False
            if option in {&#34;baseTypes&#34;, &#34;condenseType&#34;}:
                if value is not None:
                    legalValues = set(Fotype.all)
                    if option == &#34;baseTypes&#34;:
                        legalValues -= sectionTypeSet
                        testVal = setFromValue(value)
                        isLegal = all(v in legalValues for v in testVal)
                    else:
                        isLegal = value in legalValues
                    if not isLegal:
                        error(
                            f&#39;ERROR in {msg}(): illegal node type in &#34;{option}={value}&#34;&#39;
                        )
                        good = False
            elif option == &#34;extraFeatures&#34;:
                if value is not None:
                    if (
                        type(value) in SEQ_TYPES1
                        and len(value) == 2
                        and type(value[0]) in SEQ_TYPES2
                        and type(value[1]) is dict
                    ):
                        indirect = value[1]
                        legalValues = set(Fotype.all)
                        isLegal = all(v in legalValues for v in indirect)
                        if not isLegal:
                            error(
                                f&#34;ERROR in {msg}(): illegal node type in&#34;
                                f&#39; &#34;{option}={value}&#34;&#39;
                            )
                            good = False
        return good

    def get(self, options):
        displayDefaults = self.displayDefaults
        displaySettings = self.displaySettings

        normOptions = {}

        for option in displayDefaults:
            value = options.get(
                option, displaySettings.get(option, displayDefaults[option])
            )
            normValue = self.normalize(option, value)
            if normValue:
                normOptions[option] = normValue[1]

        return DisplayCurrent(normOptions)

    def consume(self, options, *remove):
        return {o: options[o] for o in options if o not in remove}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.applib.displaysettings.DisplayCurrent"><code class="flex name class">
<span>class <span class="ident">DisplayCurrent</span></span>
<span>(</span><span>options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L95-L98" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DisplayCurrent:
    def __init__(self, options):
        for (k, v) in options.items():
            setattr(self, k, v)</code></pre>
</details>
</dd>
<dt id="tf.applib.displaysettings.DisplaySettings"><code class="flex name class">
<span>class <span class="ident">DisplaySettings</span></span>
<span>(</span><span>app)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L101-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DisplaySettings:

    def __init__(self, app):
        self.app = app

        aContext = app.context
        interfaceDefaults = aContext.interfaceDefaults

        self.displayDefaults = {}
        displayDefaults = self.displayDefaults

        for (k, v) in DISPLAY_OPTIONS.items():
            value = (
                interfaceDefaults[k] if k in interfaceDefaults else aContext.get(k, v)
            )
            displayDefaults[k] = value

        self.reset()

    def reset(self, *options):
        api = self.app.api
        error = api.error

        for option in options:
            if option not in self.displayDefaults:
                error(f&#39;WARNING: unknown display option &#34;{option}&#34; will be ignored&#39;)
                continue
            self.displaySettings[option] = self.displayDefaults[option]
        if not options:
            self.displaySettings = {k: v for (k, v) in self.displayDefaults.items()}

    def setup(self, **options):
        for (option, value) in options.items():
            normValue = self.normalize(option, value)
            if not normValue:
                continue
            self.displaySettings[option] = normValue[1]

    def normalize(self, option, value):
        api = self.app.api
        error = api.error

        if option not in self.displayDefaults:
            error(f&#39;WARNING: unknown display option &#34;{option}&#34; will be ignored&#39;)
            return None

        if option == &#34;extraFeatures&#34;:
            (bare, indirect) = parseFeatures(value)
            api.ensureLoaded(bare)
            value = (bare, indirect)
        elif option == &#34;tupleFeatures&#34;:
            api.ensureLoaded(value)
            if type(value) is str:
                value = value.split() if value else []
        elif option in {&#34;suppress&#34;}:
            if type(value) is str:
                value = set(value.split()) if value else set()
        elif option in {&#34;skipCols&#34;}:
            if not value:
                value = set()
            elif type(value) is str:
                value = set(int(v) for v in value.split()) if value else set()
            elif type(value) not in {set, frozenset}:
                value = set(value)
        elif option in {&#34;withPassage&#34;}:
            if not value:
                value = False
            elif type(value) is str:
                value = set(int(v) for v in value.split()) if value else set()
            elif type(value) in {list, tuple, dict}:
                value = set(value)
            else:
                value = True
        elif option == &#34;highlights&#34;:
            if value is not None and type(value) is not dict:
                value = {m: &#34;&#34; for m in value}
        elif option == &#34;baseTypes&#34;:
            value = setFromValue(value)
        return (True, value)

    def check(self, msg, options):
        api = self.app.api
        Fotype = api.F.otype
        sectionTypeSet = api.T.sectionTypeSet
        error = api.error

        good = True
        for (option, value) in options.items():
            if option not in self.displaySettings:
                error(f&#39;ERROR in {msg}(): unknown display option &#34;{option}={value}&#34;&#39;)
                good = False
            if option in {&#34;baseTypes&#34;, &#34;condenseType&#34;}:
                if value is not None:
                    legalValues = set(Fotype.all)
                    if option == &#34;baseTypes&#34;:
                        legalValues -= sectionTypeSet
                        testVal = setFromValue(value)
                        isLegal = all(v in legalValues for v in testVal)
                    else:
                        isLegal = value in legalValues
                    if not isLegal:
                        error(
                            f&#39;ERROR in {msg}(): illegal node type in &#34;{option}={value}&#34;&#39;
                        )
                        good = False
            elif option == &#34;extraFeatures&#34;:
                if value is not None:
                    if (
                        type(value) in SEQ_TYPES1
                        and len(value) == 2
                        and type(value[0]) in SEQ_TYPES2
                        and type(value[1]) is dict
                    ):
                        indirect = value[1]
                        legalValues = set(Fotype.all)
                        isLegal = all(v in legalValues for v in indirect)
                        if not isLegal:
                            error(
                                f&#34;ERROR in {msg}(): illegal node type in&#34;
                                f&#39; &#34;{option}={value}&#34;&#39;
                            )
                            good = False
        return good

    def get(self, options):
        displayDefaults = self.displayDefaults
        displaySettings = self.displaySettings

        normOptions = {}

        for option in displayDefaults:
            value = options.get(
                option, displaySettings.get(option, displayDefaults[option])
            )
            normValue = self.normalize(option, value)
            if normValue:
                normOptions[option] = normValue[1]

        return DisplayCurrent(normOptions)

    def consume(self, options, *remove):
        return {o: options[o] for o in options if o not in remove}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.applib.displaysettings.DisplaySettings.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, msg, options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L181-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check(self, msg, options):
    api = self.app.api
    Fotype = api.F.otype
    sectionTypeSet = api.T.sectionTypeSet
    error = api.error

    good = True
    for (option, value) in options.items():
        if option not in self.displaySettings:
            error(f&#39;ERROR in {msg}(): unknown display option &#34;{option}={value}&#34;&#39;)
            good = False
        if option in {&#34;baseTypes&#34;, &#34;condenseType&#34;}:
            if value is not None:
                legalValues = set(Fotype.all)
                if option == &#34;baseTypes&#34;:
                    legalValues -= sectionTypeSet
                    testVal = setFromValue(value)
                    isLegal = all(v in legalValues for v in testVal)
                else:
                    isLegal = value in legalValues
                if not isLegal:
                    error(
                        f&#39;ERROR in {msg}(): illegal node type in &#34;{option}={value}&#34;&#39;
                    )
                    good = False
        elif option == &#34;extraFeatures&#34;:
            if value is not None:
                if (
                    type(value) in SEQ_TYPES1
                    and len(value) == 2
                    and type(value[0]) in SEQ_TYPES2
                    and type(value[1]) is dict
                ):
                    indirect = value[1]
                    legalValues = set(Fotype.all)
                    isLegal = all(v in legalValues for v in indirect)
                    if not isLegal:
                        error(
                            f&#34;ERROR in {msg}(): illegal node type in&#34;
                            f&#39; &#34;{option}={value}&#34;&#39;
                        )
                        good = False
    return good</code></pre>
</details>
</dd>
<dt id="tf.applib.displaysettings.DisplaySettings.consume"><code class="name flex">
<span>def <span class="ident">consume</span></span>(<span>self, options, *remove)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L241-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def consume(self, options, *remove):
    return {o: options[o] for o in options if o not in remove}</code></pre>
</details>
</dd>
<dt id="tf.applib.displaysettings.DisplaySettings.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L225-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get(self, options):
    displayDefaults = self.displayDefaults
    displaySettings = self.displaySettings

    normOptions = {}

    for option in displayDefaults:
        value = options.get(
            option, displaySettings.get(option, displayDefaults[option])
        )
        normValue = self.normalize(option, value)
        if normValue:
            normOptions[option] = normValue[1]

    return DisplayCurrent(normOptions)</code></pre>
</details>
</dd>
<dt id="tf.applib.displaysettings.DisplaySettings.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, option, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L139-L179" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(self, option, value):
    api = self.app.api
    error = api.error

    if option not in self.displayDefaults:
        error(f&#39;WARNING: unknown display option &#34;{option}&#34; will be ignored&#39;)
        return None

    if option == &#34;extraFeatures&#34;:
        (bare, indirect) = parseFeatures(value)
        api.ensureLoaded(bare)
        value = (bare, indirect)
    elif option == &#34;tupleFeatures&#34;:
        api.ensureLoaded(value)
        if type(value) is str:
            value = value.split() if value else []
    elif option in {&#34;suppress&#34;}:
        if type(value) is str:
            value = set(value.split()) if value else set()
    elif option in {&#34;skipCols&#34;}:
        if not value:
            value = set()
        elif type(value) is str:
            value = set(int(v) for v in value.split()) if value else set()
        elif type(value) not in {set, frozenset}:
            value = set(value)
    elif option in {&#34;withPassage&#34;}:
        if not value:
            value = False
        elif type(value) is str:
            value = set(int(v) for v in value.split()) if value else set()
        elif type(value) in {list, tuple, dict}:
            value = set(value)
        else:
            value = True
    elif option == &#34;highlights&#34;:
        if value is not None and type(value) is not dict:
            value = {m: &#34;&#34; for m in value}
    elif option == &#34;baseTypes&#34;:
        value = setFromValue(value)
    return (True, value)</code></pre>
</details>
</dd>
<dt id="tf.applib.displaysettings.DisplaySettings.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, *options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L120-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reset(self, *options):
    api = self.app.api
    error = api.error

    for option in options:
        if option not in self.displayDefaults:
            error(f&#39;WARNING: unknown display option &#34;{option}&#34; will be ignored&#39;)
            continue
        self.displaySettings[option] = self.displayDefaults[option]
    if not options:
        self.displaySettings = {k: v for (k, v) in self.displayDefaults.items()}</code></pre>
</details>
</dd>
<dt id="tf.applib.displaysettings.DisplaySettings.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, **options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/14f3be75f103a789dbf393029a15a849b85ee615/tf/applib/displaysettings.py#L132-L137" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setup(self, **options):
    for (option, value) in options.items():
        normValue = self.normalize(option, value)
        if not normValue:
            continue
        self.displaySettings[option] = normValue[1]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><img src="/text-fabric/images/tf-small.png"></p>
<p><a href="/text-fabric/cheatsheet.html">cheat sheet</a></p>
<p><a href="https://github.com/annotation">annotation on GitHub</a></p>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/annotation site:annotation.github.io site:www.annotation.nl"
data-gaCategoryParameter="tf.applib.displaysettings">
</div>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#display-settings">Display Settings.</a><ul>
<li><a href="#parameters">Parameters</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.applib" href="index.html">tf.applib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.applib.displaysettings.DisplayCurrent" href="#tf.applib.displaysettings.DisplayCurrent">DisplayCurrent</a></code></h4>
</li>
<li>
<h4><code><a title="tf.applib.displaysettings.DisplaySettings" href="#tf.applib.displaysettings.DisplaySettings">DisplaySettings</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.applib.displaysettings.DisplaySettings.check" href="#tf.applib.displaysettings.DisplaySettings.check">check</a></code></li>
<li><code><a title="tf.applib.displaysettings.DisplaySettings.consume" href="#tf.applib.displaysettings.DisplaySettings.consume">consume</a></code></li>
<li><code><a title="tf.applib.displaysettings.DisplaySettings.get" href="#tf.applib.displaysettings.DisplaySettings.get">get</a></code></li>
<li><code><a title="tf.applib.displaysettings.DisplaySettings.normalize" href="#tf.applib.displaysettings.DisplaySettings.normalize">normalize</a></code></li>
<li><code><a title="tf.applib.displaysettings.DisplaySettings.reset" href="#tf.applib.displaysettings.DisplaySettings.reset">reset</a></code></li>
<li><code><a title="tf.applib.displaysettings.DisplaySettings.setup" href="#tf.applib.displaysettings.DisplaySettings.setup">setup</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://www.annotation.nl">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="/text-fabric/images/DANS-logo.png" width=200></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>