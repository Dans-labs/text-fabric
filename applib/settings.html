<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>tf.applib.settings API documentation</title>
<meta name="description" content="App settings â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.applib.settings</code></h1>
</header>
<section id="section-intro">
<h1 id="app-settings">App settings</h1>
<p>Developers can create TF-apps by specifying a <code>config.yaml</code> with settings.
These settings will be read, checked, and transformed into configuration data
that is read by the app, see <code><a title="tf.applib.settings.showContext" href="#tf.applib.settings.showContext">showContext()</a></code></p>
<p>See for examples:
* <a href="https://github.com/annotation/app-bhsa/blob/master/code/config.yaml">bhsa</a>.
* <a href="https://github.com/annotation/app-uruk/blob/master/code/config.yaml">uruk</a>.</p>
<h1 id="config-specs">Config specs</h1>
<p>Here is a specification of all settings you can configure for an app.</p>
<p>Each section below corresponds to a main key in the <code>config.yaml</code> of an app.</p>
<p>Everything is optional, an empty <code>config.yaml</code> is valid.
Text-Fabric tries hard to supply reasonable defaults on the basis of the corpus
data it has loaded.</p>
<h2 id="apiversion"><code>apiVersion</code></h2>
<p>To let Text-Fabric check whether its version matches the version of the TF-app</p>
<dl>
<dt>Default:</dt>
<dd>integer <code>1</code></dd>
</dl>
<hr>
<h2 id="datadisplay"><code>dataDisplay</code></h2>
<p>Generic display parameters.</p>
<dl>
<dt>Default:</dt>
<dd>dict <code>{}</code></dd>
</dl>
<hr>
<h3 id="browsecontentpretty"><code>browseContentPretty</code></h3>
<p>Whether the content is shown as a list of subsectional items
contained in the selected item or as a pretty display of the item itself</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>false</code></dd>
</dl>
<hr>
<h3 id="browsenavlevel"><code>browseNavLevel</code></h3>
<p>The section level up to which the TF-browser shows a hierarchical tree.</p>
<dl>
<dt>Values</dt>
<dd><code>1</code> or <code>2</code></dd>
<dt>Default:</dt>
<dd><em>one less than the number of section types</em></dd>
</dl>
<hr>
<h3 id="examplesection"><code>exampleSection</code></h3>
<p>Placeholder text for passage entry fields in the TF browser.
"book" is the node type of top level sections.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>book 1</code></dd>
</dl>
<hr>
<h3 id="examplesectionhtml"><code>exampleSectionHtml</code></h3>
<p>Formatted placeholder text for passage entry fields in the TF browser.
"book" is the node type of top level sections.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>&lt;code&gt;piece 1&lt;/code&gt;</code></dd>
</dl>
<hr>
<h3 id="excludedfeatures"><code>excludedFeatures</code></h3>
<p>Features that are present in the data source but will not be loaded for the TF browser.</p>
<dl>
<dt>Default:</dt>
<dd>list <code>[]</code></dd>
</dl>
<hr>
<h3 id="nonevalues"><code>noneValues</code></h3>
<p>Feature values that are deemed uninformative, e.g. <code>None</code>, <code>'NA'</code></p>
<dl>
<dt>Default:</dt>
<dd>list <code>[]</code></dd>
</dl>
<hr>
<h3 id="sectionsep1"><code>sectionSep1</code></h3>
<p>Separator between main and secondary sections in a passage reference;
e.g. the space in <code>Genesis 1:1</code></p>
<h2 id="default">Default</h2>
<p>string: <code> </code> (<em>space</em>)</p>
<hr>
<h3 id="sectionsep2"><code>sectionSep2</code></h3>
<p>Separator between secondary and tertiary sections in a passage reference;
e.g. the <code>:</code> in <code>Genesis 1:1</code></p>
<dl>
<dt>Default:</dt>
<dd>string <code>:</code></dd>
</dl>
<hr>
<h3 id="showverseintuple"><code>showVerseInTuple</code></h3>
<p>Show the full text of verselike nodes in tables and tuples
(in <code><a title="tf.applib.display.plainTuple" href="display.html#tf.applib.display.plainTuple">plainTuple()</a></code> and <code><a title="tf.applib.display.table" href="display.html#tf.applib.display.table">table()</a></code>)</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>false</code></dd>
</dl>
<hr>
<h3 id="textformats"><code>textFormats</code></h3>
<pre><code>textFormats:
    layout-orig-full: layoutRich
</code></pre>
<p>Additional text formats that can use HTML styling.</p>
<dl>
<dt>Keys</dt>
<dd>names of existing and new text formats.</dd>
<dt>Values</dt>
<dd>(methd, style)</dd>
</dl>
<p>where</p>
<dl>
<dt>method</dt>
<dd>name of a method that implements that format.
If the name is <code>xxx</code>, or n<code>typexxx</code>
then <code>app.py</code> should implement a method <code>fmt_xxx(node, **kwargs)</code>
to produce html for node <code>node</code>.
This function will passed the <code>outer=True</code> if called by a plain or pretty at
the outer level, level=recursion depth, and <code>first=True, last=True</code>
if the node is on a leftmost resp.
rightmost branch in the tree of children below the outer node.</dd>
<dt>style</dt>
<dd>a keyword indicating in what style the format should be set:
normal, source, trans, phono, orig.</dd>
<dt>Default:</dt>
<dd>dict <code>{}</code></dd>
</dl>
<hr>
<h2 id="docs"><code>docs</code></h2>
<p>In the settings below you may refer to provenance settings, like <code>{org}</code> and <code>{repo}</code>
You may refer to nbviewer with <code>{urlNb}</code> and to github with <code>{urlGh}</code></p>
<dl>
<dt>Default:</dt>
<dd>dict <code>{}</code></dd>
</dl>
<hr>
<h3 id="chartext"><code>charText</code></h3>
<p>Hint text when a user hovers over the <code>charUlr</code> link to a page that describes how
TF features represent text</p>
<dl>
<dt>Default:</dt>
<dd>string <code>''</code></dd>
</dl>
<hr>
<h3 id="charurl"><code>charUrl</code></h3>
<p>Start page for character coding documentation.
TF supports several writing systems with character- and transcription tables.
Replace <code>Transcription</code> by the writing system relevant for your data.
<code>{tfDoc}</code> will be replaced by the root location of the online TF documentation.</p>
<p>If it is left out, it will point to the transcription table in the TF docs
that corresponds with the writing setting.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>{tfDoc}/writing/transcription/</code></dd>
</dl>
<hr>
<h3 id="docbase"><code>docBase</code></h3>
<p>Base url page for the corpus documentation</p>
<dl>
<dt>Default:</dt>
<dd>string <code>{docRoot}/{org}/{repo}/blob/master/docs</code></dd>
</dl>
<hr>
<h3 id="docext"><code>docExt:</code></h3>
<p>The extension of documentation pages</p>
<dl>
<dt>Default:</dt>
<dd>string <code>.md</code></dd>
</dl>
<hr>
<h3 id="docpage"><code>docPage</code></h3>
<p>Landing page for the corpus documentation</p>
<dl>
<dt>Default:</dt>
<dd>string <code>home</code></dd>
</dl>
<hr>
<h3 id="docroot"><code>docRoot</code></h3>
<p>Where the docs are: on Github (default), or on nbviewer (<code>{urlNb}</code>) or somewhere else.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>{urlGh}</code></dd>
</dl>
<hr>
<h3 id="featurebase"><code>featureBase</code></h3>
<p>URL template for feature by feature documentation
<code>{tfDoc}</code> will be replaced by the root location of the documentation as set above.
The variable part <code>&lt;feature&gt;</code> will be replaced by the names of the features.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>{docBase}/features/&lt;feature&gt;{docExt}</code></dd>
</dl>
<hr>
<h3 id="featurepage"><code>featurePage</code></h3>
<p>Start page for feature documentation,
will be filled in into <code>featureBase</code> for the variable <code>&lt;feature&gt;</code>.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>home</code></dd>
</dl>
<hr>
<h2 id="interfacedefaults"><code>interfaceDefaults</code></h2>
<p>The following options can be passed to the display functions
<code><a title="tf.applib.display.plain" href="display.html#tf.applib.display.plain">plain()</a></code> and <code><a title="tf.applib.display.pretty" href="display.html#tf.applib.display.pretty">pretty()</a></code>.
They can also be set in the Text-Fabric Browser.
The values set here are the defaults as given by this app.
Not all options work for all corpora.</p>
<dl>
<dt>Default:</dt>
<dd>dict <code>{}</code></dd>
</dl>
<hr>
<h3 id="linenumbers"><code>lineNumbers</code></h3>
<p>Whether to show the line numbers within the source files of the corpus.
The line numbers come from the source files from which the TF dataset
has been generated.</p>
<p>Those types for which <code>lineNumber="feat"</code> has been configured in <code>typeDisplay</code> below
will cause plain and pretty to display a source line number, which will
come from the feature <code>feat</code>.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>false</code> for apps that define line numbers, else <code>null</code>.</dd>
</dl>
<hr>
<h3 id="prettytypes"><code>prettyTypes</code></h3>
<p>If <code>withTypes</code> is <code>true</code>, you can set <code>prettyTypes</code> to <code>false</code> to prevent
showing the types in pretty displays.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>true</code> (all apps)</dd>
</dl>
<hr>
<h3 id="queryfeatures"><code>queryFeatures</code></h3>
<p>Whether to show the features mentioned in the last query in pretty displays.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>true</code> (all apps)</dd>
</dl>
<hr>
<h3 id="showhidden"><code>showHidden</code></h3>
<p>Whether to use nodes of hidden types when unraveling nodes.</p>
<p>Showing hidden types may clutter the displays, but sometimes you need that information.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>false</code> for apps that define hidden node types, else <code>null</code>.</dd>
</dl>
<hr>
<h3 id="standardfeatures"><code>standardFeatures</code></h3>
<p>Whether to show the standard features and their values in pretty displays.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>true</code></dd>
</dl>
<hr>
<h3 id="showgraphics"><code>showGraphics</code></h3>
<p>Whether to show additional graphics.
Applies only to nodes of types for which <code>graphics=true</code> has been configured in
<code>typeDisplay</code> below.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>true</code> for apps that have graphics data, else <code>null</code>.</dd>
</dl>
<hr>
<h3 id="withnodes"><code>withNodes</code></h3>
<p>Whether to show the node numbers.</p>
<dl>
<dt>Default:</dt>
<dd>boolen <code>false</code></dd>
</dl>
<hr>
<h3 id="withtypes-false"><code>withTypes: false</code></h3>
<p>Whether to show the node type.</p>
<dl>
<dt>Default:</dt>
<dd>boolen <code>false</code></dd>
</dl>
<hr>
<h2 id="provenancespec"><code>provenanceSpec</code></h2>
<p>Provenance parameters are used to fetch data and to report provenance in data exports.</p>
<dl>
<dt>Default:</dt>
<dd>dict <code>{}</code></dd>
</dl>
<hr>
<h3 id="corpus"><code>corpus</code></h3>
<p>A user-friendly name for your corpus.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="doi"><code>doi</code></h3>
<p>If your data is archived: the doi of the archived version, like
<code>xx.yyyy/archive.zzzzzzz</code> without the <code>&lt;https://doi.org/</code>&gt; in front.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="graphicsrelative"><code>graphicsRelative</code></h3>
<p>If not <code>null</code>, it is the path inside the repo to the directory
that holds the graphics files</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="modulespecs"><code>moduleSpecs</code></h3>
<p>You can specify modules that should always be loaded with the core data,
as many as you want:</p>
<pre><code>moduleSpecs = (
  dict(
      org=&quot;researcher1&quot;,
      repo=&quot;work1&quot;,
      relative=&quot;tf&quot;,
      corpus=&quot;speicalism1&quot;,
      docUrl=(
          &quot;{urlNb}/researcher1/work1/blob/master/programs/specialism1.ipynb&quot;
      ),
      doi=&quot;xx.yyyy/archive.zzzzzzz&quot;,
  ),
  dict(
      org=&quot;researcher2&quot;,
      repo=&quot;work2&quot;,
      relative=&quot;tf&quot;,
      corpus=&quot;speicalism2&quot;,
      docUrl=(
          &quot;{urlNb}/researcher2/work2/blob/master/programs/specialism2.ipynb&quot;
      ),
      doi=&quot;uu.vvvv/archive.wwwwwww&quot;,
  ),
)
</code></pre>
<p>If modules have the same org or repo as the main data, these do not have to
be specified.
If a module has a relative attribute equal to <code><a title="tf" href="../index.html">tf</a></code>, it can be left out.</p>
<dl>
<dt>Default:</dt>
<dd>list <code>[]</code></dd>
</dl>
<hr>
<h3 id="org"><code>org</code></h3>
<p>The GitHub organisation name under which your TF data resides.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>annotation</code></dd>
</dl>
<hr>
<h3 id="relative"><code>relative</code></h3>
<p>The path inside the repo to the directory
that holds the version directories of the tf data.</p>
<dl>
<dt>Default:</dt>
<dd>string <code><a title="tf" href="../index.html">tf</a></code></dd>
</dl>
<hr>
<h3 id="repo"><code>repo</code></h3>
<p>The GitHub repo name under which your TF data resides</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p><em>org/repo</em> = <code>annotation/default</code> acts as placeholder for app-less datasets.</p>
</div>
<dl>
<dt>Default:</dt>
<dd>string <code>default</code></dd>
</dl>
<hr>
<h3 id="version"><code>version</code></h3>
<p>The version directory with the actual <code><a title="tf" href="../index.html">tf</a></code> files that will be used.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="webbase"><code>webBase</code></h3>
<p>If present, the base url for an online edition of the corpus.</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="webhint"><code>webHint</code></h3>
<p>If passed, will be used as hint text when the user hovers over a web link</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="weblang"><code>webLang</code></h3>
<p>If passed, the language in which section headings must be generated in web links</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="weblexid"><code>webLexId</code></h3>
<p>If present, it is either:</p>
<ul>
<li>the name of a feature that contains the lexeme id for lexeme nodes.</li>
</ul>
<p>or</p>
<ul>
<li><code>true</code> and then the app should implement <code>app.getLexId(n)</code>
that computes lexeme ids for lexeme nodes.</li>
</ul>
<p>The lexeme id is the one used in the online edition of the corpus to point to lexemes.</p>
<dl>
<dt>Default:</dt>
<dd>string | boolean <code>null</code></dd>
</dl>
<hr>
<h3 id="weburl"><code>webUrl</code></h3>
<p>If present, <code>webLink(node)</code> will use this as a template to generate a url
to an online edition of the node.</p>
<p>The following place holders will be honoured:</p>
<ul>
<li><code>{webBase}</code>: the webBase above</li>
<li><code>&lt;1&gt;</code> : value for section heading 1</li>
<li><code>&lt;2&gt;</code> : value for section heading 2</li>
<li><code>&lt;3&gt;</code> : value for section heading 3</li>
<li><code>{version}</code>: version of the TF resource</li>
</ul>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="weburllex"><code>webUrlLex</code></h3>
<p>If present, <code>webLink(node)</code> will use this as a template to generate a url
to an online edition of the lexeme node.</p>
<p>The following place holders will be honoured:
*
<code>{webBase}</code>: the <code>webBase</code> value above
*
<code>&lt;lid&gt;</code> : value for the id of the lexeme
*
<code>{version}</code> version of the TF resource</p>
<dl>
<dt>Default:</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="zip"><code>zip</code></h3>
<p>Only used by <code>text-fabric-zip</code> when collecting data into zip files
as attachments to a GitHub release.</p>
<p>If left to <code>null</code>, will be configured to use the main repo and the modules.</p>
<p>You can also use this scheme to include other data from the repository.
Note that graphics data will be packaged automatically.</p>
<p>You can specify the main repo, modules, and related data:</p>
<ul>
<li>
<p><code>zip=["repo"]</code>: Only the main module.</p>
</li>
<li>
<p><code>zip=["repo", "mod1", "mod2"]</code> : if org and relative for the modules
are the same as for are the main repo)</p>
</li>
</ul>
<dl>
<dt>Default:</dt>
<dd>
<p>list <code>["repo"] + [("org1", "mod1", "relative1"), ("org2", "mod2", "relative2")]</code></p>
<p>where all modules mentioned in the moduleSpecs will be filled in.</p>
</dd>
</dl>
<hr>
<h2 id="typedisplay"><code>typeDisplay</code></h2>
<p>Here are the type-specific display parameters.
If some types do not need configuration, you may leave them out.</p>
<p>The keys are node types as they exist in the corpus for which this is an app.
The value for each key is a dictionary with the following possible contents
(you may leave out keys if you are content with its default value).</p>
<dl>
<dt>Default:</dt>
<dd>dict <code>{}</code></dd>
</dl>
<hr>
<h3 id="base"><code>base</code></h3>
<p>If present and <code>true</code>: this type acts as the base type.</p>
<dl>
<dt>plain display</dt>
<dd>if the node needs to be highlighted, it gets a coloured background.
Nodes of other types receive their highlights as coloured borders
around their boxes.</dd>
<dt>pretty</dt>
<dd>children of these nodes are not expanded further, but displayed in
plain mode (with highlighting).</dd>
<dt>Default:</dt>
<dd>boolean <code>true</code> for the slot type, <code>false</code> for other types.</dd>
</dl>
<hr>
<h3 id="boundary"><code>boundary</code></h3>
<p>If true, will only mark the start and end boundaries of the node,
without wrapping its descendants in a new box.</p>
<div class="admonition caution">
<p class="admonition-title">gaps</p>
<p>If the node has gaps, they will not be marked.</p>
</div>
<dl>
<dt>Default:</dt>
<dd>boolean <code>false</code></dd>
</dl>
<hr>
<h3 id="children"><code>children</code></h3>
<p>Which type of child nodes to be included in the display.
The value should be a node type or a set of node types:</p>
<pre><code>children: subphrase
</code></pre>
<pre><code>children:
  - subphrase
  - word
</code></pre>
<h3 id="xchildren"><code>xChildren</code></h3>
<p>Which type of child nodes to be excluded in the display.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Use this if you want to exclude some types of nodes directly appearing
inside other nodes, e.g. in
<a href="https://github.com/annotation/app-dss/blob/master/code/config.yaml">dss</a>.
where we want to prevent signs to be directly displayed below lines, because
there should always be a word around the signs.
The DSS has end-of-line tokens, outside any word, but inside the lines.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Loss of material</p>
<p>By excluding certain child types you may loose slots in the display.
This might be intentional, as in the DSS, but it could lead to
unwanted omissions.</p>
</div>
<p>The value should be a node type or a set of node types:</p>
<pre><code>xChildren: sign
</code></pre>
<pre><code>xChildren:
  - sign
</code></pre>
<dl>
<dt>Default:</dt>
<dd>string | list, <code>[]</code></dd>
</dl>
<hr>
<h3 id="childrenplain"><code>childrenPlain</code></h3>
<p>Some types correspond to long sections. Such big types will not be expanded
in pretty displays. If you also want to generate abreviated plain displays
you can say <code>childrenPlain: false</code>.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>true</code></dd>
</dl>
<hr>
<h3 id="condense"><code>condense</code></h3>
<p>If <code>true</code>: this type is the default condense type.</p>
<p>When displaying tuples of nodes,
they will be divided over displays of nodes of this type.</p>
<p>The default is:</p>
<p><code>true</code> for the lowest section type, if there are section types defined in <code>otext.tf</code>.</p>
<p>If there are no sections, we pick a medium-sized node type.
If there are no such node types, we pick the slot type, but this is pathological.</p>
<dl>
<dt>Default:</dt>
<dd>boolean <code>true</code></dd>
</dl>
<hr>
<h3 id="features"><code>features</code></h3>
<p>Pretty displays: which node features to display as <code>name=value</code>.</p>
<p>You can also specify lookup feature values for upper nodes, e.g. <code>{lex:gloss}</code>
which will look for a <code>lex</code> node above the current node and retrieve its <code>gloss</code> value.</p>
<dl>
<dt>Default:</dt>
<dd>list of string <code>''</code></dd>
</dl>
<hr>
<h3 id="featuresbare-feat1-feat2"><code>featuresBare: feat1 feat2</code></h3>
<p>Pretty displays: which features to display by value only
(the feature name is not mentioned).</p>
<p>Things like <code>{lex:gloss}</code> are allowed.</p>
<dl>
<dt>Default:</dt>
<dd>list of string <code>''</code></dd>
</dl>
<hr>
<h3 id="flow"><code>flow:</code></h3>
<p>Pretty: whether the container should arrange its subdisplays as a column or as a row.</p>
<p>Values: <code>hor</code>, <code>ver</code></p>
<dl>
<dt>Default:</dt>
<dd>
<p>string</p>
<ul>
<li><code>ver</code> if level is 3 (typically section types), except for the verselike types</li>
<li><code>ver</code> if level is 0 (typically slot types and lexeme types)</li>
<li><code>hor</code> if level is 1 or 2 (typically linguistic types at sentence level) and
for the verselike types</li>
</ul>
</dd>
</dl>
<hr>
<h3 id="graphics"><code>graphics</code></h3>
<p>If <code>true</code>, then there is additional graphics available for nodes of this
type.</p>
<p>The app needs to define a function</p>
<pre><code>getGraphics(node, nodeType, isOuter) =&gt; HTML code for sourcing the graphics
</code></pre>
<p>See <a href="https://github.com/annotation/app-uruk/blob/master/code/app.py">uruk</a>.</p>
<dl>
<dt>Default</dt>
<dd>boolean <code>null</code></dd>
</dl>
<hr>
<h3 id="level"><code>level</code></h3>
<p>Pretty: the visual style of the container box of this node, values 0, 1, 2, 3.
The bigger the number, the heavier the borders of the boxes.</p>
<p>The default is:</p>
<ul>
<li>3 for types known as section or structure types, including the verselike types</li>
<li>0 for the slot type and types known as lexeme types</li>
<li>1 or 2 for the remaining types: the bigger types are 2, the smaller types are 1</li>
</ul>
<dl>
<dt>Default</dt>
<dd>integer <code>1</code></dd>
</dl>
<hr>
<h3 id="lexocc"><code>lexOcc</code></h3>
<p>If present, indicates that this is a lexeme type,
and it points to the type of things that are occurrences of lexemes.
Lexemes are displayed with an indication of their first and last occurrence.</p>
<dl>
<dt>Default</dt>
<dd>string <em>slotType</em></dd>
</dl>
<hr>
<h3 id="linenumber"><code>lineNumber</code></h3>
<p>If present, it should be the name of a feature that holds source line numbers.</p>
<dl>
<dt>Default</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="stretch"><code>stretch</code></h3>
<p>Pretty: whether the children should be stretched in the direction perpendicular
to their stacking.</p>
<p>The default is:</p>
<ul>
<li><code>true</code> if the children form a row (then each child is stretched vertically)</li>
<li><code>false</code> if the children form a column
(then each child is NOT stretched horizontally).</li>
</ul>
<dl>
<dt>Default</dt>
<dd>boolean <code>true</code></dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>For some types in
<a href="https://github.com/annotation/app-uruk/blob/master/code/config.yaml">uruk</a>
it is needed to deviate from the default.</p>
</div>
<hr>
<h3 id="hidden"><code>hidden</code></h3>
<p>Plain and pretty: whether nodes of this type must be hidden by default.
See for example the bhsa, where the <code>atom</code> types are hidden.</p>
<p>Nodes that unravel to other nodes will exclude nodes of hidden types from
the unraveling, unless you pass the display option <code>showHidden=True</code>.</p>
<dl>
<dt>Default</dt>
<dd>boolean <code>false</code></dd>
</dl>
<hr>
<h3 id="label-template"><code>label, template</code></h3>
<p>Node contribution for plain and pretty displays (template is for plain displays,
label is for pretty displays).</p>
<p>You can have features filled in by mentioning them by name in the template, e.g.
<code>{name1} - {name2}</code>.</p>
<p>If you specify <code>true</code> as the template or label, the node information will be
the result of:</p>
<ul>
<li>section and structure types nodes: a heading</li>
<li>other nodes: plain text of the node</li>
</ul>
<dl>
<dt>Default:</dt>
<dd>
<p>string</p>
<ul>
<li><code>true</code> for the slot type</li>
<li><code>true</code> for the section and structure types</li>
<li><code>""</code> for all other types</li>
</ul>
</dd>
</dl>
<hr>
<h3 id="style"><code>style</code></h3>
<p>Formatting key for plain and pretty displays.</p>
<p>The label or template may need a special style to format it with.
You pass specify:</p>
<dl>
<dt><code>normal</code></dt>
<dd>normal non-corpus text</dd>
<dt><code>source</code></dt>
<dd>source text of the corpus (before conversion)</dd>
<dt><code>trans</code></dt>
<dd>transcription of corpus text</dd>
<dt><code>phono</code></dt>
<dd>phonological/phonetic transcription of corpus text</dd>
<dt><code>orig</code></dt>
<dd>unicode corpus text</dd>
<dt><em>anything else</em></dt>
<dd>will be inserted as an extra css class.</dd>
<dt>Default</dt>
<dd>string <code>null</code></dd>
</dl>
<hr>
<h3 id="transform"><code>transform</code></h3>
<p>Sometimes you do not want to display straight feature values, but transformed ones.
For each feature you can specfiy a transform function <code>f</code>:
E.g.</p>
<pre><code>transform:
    type: ctype
</code></pre>
<p>The feature <code>type</code>, when computed for a node of the type we are configuring here,
will yield a value which is transformed by function <code>ctype</code> to a new value.
In your app code you have to implement:</p>
<pre><code>def transform_f(app, origValue):
    ...
    newValue = ...
    return newValue
</code></pre>
<dl>
<dt>Default</dt>
<dd>dict <code>{}</code></dd>
</dl>
<hr>
<h3 id="verselike"><code>verselike</code></h3>
<p>Whether this type should be formatted as a verse</p>
<p>The default is:
<code>true</code> for the lowest section type, if there are section types in <code>otext.tf</code>.</p>
<p>But more types can be declared as verselike, e.g. <code>halfverse</code> in the
<a href="https://github.com/annotation/app-bhsa/blob/master/code/config.yaml">bhsa</a>.</p>
<hr>
<h3 id="wrap"><code>wrap</code></h3>
<p>Pretty: whether the child displays may be wrapped.</p>
<dl>
<dt>Default:</dt>
<dd>
<p>boolean</p>
<ul>
<li><code>true</code> if the children form a row, such rows may be wrapped</li>
<li><code>false</code> if the children form a column;
such columns may not be wrapped (into several columns)</li>
</ul>
</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>For some types in
<a href="https://github.com/annotation/app-uruk/blob/master/code/config.yaml">uruk</a>
it is needed to deviate from the default.</p>
</div>
<hr>
<h2 id="writing"><code>writing</code></h2>
<p>Code for triggering special fonts, e.g.</p>
<table>
<thead>
<tr>
<th>iso</th>
<th>language</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>akk</code></td>
<td>akkadian</td>
</tr>
<tr>
<td><code>hbo</code></td>
<td>hebrew</td>
</tr>
<tr>
<td><code>syc</code></td>
<td>syriac</td>
</tr>
<tr>
<td><code>ara</code></td>
<td>arabic</td>
</tr>
<tr>
<td><code>grc</code></td>
<td>greek</td>
</tr>
<tr>
<td><code>cld</code></td>
<td>neo aramaic</td>
</tr>
</tbody>
</table>
<dl>
<dt>Default:</dt>
<dd>string <code>''</code></dd>
</dl>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L0-L982" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../../docs/applib/settings.md
&#34;&#34;&#34;


import re
import types

from ..parameters import URL_GH, URL_NB, URL_TFDOC
from ..core.helpers import console, mdEsc
from .displaysettings import INTERFACE_OPTIONS
from .helpers import dm, parseFeatures, transitiveClosure


VAR_PATTERN = re.compile(r&#34;\{([^}]+)\}&#34;)

WRITING_DEFAULTS = dict(
    akk=dict(language=&#34;akkadian&#34;, direction=&#34;ltr&#34;,),
    hbo=dict(language=&#34;hebrew&#34;, direction=&#34;rtl&#34;,),
    syc=dict(language=&#34;syriac&#34;, direction=&#34;rtl&#34;,),
    ara=dict(language=&#34;arabic&#34;, direction=&#34;rtl&#34;,),
    grc=dict(language=&#34;greek&#34;, direction=&#34;ltr&#34;,),
    cld=dict(language=&#34;aramaic&#34;, direction=&#34;ltr&#34;,),
)
WRITING_DEFAULTS[&#34;&#34;] = dict(language=&#34;&#34;, direction=&#34;ltr&#34;,)

FONT_BASE = (
    &#34;https://github.com/annotation/text-fabric/blob/master/tf/server/static/fonts&#34;
)

METHOD = &#34;method&#34;
STYLE = &#34;style&#34;
DESCEND = &#34;descend&#34;

FMT_KEYS = {METHOD, STYLE}

DEFAULT_CLS = &#34;txtn&#34;
DEFAULT_CLS_SRC = &#34;txto&#34;
DEFAULT_CLS_ORIG = &#34;txtu&#34;
DEFAULT_CLS_TRANS = &#34;txtt&#34;
DEFAULT_CLS_PHONO = &#34;txtp&#34;

NORMAL = &#34;normal&#34;
ORIG = &#34;orig&#34;

FORMAT_CLS = (
    (NORMAL, DEFAULT_CLS),
    (ORIG, DEFAULT_CLS_ORIG),
    (&#34;trans&#34;, DEFAULT_CLS_TRANS),
    (&#34;source&#34;, DEFAULT_CLS_SRC),
    (&#34;phono&#34;, DEFAULT_CLS_PHONO),
)

LEVEL_DEFAULTS = dict(
    level={
        4: dict(flow=&#34;hor&#34;),
        3: dict(flow=&#34;hor&#34;),
        2: dict(flow=&#34;hor&#34;),
        1: dict(flow=&#34;hor&#34;),
        0: dict(flow=&#34;ver&#34;),
    },
    flow=dict(ver=dict(wrap=False, stretch=False), hor=dict(wrap=True, stretch=True)),
    wrap=None,
    stretch=None,
)

RELATIVE_DEFAULT = &#34;tf&#34;

MSPEC_KEYS = set(
    &#34;&#34;&#34;
    org
    repo
    relative
    corpus
    docUrl
    doi
&#34;&#34;&#34;.strip().split()
)

PROVENANCE_DEFAULTS = (
    (&#34;org&#34;, None),
    (&#34;repo&#34;, None),
    (&#34;relative&#34;, RELATIVE_DEFAULT),
    (&#34;graphicsRelative&#34;, None),
    (&#34;version&#34;, None),
    (&#34;moduleSpecs&#34;, ()),
    (&#34;zip&#34;, None),
    (&#34;corpus&#34;, &#34;TF dataset (unspecified)&#34;),
    (&#34;doi&#34;, None),
    (&#34;webBase&#34;, None),
    (&#34;webHint&#34;, None),
    (&#34;webLang&#34;, None),
    (&#34;webLexId&#34;, None),
    (&#34;webUrl&#34;, None),
    (&#34;webUrlLex&#34;, None),
    (&#34;webLexId&#34;, None),
    (&#34;webHint&#34;, None),
)

DOC_DEFAULTS = (
    (&#34;docRoot&#34;, &#34;{urlGh}&#34;),
    (&#34;docExt&#34;, &#34;.md&#34;),
    (&#34;docBase&#34;, &#34;{docRoot}/{org}/{repo}/blob/master/docs&#34;),
    (&#34;docPage&#34;, &#34;home&#34;),
    (&#34;docUrl&#34;, &#34;{docBase}/{docPage}{docExt}&#34;),
    (&#34;featureBase&#34;, &#34;{docBase}/features/&lt;feature&gt;{docExt}&#34;),
    (&#34;featurePage&#34;, &#34;home&#34;),
    (&#34;charUrl&#34;, &#34;{tfDoc}/writing/{language}.html&#34;),
    (&#34;charText&#34;, &#34;How TF features represent text&#34;),
)

DATA_DISPLAY_DEFAULTS = (
    (&#34;excludedFeatures&#34;, set(), False),
    (&#34;noneValues&#34;, {None}, False),
    (&#34;sectionSep1&#34;, &#34; &#34;, False),
    (&#34;sectionSep2&#34;, &#34;:&#34;, False),
    (&#34;textFormats&#34;, {}, True),
    (&#34;browseNavLevel&#34;, None, True),
    (&#34;browseContentPretty&#34;, False, False),
    (&#34;showVerseInTuple&#34;, False, False),
    (&#34;exampleSection&#34;, None, True),
    (&#34;exampleSectionHtml&#34;, None, True),
)

TYPE_KEYS = set(
    &#34;&#34;&#34;
    base
    children
    childrenPlain
    condense
    features
    featuresBare
    flow
    graphics
    hidden
    label
    level
    lexOcc
    lineNumber
    stretch
    template
    transform
    verselike
    wrap
&#34;&#34;&#34;.strip().split()
)

HOOKS = &#34;&#34;&#34;
    afterChild
    childrenCustom
    plainCustom
    prettyCustom
&#34;&#34;&#34;.strip().split()


class AppCurrent:
    def __init__(self, specs):
        self.update(specs)

    def update(self, specs):
        for (k, v) in specs.items():
            setattr(self, k, v)

    def get(self, k, v):
        return getattr(self, k, v)


class Check:
    def __init__(self, app, withApi):
        self.app = app
        self.withApi = withApi
        self.errors = []

    def checkSetting(self, k, v, extra=None):
        app = self.app
        withApi = self.withApi
        errors = self.errors
        dKey = self.dKey
        specs = app.specs

        if withApi:
            api = app.api
            F = api.F
            T = api.T
            Fall = api.Fall
            allNodeFeatures = set(Fall())
            nTypes = F.otype.all
            sectionTypes = T.sectionTypes

            if k in {&#34;template&#34;, &#34;label&#34;}:
                (template, feats) = extra
                if template is not True and type(template) is not str:
                    errors.append(f&#34;{k} must be `true` or a string&#34;)
                for feat in feats:
                    if feat not in allNodeFeatures:
                        if feat not in specs[&#34;transform&#34;].get(dKey, {}):
                            errors.append(f&#34;{k}: feature {feat} not loaded&#34;)
            elif k in {&#34;featuresBare&#34;, &#34;features&#34;}:
                feats = extra[0]
                tps = extra[1].values()
                for feat in feats:
                    if feat not in allNodeFeatures:
                        errors.append(f&#34;{k}: feature {feat} not loaded&#34;)
                for tp in tps:
                    if tp not in nTypes:
                        errors.append(f&#34;{k}: node type {tp} not present&#34;)
            elif k == &#34;base&#34;:
                pass
            elif k == &#34;lineNumber&#34;:
                if v not in allNodeFeatures:
                    errors.append(f&#34;{k}: feature {v} not loaded&#34;)
            elif k == &#34;browseNavLevel&#34;:
                allowedValues = set(range(len(sectionTypes)))
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(sorted(allowedValues))
                    errors.append(f&#34;{k} must be an integer in {allowed}&#34;)
            elif k in {&#34;children&#34;, &#34;xChildren&#34;}:
                if type(v) is not str and type(v) is not list:
                    errors.append(f&#34;{k} must be a (list of) node types&#34;)
                else:
                    v = {v} if type(v) is str else set(v)
                    for tp in v:
                        if tp not in nTypes:
                            errors.append(f&#34;{k}: node type {tp} not present&#34;)
            elif k in {&#34;lexOcc&#34;}:
                if type(v) is not str or v not in nTypes:
                    errors.append(f&#34;{k}: node type {v} not present&#34;)
            elif k == &#34;transform&#34;:
                for (feat, method) in extra.items():
                    if type(method) is str:
                        errors.append(f&#34;{k}:{feat}: {method}() not implemented in app&#34;)
            elif k == &#34;style&#34;:
                if type(v) is not str or v.lower() != v:
                    errors.append(f&#34;{k} must be an all lowercase string&#34;)
            elif k in {
                &#34;lineNumbers&#34;,
                &#34;prettyTypes&#34;,
                &#34;queryFeatures&#34;,
                &#34;showHidden&#34;,
                &#34;showGraphics&#34;,
                &#34;standardFeatures&#34;,
                &#34;withNodes&#34;,
                &#34;withTypes&#34;,
            }:
                allowed = self.extra[k]
                if not allowed and v is not None:
                    errors.append(
                        f&#34;{k}={v} is not useful (dataset lacks relevant features)&#34;
                    )
            elif k == &#34;textFormats&#34;:
                formatStyle = specs[&#34;formatStyle&#34;]
                if type(v) is dict:
                    for (fmt, fmtInfo) in v.items():
                        for (fk, fv) in fmtInfo.items():
                            if fk not in FMT_KEYS:
                                errors.append(f&#34;{k}: {fmt}: illegal key {fk}&#34;)
                                continue
                            if fk == METHOD:
                                (descendType, func) = T.splitFormat(fv)
                                func = f&#34;fmt_{func}&#34;
                                if not hasattr(app, func):
                                    errors.append(
                                        f&#34;{k}: {fmt} needs unimplemented method {func}&#34;
                                    )
                            elif fk == STYLE:
                                if fv not in formatStyle:
                                    if fv.lower() != fv:
                                        errors.append(
                                            f&#34;{k}: {fmt}: style {fv}&#34;
                                            f&#34; must be all lowercase&#34;
                                        )
                else:
                    errors.append(f&#34;{k} must be a dictionary&#34;)
        else:
            if k in {&#34;excludedFeatures&#34;, &#34;noneValues&#34;}:
                if type(v) is not list:
                    errors.append(f&#34;{k} must be a list&#34;)
            elif k in {
                &#34;sectionSep1&#34;,
                &#34;sectionSep2&#34;,
                &#34;exampleSection&#34;,
                &#34;exampleSectionHtml&#34;,
            }:
                if type(v) is not str:
                    errors.append(f&#34;{k} must be a string&#34;)
            elif k == &#34;writing&#34;:
                allowedValues = set(WRITING_DEFAULTS)
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(allowedValues - {&#34;&#34;})
                    errors.append(f&#34;{k} must be the empty string or one of {allowed}&#34;)
            elif k in {&#34;direction&#34;, &#34;language&#34;}:
                allowedValues = {w[k] for w in WRITING_DEFAULTS}
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(allowedValues)
                    errors.append(f&#34;{k} must be one of {allowed}&#34;)
            elif k in {
                &#34;browseContentPretty&#34;,
                &#34;base&#34;,
                &#34;childrenPlain&#34;,
                &#34;condense&#34;,
                &#34;graphics&#34;,
                &#34;hidden&#34;,
                &#34;showVerseInTuple&#34;,
                &#34;stretch&#34;,
                &#34;verselike&#34;,
                &#34;wrap&#34;,
            }:
                allowedValues = {True, False}
                if v not in allowedValues:
                    allowed = &#34;true,false&#34;
                    errors.append(f&#34;{k} must be a boolean in {allowed}&#34;)
            elif k == &#34;flow&#34;:
                allowedValues = {&#34;hor&#34;, &#34;ver&#34;}
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(allowedValues)
                    errors.append(f&#34;{k} must be a value in {allowed}&#34;)
            elif k == &#34;level&#34;:
                allowedValues = set(range(len(4)))
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(sorted(allowedValues))
                    errors.append(f&#34;{k} must be an integer in {allowed}&#34;)

    def checkGroup(self, cfg, defaults, dKey, postpone=set(), extra=None):
        self.cfg = cfg
        self.defaults = defaults
        self.dKey = dKey
        self.extra = extra
        errors = []

        errors.clear()
        dSource = cfg.get(dKey, {})

        for (k, v) in dSource.items():
            if k in defaults:
                if k not in postpone:
                    self.checkSetting(k, v)
            else:
                errors.append(f&#34;Illegal parameter `{k}` with value {v}&#34;)

    def checkItem(self, cfg, dKey):
        self.cfg = cfg
        self.dKey = dKey
        errors = self.errors

        errors.clear()
        if dKey in cfg:
            self.checkSetting(dKey, cfg[dKey])

    def report(self):
        errors = self.errors
        dKey = self.dKey

        if errors:
            console(f&#34;App config error(s) in {dKey}:&#34;, error=True)
            for msg in errors:
                console(f&#34;\t{msg}&#34;, error=True)

        self.errors = []


def setAppSpecs(app, cfg, reset=False):
    specs = dict(urlGh=URL_GH, urlNb=URL_NB, tfDoc=URL_TFDOC,)
    app.specs = specs
    specs.update(cfg)
    checker = Check(app, False)

    dKey = &#34;writing&#34;
    checker.checkItem(cfg, dKey)
    checker.report()
    value = cfg.get(dKey, &#34;&#34;)
    specs[dKey] = value
    for (k, v) in WRITING_DEFAULTS[value].items():
        specs[k] = v
    extension = f&#34; {value}&#34; if value else &#34;&#34;
    defaultClsOrig = f&#34;{DEFAULT_CLS_ORIG}{extension}&#34;
    specs.update(extension=extension, defaultClsOrig=defaultClsOrig)

    for (dKey, defaults) in (
        (&#34;provenanceSpec&#34;, PROVENANCE_DEFAULTS),
        (&#34;docs&#34;, DOC_DEFAULTS),
    ):
        checker.checkGroup(cfg, {d[0] for d in defaults}, dKey)
        checker.report()
        dSource = cfg.get(dKey, {})
        for (k, v) in defaults:
            val = dSource.get(k, v)
            val = (
                None
                if val is None
                else val.format(**specs)
                if type(val) is str
                else val
            )
            specs[k] = val

        if dKey == &#34;provenanceSpec&#34;:
            moduleSpecs = specs[&#34;moduleSpecs&#34;] or []
            for moduleSpec in moduleSpecs:
                for k in MSPEC_KEYS:
                    if k in moduleSpec:
                        v = moduleSpec[k]
                        if k == &#34;docUrl&#34; and v is not None:
                            v = v.format(**specs)
                            moduleSpec[k] = v
                    else:
                        moduleSpec[k] = (
                            specs.get(k, None)
                            if k in {&#34;org&#34;, &#34;repo&#34;}
                            else RELATIVE_DEFAULT
                            if k == &#34;relative&#34;
                            else None
                        )

        specs[dKey] = {k[0]: specs[k[0]] for k in defaults}

    if specs[&#34;zip&#34;] is None:
        org = specs[&#34;org&#34;]
        repo = specs[&#34;repo&#34;]
        graphicsRelative = specs[&#34;graphicsRelative&#34;]
        graphicsModule = [(org, repo, graphicsRelative)] if graphicsRelative else []
        specs[&#34;zip&#34;] = (
            [repo]
            + [(m[&#34;org&#34;], m[&#34;repo&#34;], m[&#34;relative&#34;],) for m in moduleSpecs]
            + graphicsModule
        )

    for (dKey, method) in (
        (&#34;dataDisplay&#34;, getDataDefaults),
        (&#34;typeDisplay&#34;, getTypeDefaults),
    ):
        method(app, cfg, dKey, False)

    if reset:
        aContext = getattr(app, &#34;context&#34;, None)
        if aContext:
            for key in HOOKS:
                specs[key] = aContext.get(key, {})
    else:
        for key in HOOKS:
            specs[key] = {}
    app.context = AppCurrent(specs)


def setAppSpecsApi(app, cfg):
    api = app.api
    T = api.T
    C = api.C
    sectionTypeSet = T.sectionTypeSet

    specs = app.specs

    for (dKey, method) in (
        (&#34;dataDisplay&#34;, getDataDefaults),
        (&#34;typeDisplay&#34;, getTypeDefaults),
    ):
        method(app, cfg, dKey, True)

    specs[&#34;allowedBaseTypes&#34;] = tuple(
        e[0] for e in C.levels.data[0:-1] if e[0] not in sectionTypeSet
    )

    specs[&#34;condenseTypes&#34;] = C.levels.data
    specs[&#34;defaultFormat&#34;] = T.defaultFormat

    dKey = &#34;interfaceDefaults&#34;
    interfaceDefaults = {inf[0]: inf[1] for inf in INTERFACE_OPTIONS}
    dSource = cfg.get(dKey, {})
    specific = {&#34;lineNumbers&#34;, &#34;showHidden&#34;, &#34;showGraphics&#34;}

    allowed = {}
    for (k, v) in interfaceDefaults.items():
        allow = (
            (
                k == &#34;lineNumbers&#34;
                and specs[&#34;lineNumberFeature&#34;]
                or k == &#34;showHidden&#34;
                and specs[&#34;isHidden&#34;]
                or k == &#34;showGraphics&#34;
                and specs[&#34;hasGraphics&#34;]
            )
            if k in specific
            else True
        )
        if k in dSource:
            val = dSource[k]
            default = val if allow else None
        else:
            default = v if allow else None
        interfaceDefaults[k] = default
        allowed[k] = allow
    checker = Check(app, True)
    checker.checkGroup(cfg, interfaceDefaults, dKey, extra=allowed)
    checker.report()
    specs[dKey] = interfaceDefaults

    app.context.update(specs)
    app.showContext = types.MethodType(showContext, app)


def getDataDefaults(app, cfg, dKey, withApi):
    checker = Check(app, withApi)

    if withApi:
        api = app.api
        F = api.F
        T = api.T
        sectionTypes = T.sectionTypes

    specs = app.specs

    givenInfo = cfg.get(dKey, {})

    if withApi:
        formatStyle = {f[0]: f[1] for f in FORMAT_CLS}
        formatStyle[ORIG] = specs[&#34;defaultClsOrig&#34;]
        specs[&#34;formatStyle&#34;] = formatStyle

    allowedKeys = {d[0] for d in DATA_DISPLAY_DEFAULTS}
    checker.checkGroup(cfg, allowedKeys, dKey)
    checker.report()

    for (attr, default, needsApi) in DATA_DISPLAY_DEFAULTS:
        if needsApi and not withApi or not needsApi and withApi:
            continue

        if attr == &#34;browseNavLevel&#34;:
            default = len(sectionTypes) - 1 if sectionTypes else 1

        value = givenInfo.get(attr, specs.get(attr, default))
        if attr in specs and attr not in givenInfo:
            continue
        elif attr == &#34;exampleSection&#34;:
            if not value:
                if sectionTypes:
                    verseType = sectionTypes[-1]
                    firstVerse = F.otype.s(verseType)[0]
                    value = app.sectionStrFromNode(firstVerse)
                else:
                    value = &#34;passage&#34;
            specs[&#34;exampleSection&#34;] = value
            specs[&#34;exampleSectionHtml&#34;] = f&#34;&lt;code&gt;{value}&lt;/code&gt;&#34;
        if attr == &#34;textFormats&#34;:
            methods = {fmt: v[METHOD] for (fmt, v) in value.items() if METHOD in v}
            styles = {fmt: v.get(STYLE, None) for (fmt, v) in value.items()}
            specs[&#34;formatMethod&#34;] = methods
            specs[&#34;formatHtml&#34;] = {T.splitFormat(fmt)[1] for fmt in methods}
            compileFormatCls(app, specs, styles)

        else:
            specs[attr] = value


def getTypeDefaults(app, cfg, dKey, withApi):
    if not withApi:
        return

    checker = Check(app, withApi)
    givenInfo = cfg.get(dKey, {})

    api = app.api
    F = api.F
    T = api.T
    N = api.N
    otypeRank = N.otypeRank
    slotType = F.otype.slotType
    nTypes = F.otype.all
    structureTypes = T.structureTypes
    structureTypeSet = T.structureTypeSet
    sectionTypes = T.sectionTypes
    sectionTypeSet = T.sectionTypeSet

    sectionalTypeSet = sectionTypeSet | structureTypeSet

    specs = app.specs

    noChildren = set()
    isHidden = set()
    featuresBare = {}
    features = {}
    lineNumberFeature = {}
    hasGraphics = set()
    verseTypes = {sectionTypes[-1]} if sectionTypes else set()
    verseRank = otypeRank[sectionTypes[-1]] if sectionTypes else None
    lexMap = {}
    baseTypes = set()
    condenseType = None
    templates = {}
    labels = {}
    styles = {}
    givenLevels = {}
    levels = {}
    childType = {}
    xChildType = {}
    transform = {}

    specs[&#34;transform&#34;] = transform
    formatStyle = specs[&#34;formatStyle&#34;]

    for nType in nTypes:
        template = (
            True if nType == slotType or nType in sectionalTypeSet - verseTypes else &#34;&#34;
        )
        for dest in (templates, labels):
            dest[nType] = (template, ())

    unknownTypes = {nType for nType in givenInfo if nType not in nTypes}
    if unknownTypes:
        unknownTypesRep = &#34;,&#34;.join(sorted(unknownTypes))
        console(f&#34;App config error(s) in typeDisplay: {unknownTypesRep}&#34;, error=True)

    for (nType, info) in givenInfo.items():
        checker.checkGroup(
            givenInfo,
            TYPE_KEYS,
            nType,
            postpone={
                &#34;base&#34;,
                &#34;label&#34;,
                &#34;template&#34;,
                &#34;features&#34;,
                &#34;featuresBare&#34;,
                &#34;transform&#34;,
            },
        )
        checker.report()

        if info.get(&#34;verselike&#34;, False):
            verseTypes.add(nType)

        lOcc = info.get(&#34;lexOcc&#34;, None)
        if lOcc is not None:
            lexMap[lOcc] = nType

        if &#34;base&#34; in info:
            base = info[&#34;base&#34;]
            checker.checkSetting(&#34;base&#34;, base)
            baseTypes.add(nType)

        if &#34;condense&#34; in info:
            condenseType = nType

        trans = info.get(&#34;transform&#34;, None)
        if trans is not None:
            resolvedTrans = {}
            for (feat, func) in trans.items():
                methodName = f&#34;transform_{func}&#34;
                resolvedTrans[feat] = getattr(app, methodName, methodName)
            v = resolvedTrans
            checker.checkSetting(&#34;transform&#34;, trans, extra=v)
            transform[nType] = v

        for (k, dest) in ((&#34;template&#34;, templates), (&#34;label&#34;, labels)):
            if k in info:
                template = info[k]
                templateFeatures = (
                    VAR_PATTERN.findall(template) if type(template) is str else ()
                )
                dest[nType] = (template, templateFeatures)
                checker.checkSetting(
                    k, template, extra=(template, templateFeatures),
                )

        if &#34;style&#34; in info:
            style = info[&#34;style&#34;]
            styles[nType] = formatStyle.get(style, style)

        for k in (&#34;featuresBare&#34;, &#34;features&#34;):
            v = info.get(k, &#34;&#34;)
            parsedV = parseFeatures(v)
            checker.checkSetting(k, v, extra=parsedV)
            if k == &#34;features&#34;:
                features[nType] = parsedV
            else:
                featuresBare[nType] = parsedV

        lineNumber = info.get(&#34;lineNumber&#34;, None)
        if lineNumber is not None:
            lineNumberFeature[nType] = lineNumber

        graphics = info.get(&#34;graphics&#34;, False)
        if graphics:
            hasGraphics.add(nType)

        if not info.get(&#34;childrenPlain&#34;, True):
            noChildren.add(nType)

        hidden = info.get(&#34;hidden&#34;, None)
        if hidden:
            isHidden.add(nType)

        verselike = info.get(&#34;verselike&#34;, False)
        if verselike:
            verseTypes.add(nType)

        if &#34;level&#34; in info or &#34;flow&#34; in info or &#34;wrap&#34; in info or &#34;stretch&#34; in info:
            givenLevels[nType] = {
                k: v for (k, v) in info.items() if k in LEVEL_DEFAULTS
            }

        if &#34;children&#34; in info:
            childs = info[&#34;children&#34;] or ()
            if type(childs) is str:
                childs = {childs}
            else:
                childs = set(childs)
            childType[nType] = set(childs or ())

        if &#34;xChildren&#34; in info:
            xChilds = info[&#34;xChildren&#34;] or ()
            if type(xChilds) is str:
                xChilds = {xChilds}
            else:
                xChilds = set(xChilds)
            xChildType[nType] = set(xChilds or ())

        checker.report()

    lexTypes = set(lexMap.values())
    nTypesNoLex = [n for n in nTypes if n not in lexTypes]

    levelTypes = [set(), set(), set(), set(), set()]
    levelTypes[4] = sectionalTypeSet - verseTypes
    levelTypes[3] = verseTypes
    levelTypes[0] = {slotType} | lexTypes

    remainingTypeSet = set(nTypes) - levelTypes[4] - levelTypes[3] - levelTypes[0]
    remainingTypes = tuple(x for x in nTypes if x in remainingTypeSet)
    nRemaining = len(remainingTypes)

    if nRemaining == 0:
        midType = slotType
    elif nRemaining == 1:
        midType = remainingTypes[0]
        levelTypes[1] = {midType}
    else:
        mid = len(remainingTypes) // 2
        midType = remainingTypes[mid]
        levelTypes[2] = set(remainingTypes[0:mid])
        levelTypes[1] = set(remainingTypes[mid:])

    children = {
        nType: {nTypesNoLex[i + 1]}
        for (i, nType) in enumerate(nTypesNoLex)
        if nType in levelTypes[2] | levelTypes[1]
    }
    children.update(
        {
            nType: {nTypesNoLex[i + 1]}
            for (i, nType) in enumerate(structureTypes)
            if i &lt; len(structureTypes) - 1
        }
    )
    children.update(
        {
            nType: {nTypesNoLex[i + 1]}
            for (i, nType) in enumerate(sectionTypes)
            if i &lt; len(sectionTypes) - 1
        }
    )

    lowestSectionalTypes = set() | verseTypes
    if sectionTypes:
        lowestSectionalTypes.add(sectionTypes[-1])
    if structureTypes:
        lowestSectionalTypes.add(structureTypes[-1])

    biggestOtherType = slotType
    for rt in remainingTypes:
        if verseRank is None or otypeRank[rt] &lt; verseRank:
            biggestOtherType = rt
            break
    smallestOtherType = remainingTypes[-1] if remainingTypes else None

    for lexType in lexTypes:
        if lexType in children:
            del children[lexType]

    for lowestSectionalType in lowestSectionalTypes:
        if lowestSectionalType not in children:
            children[lowestSectionalType] = {biggestOtherType}
        else:
            children[lowestSectionalType].add(biggestOtherType)

    if smallestOtherType is not None and smallestOtherType != slotType:
        if smallestOtherType not in children:
            children[smallestOtherType] = {slotType}
        else:
            children[smallestOtherType].add(slotType)

    if condenseType is None:
        condenseType = sectionTypes[-1] if sectionTypes else midType

    for (i, nTypes) in enumerate(levelTypes):
        for nType in nTypes:
            levels[nType] = getLevel(i, givenLevels.get(nType, {}), nType in verseTypes)

    for (nType, childInfo) in children.items():
        if nType not in childType:
            childType[nType] = childInfo

    levelCls = {}

    for (nType, nTypeInfo) in levels.items():
        level = nTypeInfo[&#34;level&#34;]
        flow = nTypeInfo[&#34;flow&#34;]
        wrap = nTypeInfo[&#34;wrap&#34;]

        containerCls = f&#34;contnr c{level}&#34;
        labelCls = f&#34;lbl c{level}&#34;
        childrenCls = (
            f&#34;children {flow} {&#39;wrap&#39; if wrap else &#39;&#39;}&#34;
            if childType.get(nType, None)
            else &#34;&#34;
        )

        levelCls[nType] = dict(
            container=containerCls, label=labelCls, children=childrenCls,
        )

    descendantType = transitiveClosure(childType, {slotType})

    for (parent, xChildren) in xChildType.items():
        if parent in descendantType:
            descendants = descendantType[parent]
            for xChild in xChildren:
                descendants.discard(xChild)

    specs.update(
        baseTypes=baseTypes if baseTypes else {slotType},
        childType=childType,
        xChildType=xChildType,
        condenseType=condenseType,
        descendantType=descendantType,
        features=features,
        featuresBare=featuresBare,
        hasGraphics=hasGraphics,
        isHidden=isHidden,
        labels=labels,
        levels=levels,
        levelCls=levelCls,
        lexMap=lexMap,
        lexTypes=lexTypes,
        lineNumberFeature=lineNumberFeature,
        noChildren=noChildren,
        noDescendTypes=lexTypes,
        styles=styles,
        templates=templates,
        transform=transform,
        verseTypes=verseTypes,
    )


def showContext(app, *keys):
    &#34;&#34;&#34;Shows the *context* of the app `tf.applib.app.App.context` in a pretty way.

    The context is the result of computing sensible defaults for the corpus
    combined with configuration settings in the app&#39;s `config.yaml`.

    Parameters
    ----------
    keys: iterable of string
        For each key passed to this function, the information for that key
        will be displayed. If no keys are passed, all keys will be displayed.

    Returns
    -------
    displayed HTML
        An expandable list of the key-value pair for the requested keys.

    See Also
    --------
    tf.applib.app.App.reuse
    &#34;&#34;&#34;

    EM = &#34;*empty*&#34;
    block = &#34;    &#34;
    keys = set(keys)

    def eScalar(x, level):
        if type(x) is str and &#34;\n&#34; in x:
            indent = block * level
            return (
                f&#34;\n{indent}```\n{indent}&#34;
                + f&#34;\n{indent}&#34;.join(x.split(&#34;\n&#34;))
                + f&#34;\n{indent}```\n&#34;
            )
        return f&#34;`{mdEsc(str(x))}`&#34; if x else EM

    def eEmpty(x):
        return EM if type(x) is str else str(x)

    def eList(x, level):
        tpv = type(x)
        indent = block * level
        md = &#34;\n&#34;
        for (i, v) in enumerate(sorted(x, key=lambda y: str(y)) if tpv is set else x):
            item = f&#34;{i + 1}.&#34; if level == 0 else &#34;*&#34;
            md += f&#34;{indent}{item:&lt;4}{eData(v, level + 1)}&#34;
        return md

    def eDict(x, level):
        indent = block * level
        md = &#34;\n&#34;
        for (k, v) in sorted(x.items(), key=lambda y: str(y)):
            item = &#34;*&#34;
            md += f&#34;{indent}{item:&lt;4}**{eScalar(k, level)}**:&#34; f&#34; {eData(v, level + 1)}&#34;
        return md

    def eRest(x, level):
        indent = block * level
        return &#34;\n&#34; + indent + eScalar(x, level) + &#34;\n&#34;

    def eData(x, level):
        if not x:
            return eEmpty(x) + &#34;\n&#34;
        tpv = type(x)
        if tpv is str or tpv is float or tpv is int or tpv is bool:
            return eScalar(x, level) + &#34;\n&#34;
        if tpv is list or tpv is tuple or tpv is set:
            return eList(x, level)
        if tpv is dict:
            return eDict(x, level)
        return eRest(x, level)

    openRep1 = &#34;open&#34; if len(keys) else &#34;&#34;
    openRep2 = &#34;open&#34; if len(keys) == 1 else &#34;&#34;
    md = [
        f&#34;&lt;details {openRep1}&gt;&#34;
        f&#34;&lt;summary&gt;&lt;b&gt;{(app.appName)}&lt;/b&gt; &lt;i&gt;app context&lt;/i&gt;&lt;/summary&gt;\n\n&#34;
    ]
    for (i, (k, v)) in enumerate(sorted(app.specs.items(), key=lambda y: str(y))):
        if len(keys) and k not in keys:
            continue
        md.append(
            f&#34;&lt;details {openRep2}&gt;&#34;
            f&#34;&lt;summary&gt;{i + 1}. {k}&lt;/summary&gt;\n\n{eData(v, 0)}\n&lt;/details&gt;\n&#34;
        )
    md.append(&#34;&lt;/details&gt;\n&#34;)
    dm(&#34;&#34;.join(md))


def getLevel(defaultLevel, givenInfo, isVerse):
    level = givenInfo.get(&#34;level&#34;, defaultLevel)
    defaultsFromLevel = LEVEL_DEFAULTS[&#34;level&#34;][level]
    flow = givenInfo.get(&#34;flow&#34;, &#34;hor&#34; if isVerse else defaultsFromLevel[&#34;flow&#34;])
    defaultsFromFlow = LEVEL_DEFAULTS[&#34;flow&#34;][flow]
    wrap = givenInfo.get(&#34;wrap&#34;, defaultsFromFlow[&#34;wrap&#34;])
    stretch = givenInfo.get(&#34;stretch&#34;, defaultsFromFlow[&#34;stretch&#34;])
    return dict(level=level, flow=flow, wrap=wrap, stretch=stretch)


def compileFormatCls(app, specs, givenStyles):
    api = app.api
    T = api.T

    result = {}
    extraFormats = set()

    formatStyle = specs[&#34;formatStyle&#34;]
    defaultClsOrig = specs[&#34;defaultClsOrig&#34;]

    for fmt in givenStyles:
        fmt = T.splitFormat(fmt)[1]
        extraFormats.add(fmt)

    for fmt in set(T.formats) | set(extraFormats):
        style = givenStyles.get(fmt, None)
        if style is None:
            textCls = None
            for (key, cls) in FORMAT_CLS:
                if (
                    f&#34;-{key}-&#34; in fmt
                    or fmt.startswith(f&#34;{key}-&#34;)
                    or fmt.endswith(f&#34;-{key}&#34;)
                ):
                    textCls = defaultClsOrig if key == ORIG else cls
            if textCls is None:
                textCls = DEFAULT_CLS
        else:
            textCls = defaultClsOrig if style == ORIG else formatStyle.get(style, style)
        result[fmt] = textCls

    specs[&#34;formatCls&#34;] = result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.applib.settings.compileFormatCls"><code class="name flex">
<span>def <span class="ident">compileFormatCls</span></span>(<span>app, specs, givenStyles)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L952-L983" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def compileFormatCls(app, specs, givenStyles):
    api = app.api
    T = api.T

    result = {}
    extraFormats = set()

    formatStyle = specs[&#34;formatStyle&#34;]
    defaultClsOrig = specs[&#34;defaultClsOrig&#34;]

    for fmt in givenStyles:
        fmt = T.splitFormat(fmt)[1]
        extraFormats.add(fmt)

    for fmt in set(T.formats) | set(extraFormats):
        style = givenStyles.get(fmt, None)
        if style is None:
            textCls = None
            for (key, cls) in FORMAT_CLS:
                if (
                    f&#34;-{key}-&#34; in fmt
                    or fmt.startswith(f&#34;{key}-&#34;)
                    or fmt.endswith(f&#34;-{key}&#34;)
                ):
                    textCls = defaultClsOrig if key == ORIG else cls
            if textCls is None:
                textCls = DEFAULT_CLS
        else:
            textCls = defaultClsOrig if style == ORIG else formatStyle.get(style, style)
        result[fmt] = textCls

    specs[&#34;formatCls&#34;] = result</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.getDataDefaults"><code class="name flex">
<span>def <span class="ident">getDataDefaults</span></span>(<span>app, cfg, dKey, withApi)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L500-L550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDataDefaults(app, cfg, dKey, withApi):
    checker = Check(app, withApi)

    if withApi:
        api = app.api
        F = api.F
        T = api.T
        sectionTypes = T.sectionTypes

    specs = app.specs

    givenInfo = cfg.get(dKey, {})

    if withApi:
        formatStyle = {f[0]: f[1] for f in FORMAT_CLS}
        formatStyle[ORIG] = specs[&#34;defaultClsOrig&#34;]
        specs[&#34;formatStyle&#34;] = formatStyle

    allowedKeys = {d[0] for d in DATA_DISPLAY_DEFAULTS}
    checker.checkGroup(cfg, allowedKeys, dKey)
    checker.report()

    for (attr, default, needsApi) in DATA_DISPLAY_DEFAULTS:
        if needsApi and not withApi or not needsApi and withApi:
            continue

        if attr == &#34;browseNavLevel&#34;:
            default = len(sectionTypes) - 1 if sectionTypes else 1

        value = givenInfo.get(attr, specs.get(attr, default))
        if attr in specs and attr not in givenInfo:
            continue
        elif attr == &#34;exampleSection&#34;:
            if not value:
                if sectionTypes:
                    verseType = sectionTypes[-1]
                    firstVerse = F.otype.s(verseType)[0]
                    value = app.sectionStrFromNode(firstVerse)
                else:
                    value = &#34;passage&#34;
            specs[&#34;exampleSection&#34;] = value
            specs[&#34;exampleSectionHtml&#34;] = f&#34;&lt;code&gt;{value}&lt;/code&gt;&#34;
        if attr == &#34;textFormats&#34;:
            methods = {fmt: v[METHOD] for (fmt, v) in value.items() if METHOD in v}
            styles = {fmt: v.get(STYLE, None) for (fmt, v) in value.items()}
            specs[&#34;formatMethod&#34;] = methods
            specs[&#34;formatHtml&#34;] = {T.splitFormat(fmt)[1] for fmt in methods}
            compileFormatCls(app, specs, styles)

        else:
            specs[attr] = value</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.getLevel"><code class="name flex">
<span>def <span class="ident">getLevel</span></span>(<span>defaultLevel, givenInfo, isVerse)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L942-L949" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getLevel(defaultLevel, givenInfo, isVerse):
    level = givenInfo.get(&#34;level&#34;, defaultLevel)
    defaultsFromLevel = LEVEL_DEFAULTS[&#34;level&#34;][level]
    flow = givenInfo.get(&#34;flow&#34;, &#34;hor&#34; if isVerse else defaultsFromLevel[&#34;flow&#34;])
    defaultsFromFlow = LEVEL_DEFAULTS[&#34;flow&#34;][flow]
    wrap = givenInfo.get(&#34;wrap&#34;, defaultsFromFlow[&#34;wrap&#34;])
    stretch = givenInfo.get(&#34;stretch&#34;, defaultsFromFlow[&#34;stretch&#34;])
    return dict(level=level, flow=flow, wrap=wrap, stretch=stretch)</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.getTypeDefaults"><code class="name flex">
<span>def <span class="ident">getTypeDefaults</span></span>(<span>app, cfg, dKey, withApi)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L553-L850" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getTypeDefaults(app, cfg, dKey, withApi):
    if not withApi:
        return

    checker = Check(app, withApi)
    givenInfo = cfg.get(dKey, {})

    api = app.api
    F = api.F
    T = api.T
    N = api.N
    otypeRank = N.otypeRank
    slotType = F.otype.slotType
    nTypes = F.otype.all
    structureTypes = T.structureTypes
    structureTypeSet = T.structureTypeSet
    sectionTypes = T.sectionTypes
    sectionTypeSet = T.sectionTypeSet

    sectionalTypeSet = sectionTypeSet | structureTypeSet

    specs = app.specs

    noChildren = set()
    isHidden = set()
    featuresBare = {}
    features = {}
    lineNumberFeature = {}
    hasGraphics = set()
    verseTypes = {sectionTypes[-1]} if sectionTypes else set()
    verseRank = otypeRank[sectionTypes[-1]] if sectionTypes else None
    lexMap = {}
    baseTypes = set()
    condenseType = None
    templates = {}
    labels = {}
    styles = {}
    givenLevels = {}
    levels = {}
    childType = {}
    xChildType = {}
    transform = {}

    specs[&#34;transform&#34;] = transform
    formatStyle = specs[&#34;formatStyle&#34;]

    for nType in nTypes:
        template = (
            True if nType == slotType or nType in sectionalTypeSet - verseTypes else &#34;&#34;
        )
        for dest in (templates, labels):
            dest[nType] = (template, ())

    unknownTypes = {nType for nType in givenInfo if nType not in nTypes}
    if unknownTypes:
        unknownTypesRep = &#34;,&#34;.join(sorted(unknownTypes))
        console(f&#34;App config error(s) in typeDisplay: {unknownTypesRep}&#34;, error=True)

    for (nType, info) in givenInfo.items():
        checker.checkGroup(
            givenInfo,
            TYPE_KEYS,
            nType,
            postpone={
                &#34;base&#34;,
                &#34;label&#34;,
                &#34;template&#34;,
                &#34;features&#34;,
                &#34;featuresBare&#34;,
                &#34;transform&#34;,
            },
        )
        checker.report()

        if info.get(&#34;verselike&#34;, False):
            verseTypes.add(nType)

        lOcc = info.get(&#34;lexOcc&#34;, None)
        if lOcc is not None:
            lexMap[lOcc] = nType

        if &#34;base&#34; in info:
            base = info[&#34;base&#34;]
            checker.checkSetting(&#34;base&#34;, base)
            baseTypes.add(nType)

        if &#34;condense&#34; in info:
            condenseType = nType

        trans = info.get(&#34;transform&#34;, None)
        if trans is not None:
            resolvedTrans = {}
            for (feat, func) in trans.items():
                methodName = f&#34;transform_{func}&#34;
                resolvedTrans[feat] = getattr(app, methodName, methodName)
            v = resolvedTrans
            checker.checkSetting(&#34;transform&#34;, trans, extra=v)
            transform[nType] = v

        for (k, dest) in ((&#34;template&#34;, templates), (&#34;label&#34;, labels)):
            if k in info:
                template = info[k]
                templateFeatures = (
                    VAR_PATTERN.findall(template) if type(template) is str else ()
                )
                dest[nType] = (template, templateFeatures)
                checker.checkSetting(
                    k, template, extra=(template, templateFeatures),
                )

        if &#34;style&#34; in info:
            style = info[&#34;style&#34;]
            styles[nType] = formatStyle.get(style, style)

        for k in (&#34;featuresBare&#34;, &#34;features&#34;):
            v = info.get(k, &#34;&#34;)
            parsedV = parseFeatures(v)
            checker.checkSetting(k, v, extra=parsedV)
            if k == &#34;features&#34;:
                features[nType] = parsedV
            else:
                featuresBare[nType] = parsedV

        lineNumber = info.get(&#34;lineNumber&#34;, None)
        if lineNumber is not None:
            lineNumberFeature[nType] = lineNumber

        graphics = info.get(&#34;graphics&#34;, False)
        if graphics:
            hasGraphics.add(nType)

        if not info.get(&#34;childrenPlain&#34;, True):
            noChildren.add(nType)

        hidden = info.get(&#34;hidden&#34;, None)
        if hidden:
            isHidden.add(nType)

        verselike = info.get(&#34;verselike&#34;, False)
        if verselike:
            verseTypes.add(nType)

        if &#34;level&#34; in info or &#34;flow&#34; in info or &#34;wrap&#34; in info or &#34;stretch&#34; in info:
            givenLevels[nType] = {
                k: v for (k, v) in info.items() if k in LEVEL_DEFAULTS
            }

        if &#34;children&#34; in info:
            childs = info[&#34;children&#34;] or ()
            if type(childs) is str:
                childs = {childs}
            else:
                childs = set(childs)
            childType[nType] = set(childs or ())

        if &#34;xChildren&#34; in info:
            xChilds = info[&#34;xChildren&#34;] or ()
            if type(xChilds) is str:
                xChilds = {xChilds}
            else:
                xChilds = set(xChilds)
            xChildType[nType] = set(xChilds or ())

        checker.report()

    lexTypes = set(lexMap.values())
    nTypesNoLex = [n for n in nTypes if n not in lexTypes]

    levelTypes = [set(), set(), set(), set(), set()]
    levelTypes[4] = sectionalTypeSet - verseTypes
    levelTypes[3] = verseTypes
    levelTypes[0] = {slotType} | lexTypes

    remainingTypeSet = set(nTypes) - levelTypes[4] - levelTypes[3] - levelTypes[0]
    remainingTypes = tuple(x for x in nTypes if x in remainingTypeSet)
    nRemaining = len(remainingTypes)

    if nRemaining == 0:
        midType = slotType
    elif nRemaining == 1:
        midType = remainingTypes[0]
        levelTypes[1] = {midType}
    else:
        mid = len(remainingTypes) // 2
        midType = remainingTypes[mid]
        levelTypes[2] = set(remainingTypes[0:mid])
        levelTypes[1] = set(remainingTypes[mid:])

    children = {
        nType: {nTypesNoLex[i + 1]}
        for (i, nType) in enumerate(nTypesNoLex)
        if nType in levelTypes[2] | levelTypes[1]
    }
    children.update(
        {
            nType: {nTypesNoLex[i + 1]}
            for (i, nType) in enumerate(structureTypes)
            if i &lt; len(structureTypes) - 1
        }
    )
    children.update(
        {
            nType: {nTypesNoLex[i + 1]}
            for (i, nType) in enumerate(sectionTypes)
            if i &lt; len(sectionTypes) - 1
        }
    )

    lowestSectionalTypes = set() | verseTypes
    if sectionTypes:
        lowestSectionalTypes.add(sectionTypes[-1])
    if structureTypes:
        lowestSectionalTypes.add(structureTypes[-1])

    biggestOtherType = slotType
    for rt in remainingTypes:
        if verseRank is None or otypeRank[rt] &lt; verseRank:
            biggestOtherType = rt
            break
    smallestOtherType = remainingTypes[-1] if remainingTypes else None

    for lexType in lexTypes:
        if lexType in children:
            del children[lexType]

    for lowestSectionalType in lowestSectionalTypes:
        if lowestSectionalType not in children:
            children[lowestSectionalType] = {biggestOtherType}
        else:
            children[lowestSectionalType].add(biggestOtherType)

    if smallestOtherType is not None and smallestOtherType != slotType:
        if smallestOtherType not in children:
            children[smallestOtherType] = {slotType}
        else:
            children[smallestOtherType].add(slotType)

    if condenseType is None:
        condenseType = sectionTypes[-1] if sectionTypes else midType

    for (i, nTypes) in enumerate(levelTypes):
        for nType in nTypes:
            levels[nType] = getLevel(i, givenLevels.get(nType, {}), nType in verseTypes)

    for (nType, childInfo) in children.items():
        if nType not in childType:
            childType[nType] = childInfo

    levelCls = {}

    for (nType, nTypeInfo) in levels.items():
        level = nTypeInfo[&#34;level&#34;]
        flow = nTypeInfo[&#34;flow&#34;]
        wrap = nTypeInfo[&#34;wrap&#34;]

        containerCls = f&#34;contnr c{level}&#34;
        labelCls = f&#34;lbl c{level}&#34;
        childrenCls = (
            f&#34;children {flow} {&#39;wrap&#39; if wrap else &#39;&#39;}&#34;
            if childType.get(nType, None)
            else &#34;&#34;
        )

        levelCls[nType] = dict(
            container=containerCls, label=labelCls, children=childrenCls,
        )

    descendantType = transitiveClosure(childType, {slotType})

    for (parent, xChildren) in xChildType.items():
        if parent in descendantType:
            descendants = descendantType[parent]
            for xChild in xChildren:
                descendants.discard(xChild)

    specs.update(
        baseTypes=baseTypes if baseTypes else {slotType},
        childType=childType,
        xChildType=xChildType,
        condenseType=condenseType,
        descendantType=descendantType,
        features=features,
        featuresBare=featuresBare,
        hasGraphics=hasGraphics,
        isHidden=isHidden,
        labels=labels,
        levels=levels,
        levelCls=levelCls,
        lexMap=lexMap,
        lexTypes=lexTypes,
        lineNumberFeature=lineNumberFeature,
        noChildren=noChildren,
        noDescendTypes=lexTypes,
        styles=styles,
        templates=templates,
        transform=transform,
        verseTypes=verseTypes,
    )</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.setAppSpecs"><code class="name flex">
<span>def <span class="ident">setAppSpecs</span></span>(<span>app, cfg, reset=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L361-L441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setAppSpecs(app, cfg, reset=False):
    specs = dict(urlGh=URL_GH, urlNb=URL_NB, tfDoc=URL_TFDOC,)
    app.specs = specs
    specs.update(cfg)
    checker = Check(app, False)

    dKey = &#34;writing&#34;
    checker.checkItem(cfg, dKey)
    checker.report()
    value = cfg.get(dKey, &#34;&#34;)
    specs[dKey] = value
    for (k, v) in WRITING_DEFAULTS[value].items():
        specs[k] = v
    extension = f&#34; {value}&#34; if value else &#34;&#34;
    defaultClsOrig = f&#34;{DEFAULT_CLS_ORIG}{extension}&#34;
    specs.update(extension=extension, defaultClsOrig=defaultClsOrig)

    for (dKey, defaults) in (
        (&#34;provenanceSpec&#34;, PROVENANCE_DEFAULTS),
        (&#34;docs&#34;, DOC_DEFAULTS),
    ):
        checker.checkGroup(cfg, {d[0] for d in defaults}, dKey)
        checker.report()
        dSource = cfg.get(dKey, {})
        for (k, v) in defaults:
            val = dSource.get(k, v)
            val = (
                None
                if val is None
                else val.format(**specs)
                if type(val) is str
                else val
            )
            specs[k] = val

        if dKey == &#34;provenanceSpec&#34;:
            moduleSpecs = specs[&#34;moduleSpecs&#34;] or []
            for moduleSpec in moduleSpecs:
                for k in MSPEC_KEYS:
                    if k in moduleSpec:
                        v = moduleSpec[k]
                        if k == &#34;docUrl&#34; and v is not None:
                            v = v.format(**specs)
                            moduleSpec[k] = v
                    else:
                        moduleSpec[k] = (
                            specs.get(k, None)
                            if k in {&#34;org&#34;, &#34;repo&#34;}
                            else RELATIVE_DEFAULT
                            if k == &#34;relative&#34;
                            else None
                        )

        specs[dKey] = {k[0]: specs[k[0]] for k in defaults}

    if specs[&#34;zip&#34;] is None:
        org = specs[&#34;org&#34;]
        repo = specs[&#34;repo&#34;]
        graphicsRelative = specs[&#34;graphicsRelative&#34;]
        graphicsModule = [(org, repo, graphicsRelative)] if graphicsRelative else []
        specs[&#34;zip&#34;] = (
            [repo]
            + [(m[&#34;org&#34;], m[&#34;repo&#34;], m[&#34;relative&#34;],) for m in moduleSpecs]
            + graphicsModule
        )

    for (dKey, method) in (
        (&#34;dataDisplay&#34;, getDataDefaults),
        (&#34;typeDisplay&#34;, getTypeDefaults),
    ):
        method(app, cfg, dKey, False)

    if reset:
        aContext = getattr(app, &#34;context&#34;, None)
        if aContext:
            for key in HOOKS:
                specs[key] = aContext.get(key, {})
    else:
        for key in HOOKS:
            specs[key] = {}
    app.context = AppCurrent(specs)</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.setAppSpecsApi"><code class="name flex">
<span>def <span class="ident">setAppSpecsApi</span></span>(<span>app, cfg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L444-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setAppSpecsApi(app, cfg):
    api = app.api
    T = api.T
    C = api.C
    sectionTypeSet = T.sectionTypeSet

    specs = app.specs

    for (dKey, method) in (
        (&#34;dataDisplay&#34;, getDataDefaults),
        (&#34;typeDisplay&#34;, getTypeDefaults),
    ):
        method(app, cfg, dKey, True)

    specs[&#34;allowedBaseTypes&#34;] = tuple(
        e[0] for e in C.levels.data[0:-1] if e[0] not in sectionTypeSet
    )

    specs[&#34;condenseTypes&#34;] = C.levels.data
    specs[&#34;defaultFormat&#34;] = T.defaultFormat

    dKey = &#34;interfaceDefaults&#34;
    interfaceDefaults = {inf[0]: inf[1] for inf in INTERFACE_OPTIONS}
    dSource = cfg.get(dKey, {})
    specific = {&#34;lineNumbers&#34;, &#34;showHidden&#34;, &#34;showGraphics&#34;}

    allowed = {}
    for (k, v) in interfaceDefaults.items():
        allow = (
            (
                k == &#34;lineNumbers&#34;
                and specs[&#34;lineNumberFeature&#34;]
                or k == &#34;showHidden&#34;
                and specs[&#34;isHidden&#34;]
                or k == &#34;showGraphics&#34;
                and specs[&#34;hasGraphics&#34;]
            )
            if k in specific
            else True
        )
        if k in dSource:
            val = dSource[k]
            default = val if allow else None
        else:
            default = v if allow else None
        interfaceDefaults[k] = default
        allowed[k] = allow
    checker = Check(app, True)
    checker.checkGroup(cfg, interfaceDefaults, dKey, extra=allowed)
    checker.report()
    specs[dKey] = interfaceDefaults

    app.context.update(specs)
    app.showContext = types.MethodType(showContext, app)</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.showContext"><code class="name flex">
<span>def <span class="ident">showContext</span></span>(<span>app, *keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the <em>context</em> of the app <code><a title="tf.applib.app.App.context" href="app.html#tf.applib.app.App.context">App.context</a></code> in a pretty way.</p>
<p>The context is the result of computing sensible defaults for the corpus
combined with configuration settings in the app's <code>config.yaml</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keys</code></strong> :&ensp;<code>iterable</code> of <code>string</code></dt>
<dd>For each key passed to this function, the information for that key
will be displayed. If no keys are passed, all keys will be displayed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>displayed HTML</code></dt>
<dd>An expandable list of the key-value pair for the requested keys.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="tf.applib.app.App.reuse" href="app.html#tf.applib.app.App.reuse">App.reuse()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L853-L939" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showContext(app, *keys):
    &#34;&#34;&#34;Shows the *context* of the app `tf.applib.app.App.context` in a pretty way.

    The context is the result of computing sensible defaults for the corpus
    combined with configuration settings in the app&#39;s `config.yaml`.

    Parameters
    ----------
    keys: iterable of string
        For each key passed to this function, the information for that key
        will be displayed. If no keys are passed, all keys will be displayed.

    Returns
    -------
    displayed HTML
        An expandable list of the key-value pair for the requested keys.

    See Also
    --------
    tf.applib.app.App.reuse
    &#34;&#34;&#34;

    EM = &#34;*empty*&#34;
    block = &#34;    &#34;
    keys = set(keys)

    def eScalar(x, level):
        if type(x) is str and &#34;\n&#34; in x:
            indent = block * level
            return (
                f&#34;\n{indent}```\n{indent}&#34;
                + f&#34;\n{indent}&#34;.join(x.split(&#34;\n&#34;))
                + f&#34;\n{indent}```\n&#34;
            )
        return f&#34;`{mdEsc(str(x))}`&#34; if x else EM

    def eEmpty(x):
        return EM if type(x) is str else str(x)

    def eList(x, level):
        tpv = type(x)
        indent = block * level
        md = &#34;\n&#34;
        for (i, v) in enumerate(sorted(x, key=lambda y: str(y)) if tpv is set else x):
            item = f&#34;{i + 1}.&#34; if level == 0 else &#34;*&#34;
            md += f&#34;{indent}{item:&lt;4}{eData(v, level + 1)}&#34;
        return md

    def eDict(x, level):
        indent = block * level
        md = &#34;\n&#34;
        for (k, v) in sorted(x.items(), key=lambda y: str(y)):
            item = &#34;*&#34;
            md += f&#34;{indent}{item:&lt;4}**{eScalar(k, level)}**:&#34; f&#34; {eData(v, level + 1)}&#34;
        return md

    def eRest(x, level):
        indent = block * level
        return &#34;\n&#34; + indent + eScalar(x, level) + &#34;\n&#34;

    def eData(x, level):
        if not x:
            return eEmpty(x) + &#34;\n&#34;
        tpv = type(x)
        if tpv is str or tpv is float or tpv is int or tpv is bool:
            return eScalar(x, level) + &#34;\n&#34;
        if tpv is list or tpv is tuple or tpv is set:
            return eList(x, level)
        if tpv is dict:
            return eDict(x, level)
        return eRest(x, level)

    openRep1 = &#34;open&#34; if len(keys) else &#34;&#34;
    openRep2 = &#34;open&#34; if len(keys) == 1 else &#34;&#34;
    md = [
        f&#34;&lt;details {openRep1}&gt;&#34;
        f&#34;&lt;summary&gt;&lt;b&gt;{(app.appName)}&lt;/b&gt; &lt;i&gt;app context&lt;/i&gt;&lt;/summary&gt;\n\n&#34;
    ]
    for (i, (k, v)) in enumerate(sorted(app.specs.items(), key=lambda y: str(y))):
        if len(keys) and k not in keys:
            continue
        md.append(
            f&#34;&lt;details {openRep2}&gt;&#34;
            f&#34;&lt;summary&gt;{i + 1}. {k}&lt;/summary&gt;\n\n{eData(v, 0)}\n&lt;/details&gt;\n&#34;
        )
    md.append(&#34;&lt;/details&gt;\n&#34;)
    dm(&#34;&#34;.join(md))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.applib.settings.AppCurrent"><code class="flex name class">
<span>class <span class="ident">AppCurrent</span></span>
<span>(</span><span>specs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L156-L165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AppCurrent:
    def __init__(self, specs):
        self.update(specs)

    def update(self, specs):
        for (k, v) in specs.items():
            setattr(self, k, v)

    def get(self, k, v):
        return getattr(self, k, v)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.applib.settings.AppCurrent.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, k, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L164-L165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get(self, k, v):
    return getattr(self, k, v)</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.AppCurrent.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, specs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L160-L162" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update(self, specs):
    for (k, v) in specs.items():
        setattr(self, k, v)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tf.applib.settings.Check"><code class="flex name class">
<span>class <span class="ident">Check</span></span>
<span>(</span><span>app, withApi)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L168-L358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Check:
    def __init__(self, app, withApi):
        self.app = app
        self.withApi = withApi
        self.errors = []

    def checkSetting(self, k, v, extra=None):
        app = self.app
        withApi = self.withApi
        errors = self.errors
        dKey = self.dKey
        specs = app.specs

        if withApi:
            api = app.api
            F = api.F
            T = api.T
            Fall = api.Fall
            allNodeFeatures = set(Fall())
            nTypes = F.otype.all
            sectionTypes = T.sectionTypes

            if k in {&#34;template&#34;, &#34;label&#34;}:
                (template, feats) = extra
                if template is not True and type(template) is not str:
                    errors.append(f&#34;{k} must be `true` or a string&#34;)
                for feat in feats:
                    if feat not in allNodeFeatures:
                        if feat not in specs[&#34;transform&#34;].get(dKey, {}):
                            errors.append(f&#34;{k}: feature {feat} not loaded&#34;)
            elif k in {&#34;featuresBare&#34;, &#34;features&#34;}:
                feats = extra[0]
                tps = extra[1].values()
                for feat in feats:
                    if feat not in allNodeFeatures:
                        errors.append(f&#34;{k}: feature {feat} not loaded&#34;)
                for tp in tps:
                    if tp not in nTypes:
                        errors.append(f&#34;{k}: node type {tp} not present&#34;)
            elif k == &#34;base&#34;:
                pass
            elif k == &#34;lineNumber&#34;:
                if v not in allNodeFeatures:
                    errors.append(f&#34;{k}: feature {v} not loaded&#34;)
            elif k == &#34;browseNavLevel&#34;:
                allowedValues = set(range(len(sectionTypes)))
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(sorted(allowedValues))
                    errors.append(f&#34;{k} must be an integer in {allowed}&#34;)
            elif k in {&#34;children&#34;, &#34;xChildren&#34;}:
                if type(v) is not str and type(v) is not list:
                    errors.append(f&#34;{k} must be a (list of) node types&#34;)
                else:
                    v = {v} if type(v) is str else set(v)
                    for tp in v:
                        if tp not in nTypes:
                            errors.append(f&#34;{k}: node type {tp} not present&#34;)
            elif k in {&#34;lexOcc&#34;}:
                if type(v) is not str or v not in nTypes:
                    errors.append(f&#34;{k}: node type {v} not present&#34;)
            elif k == &#34;transform&#34;:
                for (feat, method) in extra.items():
                    if type(method) is str:
                        errors.append(f&#34;{k}:{feat}: {method}() not implemented in app&#34;)
            elif k == &#34;style&#34;:
                if type(v) is not str or v.lower() != v:
                    errors.append(f&#34;{k} must be an all lowercase string&#34;)
            elif k in {
                &#34;lineNumbers&#34;,
                &#34;prettyTypes&#34;,
                &#34;queryFeatures&#34;,
                &#34;showHidden&#34;,
                &#34;showGraphics&#34;,
                &#34;standardFeatures&#34;,
                &#34;withNodes&#34;,
                &#34;withTypes&#34;,
            }:
                allowed = self.extra[k]
                if not allowed and v is not None:
                    errors.append(
                        f&#34;{k}={v} is not useful (dataset lacks relevant features)&#34;
                    )
            elif k == &#34;textFormats&#34;:
                formatStyle = specs[&#34;formatStyle&#34;]
                if type(v) is dict:
                    for (fmt, fmtInfo) in v.items():
                        for (fk, fv) in fmtInfo.items():
                            if fk not in FMT_KEYS:
                                errors.append(f&#34;{k}: {fmt}: illegal key {fk}&#34;)
                                continue
                            if fk == METHOD:
                                (descendType, func) = T.splitFormat(fv)
                                func = f&#34;fmt_{func}&#34;
                                if not hasattr(app, func):
                                    errors.append(
                                        f&#34;{k}: {fmt} needs unimplemented method {func}&#34;
                                    )
                            elif fk == STYLE:
                                if fv not in formatStyle:
                                    if fv.lower() != fv:
                                        errors.append(
                                            f&#34;{k}: {fmt}: style {fv}&#34;
                                            f&#34; must be all lowercase&#34;
                                        )
                else:
                    errors.append(f&#34;{k} must be a dictionary&#34;)
        else:
            if k in {&#34;excludedFeatures&#34;, &#34;noneValues&#34;}:
                if type(v) is not list:
                    errors.append(f&#34;{k} must be a list&#34;)
            elif k in {
                &#34;sectionSep1&#34;,
                &#34;sectionSep2&#34;,
                &#34;exampleSection&#34;,
                &#34;exampleSectionHtml&#34;,
            }:
                if type(v) is not str:
                    errors.append(f&#34;{k} must be a string&#34;)
            elif k == &#34;writing&#34;:
                allowedValues = set(WRITING_DEFAULTS)
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(allowedValues - {&#34;&#34;})
                    errors.append(f&#34;{k} must be the empty string or one of {allowed}&#34;)
            elif k in {&#34;direction&#34;, &#34;language&#34;}:
                allowedValues = {w[k] for w in WRITING_DEFAULTS}
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(allowedValues)
                    errors.append(f&#34;{k} must be one of {allowed}&#34;)
            elif k in {
                &#34;browseContentPretty&#34;,
                &#34;base&#34;,
                &#34;childrenPlain&#34;,
                &#34;condense&#34;,
                &#34;graphics&#34;,
                &#34;hidden&#34;,
                &#34;showVerseInTuple&#34;,
                &#34;stretch&#34;,
                &#34;verselike&#34;,
                &#34;wrap&#34;,
            }:
                allowedValues = {True, False}
                if v not in allowedValues:
                    allowed = &#34;true,false&#34;
                    errors.append(f&#34;{k} must be a boolean in {allowed}&#34;)
            elif k == &#34;flow&#34;:
                allowedValues = {&#34;hor&#34;, &#34;ver&#34;}
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(allowedValues)
                    errors.append(f&#34;{k} must be a value in {allowed}&#34;)
            elif k == &#34;level&#34;:
                allowedValues = set(range(len(4)))
                if v not in allowedValues:
                    allowed = &#34;,&#34;.join(sorted(allowedValues))
                    errors.append(f&#34;{k} must be an integer in {allowed}&#34;)

    def checkGroup(self, cfg, defaults, dKey, postpone=set(), extra=None):
        self.cfg = cfg
        self.defaults = defaults
        self.dKey = dKey
        self.extra = extra
        errors = []

        errors.clear()
        dSource = cfg.get(dKey, {})

        for (k, v) in dSource.items():
            if k in defaults:
                if k not in postpone:
                    self.checkSetting(k, v)
            else:
                errors.append(f&#34;Illegal parameter `{k}` with value {v}&#34;)

    def checkItem(self, cfg, dKey):
        self.cfg = cfg
        self.dKey = dKey
        errors = self.errors

        errors.clear()
        if dKey in cfg:
            self.checkSetting(dKey, cfg[dKey])

    def report(self):
        errors = self.errors
        dKey = self.dKey

        if errors:
            console(f&#34;App config error(s) in {dKey}:&#34;, error=True)
            for msg in errors:
                console(f&#34;\t{msg}&#34;, error=True)

        self.errors = []</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.applib.settings.Check.checkGroup"><code class="name flex">
<span>def <span class="ident">checkGroup</span></span>(<span>self, cfg, defaults, dKey, postpone=set(), extra=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L323-L338" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkGroup(self, cfg, defaults, dKey, postpone=set(), extra=None):
    self.cfg = cfg
    self.defaults = defaults
    self.dKey = dKey
    self.extra = extra
    errors = []

    errors.clear()
    dSource = cfg.get(dKey, {})

    for (k, v) in dSource.items():
        if k in defaults:
            if k not in postpone:
                self.checkSetting(k, v)
        else:
            errors.append(f&#34;Illegal parameter `{k}` with value {v}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.Check.checkItem"><code class="name flex">
<span>def <span class="ident">checkItem</span></span>(<span>self, cfg, dKey)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L340-L347" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkItem(self, cfg, dKey):
    self.cfg = cfg
    self.dKey = dKey
    errors = self.errors

    errors.clear()
    if dKey in cfg:
        self.checkSetting(dKey, cfg[dKey])</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.Check.checkSetting"><code class="name flex">
<span>def <span class="ident">checkSetting</span></span>(<span>self, k, v, extra=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L174-L321" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkSetting(self, k, v, extra=None):
    app = self.app
    withApi = self.withApi
    errors = self.errors
    dKey = self.dKey
    specs = app.specs

    if withApi:
        api = app.api
        F = api.F
        T = api.T
        Fall = api.Fall
        allNodeFeatures = set(Fall())
        nTypes = F.otype.all
        sectionTypes = T.sectionTypes

        if k in {&#34;template&#34;, &#34;label&#34;}:
            (template, feats) = extra
            if template is not True and type(template) is not str:
                errors.append(f&#34;{k} must be `true` or a string&#34;)
            for feat in feats:
                if feat not in allNodeFeatures:
                    if feat not in specs[&#34;transform&#34;].get(dKey, {}):
                        errors.append(f&#34;{k}: feature {feat} not loaded&#34;)
        elif k in {&#34;featuresBare&#34;, &#34;features&#34;}:
            feats = extra[0]
            tps = extra[1].values()
            for feat in feats:
                if feat not in allNodeFeatures:
                    errors.append(f&#34;{k}: feature {feat} not loaded&#34;)
            for tp in tps:
                if tp not in nTypes:
                    errors.append(f&#34;{k}: node type {tp} not present&#34;)
        elif k == &#34;base&#34;:
            pass
        elif k == &#34;lineNumber&#34;:
            if v not in allNodeFeatures:
                errors.append(f&#34;{k}: feature {v} not loaded&#34;)
        elif k == &#34;browseNavLevel&#34;:
            allowedValues = set(range(len(sectionTypes)))
            if v not in allowedValues:
                allowed = &#34;,&#34;.join(sorted(allowedValues))
                errors.append(f&#34;{k} must be an integer in {allowed}&#34;)
        elif k in {&#34;children&#34;, &#34;xChildren&#34;}:
            if type(v) is not str and type(v) is not list:
                errors.append(f&#34;{k} must be a (list of) node types&#34;)
            else:
                v = {v} if type(v) is str else set(v)
                for tp in v:
                    if tp not in nTypes:
                        errors.append(f&#34;{k}: node type {tp} not present&#34;)
        elif k in {&#34;lexOcc&#34;}:
            if type(v) is not str or v not in nTypes:
                errors.append(f&#34;{k}: node type {v} not present&#34;)
        elif k == &#34;transform&#34;:
            for (feat, method) in extra.items():
                if type(method) is str:
                    errors.append(f&#34;{k}:{feat}: {method}() not implemented in app&#34;)
        elif k == &#34;style&#34;:
            if type(v) is not str or v.lower() != v:
                errors.append(f&#34;{k} must be an all lowercase string&#34;)
        elif k in {
            &#34;lineNumbers&#34;,
            &#34;prettyTypes&#34;,
            &#34;queryFeatures&#34;,
            &#34;showHidden&#34;,
            &#34;showGraphics&#34;,
            &#34;standardFeatures&#34;,
            &#34;withNodes&#34;,
            &#34;withTypes&#34;,
        }:
            allowed = self.extra[k]
            if not allowed and v is not None:
                errors.append(
                    f&#34;{k}={v} is not useful (dataset lacks relevant features)&#34;
                )
        elif k == &#34;textFormats&#34;:
            formatStyle = specs[&#34;formatStyle&#34;]
            if type(v) is dict:
                for (fmt, fmtInfo) in v.items():
                    for (fk, fv) in fmtInfo.items():
                        if fk not in FMT_KEYS:
                            errors.append(f&#34;{k}: {fmt}: illegal key {fk}&#34;)
                            continue
                        if fk == METHOD:
                            (descendType, func) = T.splitFormat(fv)
                            func = f&#34;fmt_{func}&#34;
                            if not hasattr(app, func):
                                errors.append(
                                    f&#34;{k}: {fmt} needs unimplemented method {func}&#34;
                                )
                        elif fk == STYLE:
                            if fv not in formatStyle:
                                if fv.lower() != fv:
                                    errors.append(
                                        f&#34;{k}: {fmt}: style {fv}&#34;
                                        f&#34; must be all lowercase&#34;
                                    )
            else:
                errors.append(f&#34;{k} must be a dictionary&#34;)
    else:
        if k in {&#34;excludedFeatures&#34;, &#34;noneValues&#34;}:
            if type(v) is not list:
                errors.append(f&#34;{k} must be a list&#34;)
        elif k in {
            &#34;sectionSep1&#34;,
            &#34;sectionSep2&#34;,
            &#34;exampleSection&#34;,
            &#34;exampleSectionHtml&#34;,
        }:
            if type(v) is not str:
                errors.append(f&#34;{k} must be a string&#34;)
        elif k == &#34;writing&#34;:
            allowedValues = set(WRITING_DEFAULTS)
            if v not in allowedValues:
                allowed = &#34;,&#34;.join(allowedValues - {&#34;&#34;})
                errors.append(f&#34;{k} must be the empty string or one of {allowed}&#34;)
        elif k in {&#34;direction&#34;, &#34;language&#34;}:
            allowedValues = {w[k] for w in WRITING_DEFAULTS}
            if v not in allowedValues:
                allowed = &#34;,&#34;.join(allowedValues)
                errors.append(f&#34;{k} must be one of {allowed}&#34;)
        elif k in {
            &#34;browseContentPretty&#34;,
            &#34;base&#34;,
            &#34;childrenPlain&#34;,
            &#34;condense&#34;,
            &#34;graphics&#34;,
            &#34;hidden&#34;,
            &#34;showVerseInTuple&#34;,
            &#34;stretch&#34;,
            &#34;verselike&#34;,
            &#34;wrap&#34;,
        }:
            allowedValues = {True, False}
            if v not in allowedValues:
                allowed = &#34;true,false&#34;
                errors.append(f&#34;{k} must be a boolean in {allowed}&#34;)
        elif k == &#34;flow&#34;:
            allowedValues = {&#34;hor&#34;, &#34;ver&#34;}
            if v not in allowedValues:
                allowed = &#34;,&#34;.join(allowedValues)
                errors.append(f&#34;{k} must be a value in {allowed}&#34;)
        elif k == &#34;level&#34;:
            allowedValues = set(range(len(4)))
            if v not in allowedValues:
                allowed = &#34;,&#34;.join(sorted(allowedValues))
                errors.append(f&#34;{k} must be an integer in {allowed}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.applib.settings.Check.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/63b63841dad123283aba68d8c9afca203f26bb51/tf/applib/settings.py#L349-L358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def report(self):
    errors = self.errors
    dKey = self.dKey

    if errors:
        console(f&#34;App config error(s) in {dKey}:&#34;, error=True)
        for msg in errors:
            console(f&#34;\t{msg}&#34;, error=True)

    self.errors = []</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="/text-fabric/images/tf-small.png"></a></p>
<p><a href="/text-fabric/index.html">tf home</a> - <a href="/text-fabric/cheatsheet.html">cheat sheet</a></p>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/annotation site:annotation.github.io site:www.annotation.nl"
data-gaCategoryParameter="tf.applib.settings">
</div>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#app-settings">App settings</a></li>
<li><a href="#config-specs">Config specs</a><ul>
<li><a href="#apiversion">apiVersion</a></li>
<li><a href="#datadisplay">dataDisplay</a><ul>
<li><a href="#browsecontentpretty">browseContentPretty</a></li>
<li><a href="#browsenavlevel">browseNavLevel</a></li>
<li><a href="#examplesection">exampleSection</a></li>
<li><a href="#examplesectionhtml">exampleSectionHtml</a></li>
<li><a href="#excludedfeatures">excludedFeatures</a></li>
<li><a href="#nonevalues">noneValues</a></li>
<li><a href="#sectionsep1">sectionSep1</a></li>
<li><a href="#sectionsep2">sectionSep2</a></li>
<li><a href="#showverseintuple">showVerseInTuple</a></li>
<li><a href="#textformats">textFormats</a></li>
</ul>
</li>
<li><a href="#docs">docs</a><ul>
<li><a href="#chartext">charText</a></li>
<li><a href="#charurl">charUrl</a></li>
<li><a href="#docbase">docBase</a></li>
<li><a href="#docext">docExt:</a></li>
<li><a href="#docpage">docPage</a></li>
<li><a href="#docroot">docRoot</a></li>
<li><a href="#featurebase">featureBase</a></li>
<li><a href="#featurepage">featurePage</a></li>
</ul>
</li>
<li><a href="#interfacedefaults">interfaceDefaults</a><ul>
<li><a href="#linenumbers">lineNumbers</a></li>
<li><a href="#prettytypes">prettyTypes</a></li>
<li><a href="#queryfeatures">queryFeatures</a></li>
<li><a href="#showhidden">showHidden</a></li>
<li><a href="#standardfeatures">standardFeatures</a></li>
<li><a href="#showgraphics">showGraphics</a></li>
<li><a href="#withnodes">withNodes</a></li>
<li><a href="#withtypes-false">withTypes: false</a></li>
</ul>
</li>
<li><a href="#provenancespec">provenanceSpec</a><ul>
<li><a href="#corpus">corpus</a></li>
<li><a href="#doi">doi</a></li>
<li><a href="#graphicsrelative">graphicsRelative</a></li>
<li><a href="#modulespecs">moduleSpecs</a></li>
<li><a href="#org">org</a></li>
<li><a href="#relative">relative</a></li>
<li><a href="#repo">repo</a></li>
<li><a href="#version">version</a></li>
<li><a href="#webbase">webBase</a></li>
<li><a href="#webhint">webHint</a></li>
<li><a href="#weblang">webLang</a></li>
<li><a href="#weblexid">webLexId</a></li>
<li><a href="#weburl">webUrl</a></li>
<li><a href="#weburllex">webUrlLex</a></li>
<li><a href="#zip">zip</a></li>
</ul>
</li>
<li><a href="#typedisplay">typeDisplay</a><ul>
<li><a href="#base">base</a></li>
<li><a href="#boundary">boundary</a></li>
<li><a href="#children">children</a></li>
<li><a href="#xchildren">xChildren</a></li>
<li><a href="#childrenplain">childrenPlain</a></li>
<li><a href="#condense">condense</a></li>
<li><a href="#features">features</a></li>
<li><a href="#featuresbare-feat1-feat2">featuresBare: feat1 feat2</a></li>
<li><a href="#flow">flow:</a></li>
<li><a href="#graphics">graphics</a></li>
<li><a href="#level">level</a></li>
<li><a href="#lexocc">lexOcc</a></li>
<li><a href="#linenumber">lineNumber</a></li>
<li><a href="#stretch">stretch</a></li>
<li><a href="#hidden">hidden</a></li>
<li><a href="#label-template">label, template</a></li>
<li><a href="#style">style</a></li>
<li><a href="#transform">transform</a></li>
<li><a href="#verselike">verselike</a></li>
<li><a href="#wrap">wrap</a></li>
</ul>
</li>
<li><a href="#writing">writing</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.applib" href="index.html">tf.applib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.applib.settings.compileFormatCls" href="#tf.applib.settings.compileFormatCls">compileFormatCls</a></code></li>
<li><code><a title="tf.applib.settings.getDataDefaults" href="#tf.applib.settings.getDataDefaults">getDataDefaults</a></code></li>
<li><code><a title="tf.applib.settings.getLevel" href="#tf.applib.settings.getLevel">getLevel</a></code></li>
<li><code><a title="tf.applib.settings.getTypeDefaults" href="#tf.applib.settings.getTypeDefaults">getTypeDefaults</a></code></li>
<li><code><a title="tf.applib.settings.setAppSpecs" href="#tf.applib.settings.setAppSpecs">setAppSpecs</a></code></li>
<li><code><a title="tf.applib.settings.setAppSpecsApi" href="#tf.applib.settings.setAppSpecsApi">setAppSpecsApi</a></code></li>
<li><code><a title="tf.applib.settings.showContext" href="#tf.applib.settings.showContext">showContext</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.applib.settings.AppCurrent" href="#tf.applib.settings.AppCurrent">AppCurrent</a></code></h4>
<ul class="">
<li><code><a title="tf.applib.settings.AppCurrent.get" href="#tf.applib.settings.AppCurrent.get">get</a></code></li>
<li><code><a title="tf.applib.settings.AppCurrent.update" href="#tf.applib.settings.AppCurrent.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.applib.settings.Check" href="#tf.applib.settings.Check">Check</a></code></h4>
<ul class="">
<li><code><a title="tf.applib.settings.Check.checkGroup" href="#tf.applib.settings.Check.checkGroup">checkGroup</a></code></li>
<li><code><a title="tf.applib.settings.Check.checkItem" href="#tf.applib.settings.Check.checkItem">checkItem</a></code></li>
<li><code><a title="tf.applib.settings.Check.checkSetting" href="#tf.applib.settings.Check.checkSetting">checkSetting</a></code></li>
<li><code><a title="tf.applib.settings.Check.report" href="#tf.applib.settings.Check.report">report</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://www.annotation.nl">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="/text-fabric/images/DANS-logo.png" width=200></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>