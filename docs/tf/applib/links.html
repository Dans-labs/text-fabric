<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>tf.applib.links API documentation</title>
<meta name="description" content="Produce links to Text-Fabric data and links from nodes to web resources." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.applib.links</code></h1>
</header>
<section id="section-intro">
<p>Produce links to Text-Fabric data and links from nodes to web resources.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Produce links to Text-Fabric data and links from nodes to web resources.
&#34;&#34;&#34;

import re
import types

from ..parameters import (
    URL_GH,
    URL_TFDOC,
    APP_URL,
    APP_NB_URL,
)
from ..core.helpers import htmlEsc
from .repo import Checkout
from .helpers import getText, dh
from ..server.wrap import wrapProvenance


UNSUPPORTED = &#34;not online&#34;

pathRe = re.compile(
    r&#34;^(.*/(?:github|text-fabric-data))/([^/]+)/([^/]+)/(.*)$&#34;, flags=re.I
)


def linksApi(app, silent):
    &#34;&#34;&#34;Produce the link API.

    The link API provides methods to maps nodes to urls of web resources.
    It also computes several provenance and documentation links from the
    configuration settings of the corpus.

    Parameters
    ----------
    app: obj
        The high-level API object
    silent:
        The verbosity mode to perform this operation in.
        Normally it is the same as for the app, but when we do an `A.reuse()`
        we force `silent=True`.
    &#34;&#34;&#34;
    app.showProvenance = types.MethodType(showProvenance, app)
    app.header = types.MethodType(header, app)
    app.webLink = types.MethodType(webLink, app)
    isCompatible = app.isCompatible

    api = app.api

    aContext = app.context
    appName = aContext.appName
    docUrl = aContext.docUrl
    repo = aContext.repo
    version = aContext.version
    corpus = aContext.corpus
    featureBase = aContext.featureBase
    featurePage = aContext.featurePage
    charUrl = aContext.charUrl
    charText = aContext.charText

    tutUrl = f&#34;{APP_NB_URL}/{appName}/start.ipynb&#34;
    extraUrl = f&#34;{APP_URL}/app-{appName}&#34;

    dataLink = (
        outLink(repo.upper(), docUrl, f&#34;provenance of {corpus}&#34;)
        if isCompatible and repo is not None and docUrl
        else UNSUPPORTED
    )
    charLink = (
        (
            outLink(&#34;Character table&#34;, charUrl.format(tfDoc=URL_TFDOC), charText)
            if isCompatible
            else UNSUPPORTED
        )
        if charUrl
        else &#34;&#34;
    )
    featureLink = (
        (
            outLink(
                &#34;Feature docs&#34;,
                featureBase.replace(&#34;&lt;feature&gt;&#34;, featurePage).format(version=version),
                f&#34;{repo.upper()} feature documentation&#34;,
            )
            if isCompatible and repo is not None and featureBase
            else UNSUPPORTED
        )
        if isCompatible
        else UNSUPPORTED
    )
    appLink = outLink(
        f&#34;{appName} API&#34;,
        extraUrl,
        f&#34;{appName} API documentation&#34;
        if isCompatible and repo is not None
        else UNSUPPORTED,
    )
    tfLink = (
        outLink(
            f&#34;Text-Fabric API {api.TF.version}&#34;,
            f&#34;{URL_TFDOC}/Api/Fabric/&#34;,
            &#34;text-fabric-api&#34;,
        )
        if isCompatible
        else UNSUPPORTED
    )
    tfsLink = (
        outLink(
            &#34;Search Reference&#34;,
            f&#34;{URL_TFDOC}/Use/Search/&#34;,
            &#34;Search Templates Introduction and Reference&#34;,
        )
        if isCompatible
        else UNSUPPORTED
    )
    tutLink = (
        outLink(&#34;App tutorial&#34;, tutUrl, &#34;App tutorial in Jupyter Notebook&#34;)
        if isCompatible and repo is not None
        else UNSUPPORTED
    )

    app.appLink = appLink
    app.dataLink = dataLink
    app.charLink = charLink
    app.featureLink = featureLink
    app.tfLink = tfLink
    app.tfsLink = tfsLink
    app.tutLink = tutLink

    if not app._browse:
        if not silent:
            header(app)


def header(app):
    &#34;&#34;&#34;Generate a colofon of the TF-app.

    This colofon will be displayed after initializing the advanced API,
    and it is packed with provenance and documentation links.
    &#34;&#34;&#34;

    appLink = app.appLink
    dataLink = app.dataLink
    charLink = app.charLink
    featureLink = app.featureLink
    tfsLink = app.tfsLink
    tfLink = app.tfLink
    tutLink = app.tutLink

    if app._browse:
        return (
            f&#34;&#34;&#34;\
&lt;div class=&#34;hdlinks&#34;&gt;
  {dataLink}
  {charLink}
  {featureLink}
  {tfsLink}
  {tutLink}
&lt;/div&gt;\
&#34;&#34;&#34;,
            f&#39;&lt;img class=&#34;hdlogo&#34; src=&#34;/data/static/logo.png&#34;/&gt;&#39;,
            f&#39;&lt;img class=&#34;hdlogo&#34; src=&#34;/server/static/icon.png&#34;/&gt;&#39;,
        )
    else:
        dh(
            &#34;&lt;b&gt;Documentation:&lt;/b&gt;&#34;
            f&#34; {dataLink} {charLink} {featureLink} {appLink} {tfLink} {tfsLink}&#34;
            &#34;&lt;details open&gt;&lt;summary&gt;&lt;b&gt;Loaded features&lt;/b&gt;:&lt;/summary&gt;\n&#34;
            + _featuresPerModule(app)
            + &#34;&lt;/details&gt;&#34;
        )


def webLink(
    app, n, text=None, clsName=None, urlOnly=False, _asString=False, _noUrl=False
):
    &#34;&#34;&#34;Maps a node to a web resource.

    Usually called as `A.webLink(...)`

    The mapping is quite sophisticated. It will do sensible things for
    section nodes and lexeme nodes, dependent on how they are configured in
    the app&#39;s `config.yaml`.

    !!! hint &#34;Customizable&#34;
        You can customize the behaviour of `webLink()` to the needs of your corpus
        by providing appropriate values in its `config.yaml`, especially for
        `webBase`, `webLang`, `webUrl`, `webUrlLex`, and `webHint`.

    Parameters
    ----------
    n: int
        A node
    text: string/HTML, optional default `None`
        The text of the link. If left out, a suitable text will be derived from
        the node.
    clsName: string, optional default `None`
        A CSS class name to add to the resulting link element
    urlOnly: boolean, optional `False`
        If True, only the url will be returned.
    _asString: boolean, optional `False`
        Whether to deliver the result as a piece of HTML or to display the link
        on the (Jupyter) interface.
    _noUrl: boolean, optional `False`
        Whether to put the generated url in the `href` attribute.
        It can be inhibited. This is useful for the TF-browser, which may want
        to attach an action to the link and navigate to a location based on
        other attributes.
    &#34;&#34;&#34;

    api = app.api
    T = api.T
    F = api.F
    Fs = api.Fs

    aContext = app.context
    webBase = aContext.webBase
    webLang = aContext.webLang
    webUrl = aContext.webUrl
    webUrlLex = aContext.webUrlLex
    webLexId = aContext.webLexId
    webHint = aContext.webHint
    lexTypes = aContext.lexTypes
    styles = aContext.styles

    nType = F.otype.v(n)
    passageText = None

    if nType in lexTypes:
        if text is None:
            text = getText(app, False, n, nType, False, True, True, &#34;&#34;, None)
        if webUrlLex and webLexId:
            lid = (
                app.getLexId(n)
                if webLexId is True
                else Fs(webLexId).v(n)
                if webLexId
                else None
            )
            theUrl = webUrlLex.replace(&#34;&lt;lid&gt;&#34;, str(lid))
        elif webBase:
            theUrl = webBase
        else:
            theUrl = None
    else:
        if text is None:
            text = app.sectionStrFromNode(n)
            passageText = text
        if webUrl:
            theUrl = webUrl
            headingTuple = T.sectionFromNode(n, lang=webLang, fillup=True)
            for (i, heading) in enumerate(headingTuple):
                theUrl = theUrl.replace(f&#34;&lt;{i + 1}&gt;&#34;, str(heading))
        else:
            theUrl = None

    style = styles.get(nType, None)
    if style:
        clsName = f&#34;{clsName or &#39;&#39;} {style}&#34;
    if theUrl is None:
        fullResult = text
        href = None
    else:
        href = &#34;#&#34; if _noUrl else theUrl
        atts = dict(target=&#34;&#34;) if _noUrl else dict(title=webHint)
        fullResult = outLink(text, href, clsName=clsName, passage=passageText, **atts,)
    result = href if urlOnly else fullResult
    if _asString or urlOnly:
        return result
    dh(result)


def showProvenance(app, jobName=&#34;program code&#34;, author=&#34;program author&#34;):
    &#34;&#34;&#34;Shows the provenance that is normally displayed during data loading.

    This comes in handy if you have started with `use(xxx, silence=&#39;deep&#39;)` and still
    need to show the provenance.
    Moreover, the provenance is shown in a formatted way.

    Parameters
    ----------
    jobName: string, optional `program code`
        E.g. the name of program in which you call this function.
        In the Text-Fabric browser the name of the job will be entered here.
        This item will be displayed together with the rest of the provenance.

    author: string, optional `program author`
        E.g. your own name.
        This item will be displayed together with the rest of the provenance.
    &#34;&#34;&#34;

    aContext = app.context
    appName = aContext.appName
    commit = aContext.commit
    appProvenance = (((&#34;name&#34;, appName), (&#34;commit&#34;, commit)),)
    provenance = (appProvenance, app.provenance)
    setNames = (
        tuple(sorted(app.sets.keys()))
        if hasattr(app, &#34;sets&#34;) and type(app.sets) is dict
        else ()
    )
    form = dict(jobName=jobName, author=author)
    dh(wrapProvenance(form, provenance, setNames)[0])


def outLink(text, href, title=None, passage=None, clsName=None, target=&#34;_blank&#34;):
    &#34;&#34;&#34;Produce a formatted link.

    Parameters
    ----------
    text: string/HTML
        The text of the link.
    href: string/URL
        The url of the link.
    title: string, optional `None`
        The hint of the link.
    target: string, optional `_blank`
        The target window/tab of the link.
    clsName: string, optional default `None`
        A CSS class name to add to the resulting link element
    passage: string, optional `None`
        A passage indicator, which will end up in the `sec` attribute of the
        link element. Used by the TF-browser.
    &#34;&#34;&#34;

    titleAtt = &#34;&#34; if title is None else f&#39; title=&#34;{title}&#34;&#39;
    clsAtt = f&#39; class=&#34;{clsName.lower()}&#34;&#39; if clsName else &#34;&#34;
    targetAtt = f&#39; target=&#34;{target}&#34;&#39; if target else &#34;&#34;
    passageAtt = f&#39; sec=&#34;{passage}&#34;&#39; if passage else &#34;&#34;
    return (
        f&#39;&lt;a{clsAtt}{targetAtt} href=&#34;{htmlEsc(href)}&#34;{titleAtt}{passageAtt}&gt;&#39;
        f&#34;{text}&lt;/a&gt;&#34;
    )


def _featuresPerModule(app):
    &#34;&#34;&#34;Generate a formatted list of loaded TF features, per module.
    &#34;&#34;&#34;

    isCompatible = app.isCompatible
    if not isCompatible:
        return UNSUPPORTED

    api = app.api
    TF = api.TF

    aContext = app.context
    mOrg = aContext.org
    mRepo = aContext.repo
    mRelative = aContext.relative
    version = aContext.version
    moduleSpecs = aContext.moduleSpecs
    corpus = aContext.corpus
    featureBase = aContext.featureBase

    features = api.Fall() + api.Eall()

    fixedModuleIndex = {}
    for m in moduleSpecs or []:
        fixedModuleIndex[(m[&#34;org&#34;], m[&#34;repo&#34;], m[&#34;relative&#34;])] = (
            m[&#34;corpus&#34;],
            m[&#34;docUrl&#34;],
        )

    moduleIndex = {}
    mLocations = app.mLocations if hasattr(app, &#34;mLocations&#34;) else []
    baseLoc = mLocations[0] if hasattr(app, &#34;mLocations&#34;) else ()

    for mLoc in mLocations:
        match = pathRe.fullmatch(mLoc)
        if not match:
            moduleIndex[mLoc] = (&#34;??&#34;, &#34;??&#34;, &#34;??&#34;, mLoc, &#34;&#34;)
        else:
            (base, org, repo, relative) = match.groups()
            mId = (org, repo, relative)
            (corpus, docUrl) = (
                (relative, None)
                if org is None or repo is None
                else (
                    (corpus, featureBase.format(version=version))
                    if featureBase
                    else (corpus, None)
                )
                if mLoc == baseLoc
                else fixedModuleIndex[mId]
                if mId in fixedModuleIndex
                else (
                    f&#34;{org}/{repo}/{relative}&#34;,
                    f&#34;{URL_GH}/{org}/{repo}/tree/master/{relative}&#34;,
                )
            )
            moduleIndex[mId] = (org, repo, relative, corpus, docUrl)

    featureCat = {}

    for feature in features:
        added = False
        featureInfo = TF.features[feature]
        featurePath = featureInfo.path
        match = pathRe.fullmatch(featurePath)
        if match:
            (base, fOrg, fRepo, relative) = match.groups()
            fRelative = relative.rsplit(&#34;/&#34;, 1)[0]
            mId = (fOrg, fRepo, fRelative)
        else:
            mId = featurePath.rsplit(&#34;/&#34;, 1)[0]
        if type(mId) is str:
            for (mIId, mInfo) in moduleIndex.items():
                if type(mIId) is str:
                    if featurePath.startswith(mIId):
                        featureCat.setdefault(mIId, []).append(feature)
                        added = True
        else:
            for (mIId, mInfo) in moduleIndex.items():
                if type(mIId) is not str:
                    (mOrg, mRepo, mRelative) = mIId
                    if (
                        fOrg == mOrg
                        and fRepo == mRepo
                        and fRelative.startswith(mRelative)
                    ):
                        featureCat.setdefault(mIId, []).append(feature)
                        added = True
        if not added:
            featureCat.setdefault(mId, []).append(feature)

    baseId = (mOrg, mRepo, mRelative)
    baseMods = {
        mId for mId in featureCat.keys() if type(mId) is tuple and mId == baseId
    }
    moduleOrder = list(baseMods) + sorted(
        (mId for mId in featureCat.keys() if mId not in baseMods),
        key=lambda mId: (1, mId) if type(mId) is str else (0, mId),
    )

    html = &#34;&#34;
    for mId in moduleOrder:
        catFeats = featureCat[mId]
        if not catFeats:
            continue
        modInfo = moduleIndex.get(mId, None)
        if modInfo:
            (org, repo, relative, corpus, docUrl) = modInfo
        else:
            corpus = mId if type(mId) is str else &#34;/&#34;.join(mId)
            docUrl = (
                &#34;&#34;
                if type(mId) is str
                else f&#34;{URL_GH}/{mId[0]}/{mId[1]}/tree/master/{mId[2]}&#34;
            )
        html += f&#34;&lt;p&gt;&lt;b&gt;{corpus}&lt;/b&gt;:&#34;

        seen = set()

        for feature in catFeats:
            if &#34;@&#34; in feature:
                dlFeature = f&#39;{feature.rsplit(&#34;@&#34;, 1)[0]}@ll&#39;
                if dlFeature in seen:
                    continue
                seen.add(dlFeature)
                featureRep = dlFeature
            else:
                featureRep = feature
            featureInfo = TF.features[feature]
            featurePath = featureInfo.path
            isEdge = featureInfo.isEdge
            pre = &#34;&lt;b&gt;&lt;i&gt;&#34; if isEdge else &#34;&#34;
            post = &#34;&lt;/i&gt;&lt;/b&gt;&#34; if isEdge else &#34;&#34;
            html += f&#34; {pre}&#34;
            html += (
                outLink(
                    featureRep,
                    docUrl.replace(&#34;&lt;feature&gt;&#34;, featureRep),
                    title=featurePath,
                )
                if docUrl
                else f&#39;&lt;span title=&#34;{featurePath}&#34;&gt;{featureRep}&lt;/span&gt;&#39;
            )
            html += f&#34;{post} &#34;
        html += &#34;&lt;/p&gt;&#34;
    return html


def provenanceLink(org, repo, version, commit, release, local, relative):
    &#34;&#34;&#34;Generate a provenance link for a data source.

    We assume the data source resides somewhere inside a GitHub repo.

    Parameters
    ----------
    org: string
        Organization on GitHub
    repo: string
        Repository on Github
    version: string
        Version of the data source.
        This is not the release or commit of a repo, but the subdirectory
        corresponding with a data version under a `tf` directory with feature files.
    commit: string
        The commit hash of the repository on GitHub.
    &#34;&#34;&#34;

    text = (
        f&#34;data on local machine {relative}&#34;
        if org is None or repo is None
        else f&#34;{org}/{repo} v:{version} ({Checkout.toString(commit, release, local)})&#34;
    )
    relativeFlat = relative.replace(&#34;/&#34;, &#34;-&#34;)
    url = (
        None
        if org is None or repo is None
        else f&#34;{URL_GH}/{org}/{repo}/tree/master/{relative}&#34;
        if local
        else (
            f&#34;{URL_GH}/{org}/{repo}/releases/download/{release}&#34;
            f&#34;/{relativeFlat}-{version}.zip&#34;
            if release
            else f&#34;{URL_GH}/{org}/{repo}/tree/{commit}/{relative}&#34;
        )
    )
    return (text, url)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.applib.links.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>app)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a colofon of the TF-app.</p>
<p>This colofon will be displayed after initializing the advanced API,
and it is packed with provenance and documentation links.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(app):
    &#34;&#34;&#34;Generate a colofon of the TF-app.

    This colofon will be displayed after initializing the advanced API,
    and it is packed with provenance and documentation links.
    &#34;&#34;&#34;

    appLink = app.appLink
    dataLink = app.dataLink
    charLink = app.charLink
    featureLink = app.featureLink
    tfsLink = app.tfsLink
    tfLink = app.tfLink
    tutLink = app.tutLink

    if app._browse:
        return (
            f&#34;&#34;&#34;\
&lt;div class=&#34;hdlinks&#34;&gt;
  {dataLink}
  {charLink}
  {featureLink}
  {tfsLink}
  {tutLink}
&lt;/div&gt;\
&#34;&#34;&#34;,
            f&#39;&lt;img class=&#34;hdlogo&#34; src=&#34;/data/static/logo.png&#34;/&gt;&#39;,
            f&#39;&lt;img class=&#34;hdlogo&#34; src=&#34;/server/static/icon.png&#34;/&gt;&#39;,
        )
    else:
        dh(
            &#34;&lt;b&gt;Documentation:&lt;/b&gt;&#34;
            f&#34; {dataLink} {charLink} {featureLink} {appLink} {tfLink} {tfsLink}&#34;
            &#34;&lt;details open&gt;&lt;summary&gt;&lt;b&gt;Loaded features&lt;/b&gt;:&lt;/summary&gt;\n&#34;
            + _featuresPerModule(app)
            + &#34;&lt;/details&gt;&#34;
        )</code></pre>
</details>
</dd>
<dt id="tf.applib.links.linksApi"><code class="name flex">
<span>def <span class="ident">linksApi</span></span>(<span>app, silent)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the link API.</p>
<p>The link API provides methods to maps nodes to urls of web resources.
It also computes several provenance and documentation links from the
configuration settings of the corpus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>obj</code></dt>
<dd>The high-level API object</dd>
</dl>
<p>silent:
The verbosity mode to perform this operation in.
Normally it is the same as for the app, but when we do an <code>A.reuse()</code>
we force <code>silent=True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linksApi(app, silent):
    &#34;&#34;&#34;Produce the link API.

    The link API provides methods to maps nodes to urls of web resources.
    It also computes several provenance and documentation links from the
    configuration settings of the corpus.

    Parameters
    ----------
    app: obj
        The high-level API object
    silent:
        The verbosity mode to perform this operation in.
        Normally it is the same as for the app, but when we do an `A.reuse()`
        we force `silent=True`.
    &#34;&#34;&#34;
    app.showProvenance = types.MethodType(showProvenance, app)
    app.header = types.MethodType(header, app)
    app.webLink = types.MethodType(webLink, app)
    isCompatible = app.isCompatible

    api = app.api

    aContext = app.context
    appName = aContext.appName
    docUrl = aContext.docUrl
    repo = aContext.repo
    version = aContext.version
    corpus = aContext.corpus
    featureBase = aContext.featureBase
    featurePage = aContext.featurePage
    charUrl = aContext.charUrl
    charText = aContext.charText

    tutUrl = f&#34;{APP_NB_URL}/{appName}/start.ipynb&#34;
    extraUrl = f&#34;{APP_URL}/app-{appName}&#34;

    dataLink = (
        outLink(repo.upper(), docUrl, f&#34;provenance of {corpus}&#34;)
        if isCompatible and repo is not None and docUrl
        else UNSUPPORTED
    )
    charLink = (
        (
            outLink(&#34;Character table&#34;, charUrl.format(tfDoc=URL_TFDOC), charText)
            if isCompatible
            else UNSUPPORTED
        )
        if charUrl
        else &#34;&#34;
    )
    featureLink = (
        (
            outLink(
                &#34;Feature docs&#34;,
                featureBase.replace(&#34;&lt;feature&gt;&#34;, featurePage).format(version=version),
                f&#34;{repo.upper()} feature documentation&#34;,
            )
            if isCompatible and repo is not None and featureBase
            else UNSUPPORTED
        )
        if isCompatible
        else UNSUPPORTED
    )
    appLink = outLink(
        f&#34;{appName} API&#34;,
        extraUrl,
        f&#34;{appName} API documentation&#34;
        if isCompatible and repo is not None
        else UNSUPPORTED,
    )
    tfLink = (
        outLink(
            f&#34;Text-Fabric API {api.TF.version}&#34;,
            f&#34;{URL_TFDOC}/Api/Fabric/&#34;,
            &#34;text-fabric-api&#34;,
        )
        if isCompatible
        else UNSUPPORTED
    )
    tfsLink = (
        outLink(
            &#34;Search Reference&#34;,
            f&#34;{URL_TFDOC}/Use/Search/&#34;,
            &#34;Search Templates Introduction and Reference&#34;,
        )
        if isCompatible
        else UNSUPPORTED
    )
    tutLink = (
        outLink(&#34;App tutorial&#34;, tutUrl, &#34;App tutorial in Jupyter Notebook&#34;)
        if isCompatible and repo is not None
        else UNSUPPORTED
    )

    app.appLink = appLink
    app.dataLink = dataLink
    app.charLink = charLink
    app.featureLink = featureLink
    app.tfLink = tfLink
    app.tfsLink = tfsLink
    app.tutLink = tutLink

    if not app._browse:
        if not silent:
            header(app)</code></pre>
</details>
</dd>
<dt id="tf.applib.links.outLink"><code class="name flex">
<span>def <span class="ident">outLink</span></span>(<span>text, href, title=None, passage=None, clsName=None, target='_blank')</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a formatted link.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string/HTML</code></dt>
<dd>The text of the link.</dd>
<dt><strong><code>href</code></strong> :&ensp;<code>string/URL</code></dt>
<dd>The url of the link.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The hint of the link.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>string</code>, optional <code>_blank</code></dt>
<dd>The target window/tab of the link.</dd>
<dt><strong><code>clsName</code></strong> :&ensp;<code>string</code>, optional <code>default </code>None``</dt>
<dd>A CSS class name to add to the resulting link element</dd>
<dt><strong><code>passage</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A passage indicator, which will end up in the <code>sec</code> attribute of the
link element. Used by the TF-browser.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outLink(text, href, title=None, passage=None, clsName=None, target=&#34;_blank&#34;):
    &#34;&#34;&#34;Produce a formatted link.

    Parameters
    ----------
    text: string/HTML
        The text of the link.
    href: string/URL
        The url of the link.
    title: string, optional `None`
        The hint of the link.
    target: string, optional `_blank`
        The target window/tab of the link.
    clsName: string, optional default `None`
        A CSS class name to add to the resulting link element
    passage: string, optional `None`
        A passage indicator, which will end up in the `sec` attribute of the
        link element. Used by the TF-browser.
    &#34;&#34;&#34;

    titleAtt = &#34;&#34; if title is None else f&#39; title=&#34;{title}&#34;&#39;
    clsAtt = f&#39; class=&#34;{clsName.lower()}&#34;&#39; if clsName else &#34;&#34;
    targetAtt = f&#39; target=&#34;{target}&#34;&#39; if target else &#34;&#34;
    passageAtt = f&#39; sec=&#34;{passage}&#34;&#39; if passage else &#34;&#34;
    return (
        f&#39;&lt;a{clsAtt}{targetAtt} href=&#34;{htmlEsc(href)}&#34;{titleAtt}{passageAtt}&gt;&#39;
        f&#34;{text}&lt;/a&gt;&#34;
    )</code></pre>
</details>
</dd>
<dt id="tf.applib.links.provenanceLink"><code class="name flex">
<span>def <span class="ident">provenanceLink</span></span>(<span>org, repo, version, commit, release, local, relative)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a provenance link for a data source.</p>
<p>We assume the data source resides somewhere inside a GitHub repo.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>org</code></strong> :&ensp;<code>string</code></dt>
<dd>Organization on GitHub</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>string</code></dt>
<dd>Repository on Github</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code></dt>
<dd>Version of the data source.
This is not the release or commit of a repo, but the subdirectory
corresponding with a data version under a <code><a title="tf" href="../index.html">tf</a></code> directory with feature files.</dd>
<dt><strong><code>commit</code></strong> :&ensp;<code>string</code></dt>
<dd>The commit hash of the repository on GitHub.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def provenanceLink(org, repo, version, commit, release, local, relative):
    &#34;&#34;&#34;Generate a provenance link for a data source.

    We assume the data source resides somewhere inside a GitHub repo.

    Parameters
    ----------
    org: string
        Organization on GitHub
    repo: string
        Repository on Github
    version: string
        Version of the data source.
        This is not the release or commit of a repo, but the subdirectory
        corresponding with a data version under a `tf` directory with feature files.
    commit: string
        The commit hash of the repository on GitHub.
    &#34;&#34;&#34;

    text = (
        f&#34;data on local machine {relative}&#34;
        if org is None or repo is None
        else f&#34;{org}/{repo} v:{version} ({Checkout.toString(commit, release, local)})&#34;
    )
    relativeFlat = relative.replace(&#34;/&#34;, &#34;-&#34;)
    url = (
        None
        if org is None or repo is None
        else f&#34;{URL_GH}/{org}/{repo}/tree/master/{relative}&#34;
        if local
        else (
            f&#34;{URL_GH}/{org}/{repo}/releases/download/{release}&#34;
            f&#34;/{relativeFlat}-{version}.zip&#34;
            if release
            else f&#34;{URL_GH}/{org}/{repo}/tree/{commit}/{relative}&#34;
        )
    )
    return (text, url)</code></pre>
</details>
</dd>
<dt id="tf.applib.links.showProvenance"><code class="name flex">
<span>def <span class="ident">showProvenance</span></span>(<span>app, jobName='program code', author='program author')</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the provenance that is normally displayed during data loading.</p>
<p>This comes in handy if you have started with <code>use(xxx, silence='deep')</code> and still
need to show the provenance.
Moreover, the provenance is shown in a formatted way.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>jobName</code></strong> :&ensp;<code>string</code>, optional <code>program code</code></dt>
<dd>E.g. the name of program in which you call this function.
In the Text-Fabric browser the name of the job will be entered here.
This item will be displayed together with the rest of the provenance.</dd>
<dt><strong><code>author</code></strong> :&ensp;<code>string</code>, optional <code>program author</code></dt>
<dd>E.g. your own name.
This item will be displayed together with the rest of the provenance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showProvenance(app, jobName=&#34;program code&#34;, author=&#34;program author&#34;):
    &#34;&#34;&#34;Shows the provenance that is normally displayed during data loading.

    This comes in handy if you have started with `use(xxx, silence=&#39;deep&#39;)` and still
    need to show the provenance.
    Moreover, the provenance is shown in a formatted way.

    Parameters
    ----------
    jobName: string, optional `program code`
        E.g. the name of program in which you call this function.
        In the Text-Fabric browser the name of the job will be entered here.
        This item will be displayed together with the rest of the provenance.

    author: string, optional `program author`
        E.g. your own name.
        This item will be displayed together with the rest of the provenance.
    &#34;&#34;&#34;

    aContext = app.context
    appName = aContext.appName
    commit = aContext.commit
    appProvenance = (((&#34;name&#34;, appName), (&#34;commit&#34;, commit)),)
    provenance = (appProvenance, app.provenance)
    setNames = (
        tuple(sorted(app.sets.keys()))
        if hasattr(app, &#34;sets&#34;) and type(app.sets) is dict
        else ()
    )
    form = dict(jobName=jobName, author=author)
    dh(wrapProvenance(form, provenance, setNames)[0])</code></pre>
</details>
</dd>
<dt id="tf.applib.links.webLink"><code class="name flex">
<span>def <span class="ident">webLink</span></span>(<span>app, n, text=None, clsName=None, urlOnly=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps a node to a web resource.</p>
<p>Usually called as <code>A.webLink(&hellip;)</code></p>
<p>The mapping is quite sophisticated. It will do sensible things for
section nodes and lexeme nodes, dependent on how they are configured in
the app's <code>config.yaml</code>.</p>
<div class="admonition hint">
<p class="admonition-title">Customizable</p>
<p>You can customize the behaviour of <code><a title="tf.applib.links.webLink" href="#tf.applib.links.webLink">webLink()</a></code> to the needs of your corpus
by providing appropriate values in its <code>config.yaml</code>, especially for
<code>webBase</code>, <code>webLang</code>, <code>webUrl</code>, <code>webUrlLex</code>, and <code>webHint</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>A node</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>string/HTML</code>, optional <code>default </code>None``</dt>
<dd>The text of the link. If left out, a suitable text will be derived from
the node.</dd>
<dt><strong><code>clsName</code></strong> :&ensp;<code>string</code>, optional <code>default </code>None``</dt>
<dd>A CSS class name to add to the resulting link element</dd>
<dt><strong><code>urlOnly</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, only the url will be returned.</dd>
<dt><strong><code>_asString</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to deliver the result as a piece of HTML or to display the link
on the (Jupyter) interface.</dd>
<dt><strong><code>_noUrl</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to put the generated url in the <code>href</code> attribute.
It can be inhibited. This is useful for the TF-browser, which may want
to attach an action to the link and navigate to a location based on
other attributes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def webLink(
    app, n, text=None, clsName=None, urlOnly=False, _asString=False, _noUrl=False
):
    &#34;&#34;&#34;Maps a node to a web resource.

    Usually called as `A.webLink(...)`

    The mapping is quite sophisticated. It will do sensible things for
    section nodes and lexeme nodes, dependent on how they are configured in
    the app&#39;s `config.yaml`.

    !!! hint &#34;Customizable&#34;
        You can customize the behaviour of `webLink()` to the needs of your corpus
        by providing appropriate values in its `config.yaml`, especially for
        `webBase`, `webLang`, `webUrl`, `webUrlLex`, and `webHint`.

    Parameters
    ----------
    n: int
        A node
    text: string/HTML, optional default `None`
        The text of the link. If left out, a suitable text will be derived from
        the node.
    clsName: string, optional default `None`
        A CSS class name to add to the resulting link element
    urlOnly: boolean, optional `False`
        If True, only the url will be returned.
    _asString: boolean, optional `False`
        Whether to deliver the result as a piece of HTML or to display the link
        on the (Jupyter) interface.
    _noUrl: boolean, optional `False`
        Whether to put the generated url in the `href` attribute.
        It can be inhibited. This is useful for the TF-browser, which may want
        to attach an action to the link and navigate to a location based on
        other attributes.
    &#34;&#34;&#34;

    api = app.api
    T = api.T
    F = api.F
    Fs = api.Fs

    aContext = app.context
    webBase = aContext.webBase
    webLang = aContext.webLang
    webUrl = aContext.webUrl
    webUrlLex = aContext.webUrlLex
    webLexId = aContext.webLexId
    webHint = aContext.webHint
    lexTypes = aContext.lexTypes
    styles = aContext.styles

    nType = F.otype.v(n)
    passageText = None

    if nType in lexTypes:
        if text is None:
            text = getText(app, False, n, nType, False, True, True, &#34;&#34;, None)
        if webUrlLex and webLexId:
            lid = (
                app.getLexId(n)
                if webLexId is True
                else Fs(webLexId).v(n)
                if webLexId
                else None
            )
            theUrl = webUrlLex.replace(&#34;&lt;lid&gt;&#34;, str(lid))
        elif webBase:
            theUrl = webBase
        else:
            theUrl = None
    else:
        if text is None:
            text = app.sectionStrFromNode(n)
            passageText = text
        if webUrl:
            theUrl = webUrl
            headingTuple = T.sectionFromNode(n, lang=webLang, fillup=True)
            for (i, heading) in enumerate(headingTuple):
                theUrl = theUrl.replace(f&#34;&lt;{i + 1}&gt;&#34;, str(heading))
        else:
            theUrl = None

    style = styles.get(nType, None)
    if style:
        clsName = f&#34;{clsName or &#39;&#39;} {style}&#34;
    if theUrl is None:
        fullResult = text
        href = None
    else:
        href = &#34;#&#34; if _noUrl else theUrl
        atts = dict(target=&#34;&#34;) if _noUrl else dict(title=webHint)
        fullResult = outLink(text, href, clsName=clsName, passage=passageText, **atts,)
    result = href if urlOnly else fullResult
    if _asString or urlOnly:
        return result
    dh(result)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<img src="../images/tf-small.png">
<img src="../../images/tf-small.png">
<div><a href="/tf/cheatsheet.html">cheat sheet</a></div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.applib" href="index.html">tf.applib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.applib.links.header" href="#tf.applib.links.header">header</a></code></li>
<li><code><a title="tf.applib.links.linksApi" href="#tf.applib.links.linksApi">linksApi</a></code></li>
<li><code><a title="tf.applib.links.outLink" href="#tf.applib.links.outLink">outLink</a></code></li>
<li><code><a title="tf.applib.links.provenanceLink" href="#tf.applib.links.provenanceLink">provenanceLink</a></code></li>
<li><code><a title="tf.applib.links.showProvenance" href="#tf.applib.links.showProvenance">showProvenance</a></code></li>
<li><code><a title="tf.applib.links.webLink" href="#tf.applib.links.webLink">webLink</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>