<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>tf.fabric API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.fabric</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os

&#34;&#34;&#34;Defined the main class.

Also lists the precomputation steps.
&#34;&#34;&#34;

import collections
from .parameters import VERSION, NAME, APIREF, LOCATIONS
from .core.data import Data, WARP, WARP2_DEFAULT, MEM_MSG
from .core.helpers import (
    itemize,
    setDir,
    expandDir,
    collectFormats,
    cleanName,
    check32,
    console,
    makeExamples,
)
from .core.timestamp import Timestamp
from .core.prepare import (
    levels,
    order,
    rank,
    levUp,
    levDown,
    boundary,
    sections,
    structure,
)
from .core.api import (
    Api,
    NodeFeature,
    EdgeFeature,
    OtypeFeature,
    OslotsFeature,
    Computed,
    addSortKey,
    addOtype,
    addLocality,
    addRank,
    addText,
    addSearch,
)
from .convert.mql import MQL, tfFromMql


PRECOMPUTE = (
    (False, &#34;__levels__&#34;, levels, WARP),
    (False, &#34;__order__&#34;, order, WARP[0:2] + (&#34;__levels__&#34;,)),
    (False, &#34;__rank__&#34;, rank, (WARP[0], &#34;__order__&#34;)),
    (False, &#34;__levUp__&#34;, levUp, WARP[0:2] + (&#34;__rank__&#34;,)),
    (False, &#34;__levDown__&#34;, levDown, (WARP[0], &#34;__levUp__&#34;, &#34;__rank__&#34;)),
    (False, &#34;__boundary__&#34;, boundary, WARP[0:2] + (&#34;__rank__&#34;,)),
    (True, &#34;__sections__&#34;, sections, WARP + (&#34;__levUp__&#34;, &#34;__levels__&#34;)),
    (True, &#34;__structure__&#34;, structure, WARP + (&#34;__rank__&#34;, &#34;__levUp__&#34;,)),
)
&#34;&#34;&#34;Precomputation steps.

Each step corresponds to a precomputation task.

A task is specified by a tuple containing:

Parameters
----------
dep: boolean
    Whether the step is dependent on the presence of additional features.
    Only relevant for the precomputation of section structure:
    that should only happen if there are section features.
name: string
    The name of the result of a precomputed task.
    The result is a blob of data that can be loaded and compressed just as ordinary features.
function: function
    The function that performs the precomputation task.
    These functions are defined in `tf.core.prepare`.
dependencies: strings
    The remaining parts of the tuple are the names of precomputed features
    that must be coomputed before and whose results are passed as argument
    to the function that executes the precomputation.

For a description of what the steps are for, see the functions
in `tf.core.prepare`.
&#34;&#34;&#34;
KIND = dict(__sections__=&#34;section&#34;, __structure__=&#34;structure&#34;)


class Fabric(object):
    &#34;&#34;&#34;Main class of the TF package.

    Top level management of

    *   locating tf feature files
    *   loading and saving feature data
    *   precomputing auxiliary data
    *   caching precomputed and compressed data
    &#34;&#34;&#34;

    def __init__(self, locations=None, modules=None, silent=False):
        self.silent = silent
        self.tm = Timestamp()
        self.tm.setSilent(silent)
        self.banner = f&#34;This is {NAME} {VERSION}&#34;
        self.version = VERSION
        (on32, warn, msg) = check32()
        if on32:
            self.tm.info(warn, tm=False)
        if msg:
            self.tm.info(msg, tm=False)
        self.tm.info(
            f&#34;&#34;&#34;{self.banner}
Api reference : {APIREF}
&#34;&#34;&#34;,
            tm=False,
        )
        self.good = True

        if modules is None:
            modules = [&#34;&#34;]
        if type(modules) is str:
            modules = [x.strip() for x in itemize(modules, &#34;\n&#34;)]
        self.modules = modules

        if locations is None:
            locations = LOCATIONS
        if type(locations) is str:
            locations = [x.strip() for x in itemize(locations, &#34;\n&#34;)]
        setDir(self)
        self.locations = []
        for loc in locations:
            self.locations.append(expandDir(self, loc))

        self.locationRep = &#34;\n\t&#34;.join(
            &#34;\n\t&#34;.join(f&#34;{l}/{f}&#34; for f in self.modules) for l in self.locations
        )
        self.featuresRequested = []
        self._makeIndex()

    def load(self, features, add=False, silent=None):
        if silent is not None:
            wasSilent = self.tm.isSilent()
            self.tm.setSilent(silent)
        self.tm.indent(level=0, reset=True)
        self.tm.info(&#34;loading features ...&#34;)
        self.sectionsOK = True
        self.structureOK = True
        self.good = True
        if self.good:
            featuresRequested = (
                itemize(features) if type(features) is str else sorted(features)
            )
            if add:
                self.featuresRequested += featuresRequested
            else:
                self.featuresRequested = featuresRequested
            for fName in list(WARP):
                self._loadFeature(fName, optional=fName == WARP[2])
        if self.good:
            self.textFeatures = set()
            if WARP[2] in self.features:
                otextMeta = self.features[WARP[2]].metaData
                for otextMod in self.features:
                    if otextMod.startswith(WARP[2] + &#34;@&#34;):
                        self._loadFeature(otextMod)
                        otextMeta.update(self.features[otextMod].metaData)
                self.sectionFeats = itemize(otextMeta.get(&#34;sectionFeatures&#34;, &#34;&#34;), &#34;,&#34;)
                self.sectionTypes = itemize(otextMeta.get(&#34;sectionTypes&#34;, &#34;&#34;), &#34;,&#34;)
                self.structureFeats = itemize(
                    otextMeta.get(&#34;structureFeatures&#34;, &#34;&#34;), &#34;,&#34;
                )
                self.structureTypes = itemize(otextMeta.get(&#34;structureTypes&#34;, &#34;&#34;), &#34;,&#34;)
                (self.cformats, self.formatFeats) = collectFormats(otextMeta)
                if not (0 &lt; len(self.sectionTypes) &lt;= 3) or not (
                    0 &lt; len(self.sectionFeats) &lt;= 3
                ):
                    if not add:
                        self.tm.warning(
                            f&#34;Dataset without sections in {WARP[2]}:&#34;
                            f&#34;no section functions in the T-API&#34;
                        )
                    self.sectionsOK = False
                else:
                    self.textFeatures |= set(self.sectionFeats)
                    self.sectionFeatsWithLanguage = tuple(
                        f
                        for f in self.features
                        if f == self.sectionFeats[0]
                        or f.startswith(f&#34;{self.sectionFeats[0]}@&#34;)
                    )
                    self.textFeatures |= set(self.sectionFeatsWithLanguage)
                if not self.structureTypes or not self.structureFeats:
                    if not add:
                        self.tm.warning(
                            f&#34;Dataset without structure sections in {WARP[2]}:&#34;
                            f&#34;no structure functions in the T-API&#34;
                        )
                    self.structureOK = False
                else:
                    self.textFeatures |= set(self.structureFeats)

                self.textFeatures |= set(self.formatFeats)

                for fName in self.textFeatures:
                    self._loadFeature(fName)

            else:
                self.sectionsOK = False
                self.structureOK = False

        if self.good:
            self._precompute()
        if self.good:
            for fName in self.featuresRequested:
                self._loadFeature(fName)
        if not self.good:
            self.tm.indent(level=0)
            self.tm.error(&#34;Not all features could be loaded/computed&#34;)
            self.tm.cache()
            result = False
        elif add:
            try:
                self._updateApi()
            except MemoryError:
                console(MEM_MSG)
                result = False
        else:
            try:
                result = self._makeApi()
            except MemoryError:
                console(MEM_MSG)
                result = False
        if silent is not None:
            self.tm.setSilent(wasSilent)
        if not add:
            return result

    def explore(self, silent=None, show=True):
        if silent is not None:
            wasSilent = self.tm.isSilent()
            self.tm.setSilent(silent)
        nodes = set()
        edges = set()
        configs = set()
        computeds = set()
        for (fName, fObj) in self.features.items():
            fObj.load(metaOnly=True)
            dest = None
            if fObj.method:
                dest = computeds
            elif fObj.isConfig:
                dest = configs
            elif fObj.isEdge:
                dest = edges
            else:
                dest = nodes
            dest.add(fName)
        self.tm.info(
            &#34;Feature overview: {} for nodes; {} for edges; {} configs; {} computed&#34;.format(
                len(nodes), len(edges), len(configs), len(computeds),
            )
        )
        self.featureSets = dict(
            nodes=nodes, edges=edges, configs=configs, computeds=computeds
        )
        if silent is not None:
            self.tm.setSilent(wasSilent)
        if show:
            return dict(
                (kind, tuple(sorted(kindSet)))
                for (kind, kindSet) in sorted(
                    self.featureSets.items(), key=lambda x: x[0]
                )
            )

    def loadAll(self, silent=None):
        api = self.load(&#34;&#34;, silent=silent)
        allFeatures = self.explore(silent=silent or True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        self.load(loadableFeatures, add=True, silent=silent)
        return api

    def clearCache(self):
        for (fName, fObj) in self.features.items():
            fObj.cleanDataBin()

    def save(
        self,
        nodeFeatures={},
        edgeFeatures={},
        metaData={},
        location=None,
        module=None,
        silent=None,
    ):
        good = True
        if silent is not None:
            wasSilent = self.tm.isSilent()
            self.tm.setSilent(silent)
        self.tm.indent(level=0, reset=True)
        self._getWriteLoc(location=location, module=module)
        configFeatures = dict(
            f
            for f in metaData.items()
            if f[0] != &#34;&#34; and f[0] not in nodeFeatures and f[0] not in edgeFeatures
        )
        self.tm.info(
            &#34;Exporting {} node and {} edge and {} config features to {}:&#34;.format(
                len(nodeFeatures),
                len(edgeFeatures),
                len(configFeatures),
                self.writeDir,
            )
        )
        todo = []
        for (fName, data) in sorted(nodeFeatures.items()):
            todo.append((fName, data, False, False))
        for (fName, data) in sorted(edgeFeatures.items()):
            todo.append((fName, data, True, False))
        for (fName, data) in sorted(configFeatures.items()):
            todo.append((fName, data, None, True))
        total = collections.Counter()
        failed = collections.Counter()
        maxSlot = None
        maxNode = None
        slotType = None
        if WARP[0] in nodeFeatures:
            self.tm.info(f&#34;VALIDATING {WARP[1]} feature&#34;)
            otypeData = nodeFeatures[WARP[0]]
            if type(otypeData) is tuple:
                (otypeData, slotType, maxSlot, maxNode) = otypeData
            elif 1 in otypeData:
                slotType = otypeData[1]
                maxSlot = max(n for n in otypeData if otypeData[n] == slotType)
                maxNode = max(otypeData)
        if WARP[1] in edgeFeatures:
            self.tm.info(f&#34;VALIDATING {WARP[1]} feature&#34;)
            oslotsData = edgeFeatures[WARP[1]]
            if type(oslotsData) is tuple:
                (oslotsData, maxSlot, maxNode) = oslotsData
            if maxSlot is None or maxNode is None:
                self.tm.error(f&#34;ERROR: cannot check validity of {WARP[1]} feature&#34;)
                good = False
            else:
                self.tm.info(f&#34;maxSlot={maxSlot:&gt;11}&#34;)
                self.tm.info(f&#34;maxNode={maxNode:&gt;11}&#34;)
                maxNodeInData = max(oslotsData)
                minNodeInData = min(oslotsData)

                mappedSlotNodes = []
                unmappedNodes = []
                fakeNodes = []

                start = min((maxSlot + 1, minNodeInData))
                end = max((maxNode, maxNodeInData))
                for n in range(start, end + 1):
                    if n in oslotsData:
                        if n &lt;= maxSlot:
                            mappedSlotNodes.append(n)
                        elif n &gt; maxNode:
                            fakeNodes.append(n)
                    else:
                        if maxSlot &lt; n &lt;= maxNode:
                            unmappedNodes.append(n)

                if mappedSlotNodes:
                    self.tm.error(f&#34;ERROR: {WARP[1]} maps slot nodes&#34;)
                    self.tm.error(makeExamples(mappedSlotNodes), tm=False)
                    good = False
                if fakeNodes:
                    self.tm.error(
                        f&#34;ERROR: {WARP[1]} maps nodes that are not in {WARP[0]}&#34;
                    )
                    self.tm.error(makeExamples(fakeNodes), tm=False)
                    good = False
                if unmappedNodes:
                    self.tm.error(f&#34;ERROR: {WARP[1]} fails to map nodes:&#34;)
                    unmappedByType = {}
                    for n in unmappedNodes:
                        unmappedByType.setdefault(
                            otypeData.get(n, &#34;_UNKNOWN_&#34;), []
                        ).append(n)
                    for (nType, nodes) in sorted(
                        unmappedByType.items(), key=lambda x: (-len(x[1]), x[0]),
                    ):
                        self.tm.error(
                            f&#34;--- unmapped {nType:&lt;10} : {makeExamples(nodes)}&#34;
                        )
                    good = False

            if good:
                self.tm.info(f&#34;OK: {WARP[1]} is valid&#34;)

        for (fName, data, isEdge, isConfig) in todo:
            edgeValues = False
            fMeta = {}
            fMeta.update(metaData.get(&#34;&#34;, {}))
            fMeta.update(metaData.get(fName, {}))
            if fMeta.get(&#34;edgeValues&#34;, False):
                edgeValues = True
            if &#34;edgeValues&#34; in fMeta:
                del fMeta[&#34;edgeValues&#34;]
            fObj = Data(
                f&#34;{self.writeDir}/{fName}.tf&#34;,
                self.tm,
                data=data,
                metaData=fMeta,
                isEdge=isEdge,
                isConfig=isConfig,
                edgeValues=edgeValues,
            )
            tag = &#34;config&#34; if isConfig else &#34;edge&#34; if isEdge else &#34;node&#34;
            if fObj.save(nodeRanges=fName == WARP[0], overwrite=True):
                total[tag] += 1
            else:
                failed[tag] += 1
        self.tm.indent(level=0)
        self.tm.info(
            f&#34;&#34;&#34;Exported {total[&#34;node&#34;]} node features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;edge&#34;]} edge features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;config&#34;]} config features&#34;&#34;&#34;
            f&#34;&#34;&#34; to {self.writeDir}&#34;&#34;&#34;
        )
        if len(failed):
            for (tag, nf) in sorted(failed.items()):
                self.tm.error(f&#34;Failed to export {nf} {tag} features&#34;)
            good = False

        if silent is not None:
            self.tm.setSilent(wasSilent)
        return good

    def exportMQL(self, mqlName, mqlDir):
        self.tm.indent(level=0, reset=True)
        mqlDir = expandDir(self, mqlDir)

        mqlNameClean = cleanName(mqlName)
        mql = MQL(mqlDir, mqlNameClean, self.features, self.tm)
        mql.write()

    def importMQL(self, mqlFile, slotType=None, otext=None, meta=None):
        self.tm.indent(level=0, reset=True)
        (good, nodeFeatures, edgeFeatures, metaData) = tfFromMql(
            mqlFile, self.tm, slotType=slotType, otext=otext, meta=meta
        )
        if good:
            self.save(
                nodeFeatures=nodeFeatures, edgeFeatures=edgeFeatures, metaData=metaData
            )

    def _loadFeature(self, fName, optional=False):
        if not self.good:
            return False
        silent = self.tm.isSilent()
        if fName not in self.features:
            if not optional:
                self.tm.error(f&#39;Feature &#34;{fName}&#34; not available in\n{self.locationRep}&#39;)
                self.good = False
        else:
            # if not self.features[fName].load(silent=silent or (fName not in self.featuresRequested)):
            if not self.features[fName].load(silent=silent):
                self.good = False

    def _makeIndex(self):
        self.features = {}
        self.featuresIgnored = {}
        tfFiles = {}
        for loc in self.locations:
            for mod in self.modules:
                dirF = f&#34;{loc}/{mod}&#34;
                if not os.path.exists(dirF):
                    continue
                with os.scandir(dirF) as sd:
                    files = tuple(
                        e.name for e in sd if e.is_file() and e.name.endswith(&#34;.tf&#34;)
                    )
                for fileF in files:
                    (fName, ext) = os.path.splitext(fileF)
                    tfFiles.setdefault(fName, []).append(f&#34;{dirF}/{fileF}&#34;)
        for (fName, featurePaths) in sorted(tfFiles.items()):
            chosenFPath = featurePaths[-1]
            for featurePath in sorted(set(featurePaths[0:-1])):
                if featurePath != chosenFPath:
                    self.featuresIgnored.setdefault(fName, []).append(featurePath)
            self.features[fName] = Data(chosenFPath, self.tm)
        self._getWriteLoc()
        self.tm.info(
            &#34;{} features found and {} ignored&#34;.format(
                len(tfFiles), sum(len(x) for x in self.featuresIgnored.values()),
            ),
            tm=False,
        )

        good = True
        for fName in WARP:
            if fName not in self.features:
                if fName == WARP[2]:
                    self.tm.info(
                        (
                            f&#39;Warp feature &#34;{WARP[2]}&#34; not found. Working without Text-API\n&#39;
                        )
                    )
                    self.features[WARP[2]] = Data(
                        f&#34;{WARP[2]}.tf&#34;, self.tm, isConfig=True, metaData=WARP2_DEFAULT,
                    )
                    self.features[WARP[2]].dataLoaded = True
                else:
                    self.tm.info(
                        f&#39;Warp feature &#34;{fName}&#34; not found in\n{self.locationRep}&#39;
                    )
                    good = False
            elif fName == WARP[2]:
                self._loadFeature(fName, optional=True)
        if not good:
            return False
        self.warpDir = self.features[WARP[0]].dirName
        self.precomputeList = []
        for (dep2, fName, method, dependencies) in PRECOMPUTE:
            thisGood = True
            if dep2 and WARP[2] not in self.features:
                continue
            if dep2:
                otextMeta = self.features[WARP[2]].metaData
                sFeatures = f&#34;{KIND[fName]}Features&#34;
                sFeats = tuple(itemize(otextMeta.get(sFeatures, &#34;&#34;), &#34;,&#34;))
                dependencies = dependencies + sFeats
            for dep in dependencies:
                if dep not in self.features:
                    self.tm.info(
                        f&#39;Missing dependency for computed data feature &#34;{fName}&#34;: &#34;{dep}&#34;&#39;
                    )
                    thisGood = False
            if not thisGood:
                good = False
            self.features[fName] = Data(
                f&#34;{self.warpDir}/{fName}.x&#34;,
                self.tm,
                method=method,
                dependencies=[self.features.get(dep, None) for dep in dependencies],
            )
            self.precomputeList.append((fName, dep2))
        self.good = good

    def _getWriteLoc(self, location=None, module=None):
        writeLoc = (
            os.path.expanduser(location)
            if location is not None
            else &#34;&#34;
            if len(self.locations) == 0
            else self.locations[-1]
        )
        writeMod = (
            module
            if module is not None
            else &#34;&#34;
            if len(self.modules) == 0
            else self.modules[-1]
        )
        self.writeDir = (
            f&#34;{writeLoc}{writeMod}&#34;
            if writeLoc == &#34;&#34; or writeMod == &#34;&#34;
            else f&#34;{writeLoc}/{writeMod}&#34;
        )

    def _precompute(self):
        good = True
        for (fName, dep2) in self.precomputeList:
            ok = getattr(self, f&#39;{fName.strip(&#34;_&#34;)}OK&#39;, False)
            if dep2 and not ok:
                continue
            if not self.features[fName].load():
                good = False
                break
        self.good = good

    def _makeApi(self):
        if not self.good:
            return None

        silent = self.tm.isSilent()
        api = Api(self)

        w0info = self.features[WARP[0]]
        w1info = self.features[WARP[1]]

        setattr(api.F, WARP[0], OtypeFeature(api, w0info.metaData, w0info.data))
        setattr(api.E, WARP[1], OslotsFeature(api, w1info.metaData, w1info.data))

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if fObj.method:
                    feat = fName.strip(&#34;_&#34;)
                    ok = getattr(self, f&#34;{feat}OK&#34;, False)
                    ap = api.C
                    if fName in [x[0] for x in self.precomputeList if not x[1] or ok]:
                        setattr(ap, feat, Computed(api, fObj.data))
                    else:
                        fObj.unload()
                        if hasattr(ap, feat):
                            delattr(api.C, feat)
                else:
                    if fName in requestedSet | self.textFeatures:
                        if fName in WARP:
                            continue
                        elif fObj.isEdge:
                            setattr(
                                api.E,
                                fName,
                                EdgeFeature(
                                    api, fObj.metaData, fObj.data, fObj.edgeValues
                                ),
                            )
                        else:
                            setattr(
                                api.F, fName, NodeFeature(api, fObj.metaData, fObj.data)
                            )
                    else:
                        if fName in WARP or fName in self.textFeatures:
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        addSortKey(api)
        addOtype(api)
        addLocality(api)
        addRank(api)
        addText(api)
        addSearch(api, silent)
        self.tm.indent(level=0)
        self.tm.info(&#34;All features loaded/computed - for details use loadLog()&#34;)
        self.api = api
        return api

    def _updateApi(self):
        if not self.good:
            return None
        api = self.api

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if not fObj.method:
                    if fName in requestedSet | self.textFeatures:
                        if fName in WARP:
                            continue
                        elif fObj.isEdge:
                            if not hasattr(api.E, fName):
                                setattr(
                                    api.E,
                                    fName,
                                    EdgeFeature(
                                        api, fObj.metaData, fObj.data, fObj.edgeValues
                                    ),
                                )
                        else:
                            if not hasattr(api.F, fName):
                                setattr(
                                    api.F,
                                    fName,
                                    NodeFeature(api, fObj.metaData, fObj.data),
                                )
                    else:
                        if fName in WARP or fName in self.textFeatures:
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        self.tm.indent(level=0)
        self.tm.info(&#34;All additional features loaded - for details use loadLog()&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="tf.fabric.PRECOMPUTE"><code class="name">var <span class="ident">PRECOMPUTE</span></code></dt>
<dd>
<div class="desc"><p>Precomputation steps.</p>
<p>Each step corresponds to a precomputation task.</p>
<p>A task is specified by a tuple containing:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dep</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the step is dependent on the presence of additional features.
Only relevant for the precomputation of section structure:
that should only happen if there are section features.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the result of a precomputed task.
The result is a blob of data that can be loaded and compressed just as ordinary features.</dd>
<dt><strong><code>function</code></strong> :&ensp;<code>function</code></dt>
<dd>The function that performs the precomputation task.
These functions are defined in <code><a title="tf.core.prepare" href="core/prepare.html">tf.core.prepare</a></code>.</dd>
<dt><strong><code>dependencies</code></strong> :&ensp;<code>strings</code></dt>
<dd>The remaining parts of the tuple are the names of precomputed features
that must be coomputed before and whose results are passed as argument
to the function that executes the precomputation.</dd>
</dl>
<p>For a description of what the steps are for, see the functions
in <code><a title="tf.core.prepare" href="core/prepare.html">tf.core.prepare</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.fabric.Fabric"><code class="flex name class">
<span>class <span class="ident">Fabric</span></span>
<span>(</span><span>locations=None, modules=None, silent=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class of the TF package.</p>
<p>Top level management of</p>
<ul>
<li>locating tf feature files</li>
<li>loading and saving feature data</li>
<li>precomputing auxiliary data</li>
<li>caching precomputed and compressed data</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fabric(object):
    &#34;&#34;&#34;Main class of the TF package.

    Top level management of

    *   locating tf feature files
    *   loading and saving feature data
    *   precomputing auxiliary data
    *   caching precomputed and compressed data
    &#34;&#34;&#34;

    def __init__(self, locations=None, modules=None, silent=False):
        self.silent = silent
        self.tm = Timestamp()
        self.tm.setSilent(silent)
        self.banner = f&#34;This is {NAME} {VERSION}&#34;
        self.version = VERSION
        (on32, warn, msg) = check32()
        if on32:
            self.tm.info(warn, tm=False)
        if msg:
            self.tm.info(msg, tm=False)
        self.tm.info(
            f&#34;&#34;&#34;{self.banner}
Api reference : {APIREF}
&#34;&#34;&#34;,
            tm=False,
        )
        self.good = True

        if modules is None:
            modules = [&#34;&#34;]
        if type(modules) is str:
            modules = [x.strip() for x in itemize(modules, &#34;\n&#34;)]
        self.modules = modules

        if locations is None:
            locations = LOCATIONS
        if type(locations) is str:
            locations = [x.strip() for x in itemize(locations, &#34;\n&#34;)]
        setDir(self)
        self.locations = []
        for loc in locations:
            self.locations.append(expandDir(self, loc))

        self.locationRep = &#34;\n\t&#34;.join(
            &#34;\n\t&#34;.join(f&#34;{l}/{f}&#34; for f in self.modules) for l in self.locations
        )
        self.featuresRequested = []
        self._makeIndex()

    def load(self, features, add=False, silent=None):
        if silent is not None:
            wasSilent = self.tm.isSilent()
            self.tm.setSilent(silent)
        self.tm.indent(level=0, reset=True)
        self.tm.info(&#34;loading features ...&#34;)
        self.sectionsOK = True
        self.structureOK = True
        self.good = True
        if self.good:
            featuresRequested = (
                itemize(features) if type(features) is str else sorted(features)
            )
            if add:
                self.featuresRequested += featuresRequested
            else:
                self.featuresRequested = featuresRequested
            for fName in list(WARP):
                self._loadFeature(fName, optional=fName == WARP[2])
        if self.good:
            self.textFeatures = set()
            if WARP[2] in self.features:
                otextMeta = self.features[WARP[2]].metaData
                for otextMod in self.features:
                    if otextMod.startswith(WARP[2] + &#34;@&#34;):
                        self._loadFeature(otextMod)
                        otextMeta.update(self.features[otextMod].metaData)
                self.sectionFeats = itemize(otextMeta.get(&#34;sectionFeatures&#34;, &#34;&#34;), &#34;,&#34;)
                self.sectionTypes = itemize(otextMeta.get(&#34;sectionTypes&#34;, &#34;&#34;), &#34;,&#34;)
                self.structureFeats = itemize(
                    otextMeta.get(&#34;structureFeatures&#34;, &#34;&#34;), &#34;,&#34;
                )
                self.structureTypes = itemize(otextMeta.get(&#34;structureTypes&#34;, &#34;&#34;), &#34;,&#34;)
                (self.cformats, self.formatFeats) = collectFormats(otextMeta)
                if not (0 &lt; len(self.sectionTypes) &lt;= 3) or not (
                    0 &lt; len(self.sectionFeats) &lt;= 3
                ):
                    if not add:
                        self.tm.warning(
                            f&#34;Dataset without sections in {WARP[2]}:&#34;
                            f&#34;no section functions in the T-API&#34;
                        )
                    self.sectionsOK = False
                else:
                    self.textFeatures |= set(self.sectionFeats)
                    self.sectionFeatsWithLanguage = tuple(
                        f
                        for f in self.features
                        if f == self.sectionFeats[0]
                        or f.startswith(f&#34;{self.sectionFeats[0]}@&#34;)
                    )
                    self.textFeatures |= set(self.sectionFeatsWithLanguage)
                if not self.structureTypes or not self.structureFeats:
                    if not add:
                        self.tm.warning(
                            f&#34;Dataset without structure sections in {WARP[2]}:&#34;
                            f&#34;no structure functions in the T-API&#34;
                        )
                    self.structureOK = False
                else:
                    self.textFeatures |= set(self.structureFeats)

                self.textFeatures |= set(self.formatFeats)

                for fName in self.textFeatures:
                    self._loadFeature(fName)

            else:
                self.sectionsOK = False
                self.structureOK = False

        if self.good:
            self._precompute()
        if self.good:
            for fName in self.featuresRequested:
                self._loadFeature(fName)
        if not self.good:
            self.tm.indent(level=0)
            self.tm.error(&#34;Not all features could be loaded/computed&#34;)
            self.tm.cache()
            result = False
        elif add:
            try:
                self._updateApi()
            except MemoryError:
                console(MEM_MSG)
                result = False
        else:
            try:
                result = self._makeApi()
            except MemoryError:
                console(MEM_MSG)
                result = False
        if silent is not None:
            self.tm.setSilent(wasSilent)
        if not add:
            return result

    def explore(self, silent=None, show=True):
        if silent is not None:
            wasSilent = self.tm.isSilent()
            self.tm.setSilent(silent)
        nodes = set()
        edges = set()
        configs = set()
        computeds = set()
        for (fName, fObj) in self.features.items():
            fObj.load(metaOnly=True)
            dest = None
            if fObj.method:
                dest = computeds
            elif fObj.isConfig:
                dest = configs
            elif fObj.isEdge:
                dest = edges
            else:
                dest = nodes
            dest.add(fName)
        self.tm.info(
            &#34;Feature overview: {} for nodes; {} for edges; {} configs; {} computed&#34;.format(
                len(nodes), len(edges), len(configs), len(computeds),
            )
        )
        self.featureSets = dict(
            nodes=nodes, edges=edges, configs=configs, computeds=computeds
        )
        if silent is not None:
            self.tm.setSilent(wasSilent)
        if show:
            return dict(
                (kind, tuple(sorted(kindSet)))
                for (kind, kindSet) in sorted(
                    self.featureSets.items(), key=lambda x: x[0]
                )
            )

    def loadAll(self, silent=None):
        api = self.load(&#34;&#34;, silent=silent)
        allFeatures = self.explore(silent=silent or True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        self.load(loadableFeatures, add=True, silent=silent)
        return api

    def clearCache(self):
        for (fName, fObj) in self.features.items():
            fObj.cleanDataBin()

    def save(
        self,
        nodeFeatures={},
        edgeFeatures={},
        metaData={},
        location=None,
        module=None,
        silent=None,
    ):
        good = True
        if silent is not None:
            wasSilent = self.tm.isSilent()
            self.tm.setSilent(silent)
        self.tm.indent(level=0, reset=True)
        self._getWriteLoc(location=location, module=module)
        configFeatures = dict(
            f
            for f in metaData.items()
            if f[0] != &#34;&#34; and f[0] not in nodeFeatures and f[0] not in edgeFeatures
        )
        self.tm.info(
            &#34;Exporting {} node and {} edge and {} config features to {}:&#34;.format(
                len(nodeFeatures),
                len(edgeFeatures),
                len(configFeatures),
                self.writeDir,
            )
        )
        todo = []
        for (fName, data) in sorted(nodeFeatures.items()):
            todo.append((fName, data, False, False))
        for (fName, data) in sorted(edgeFeatures.items()):
            todo.append((fName, data, True, False))
        for (fName, data) in sorted(configFeatures.items()):
            todo.append((fName, data, None, True))
        total = collections.Counter()
        failed = collections.Counter()
        maxSlot = None
        maxNode = None
        slotType = None
        if WARP[0] in nodeFeatures:
            self.tm.info(f&#34;VALIDATING {WARP[1]} feature&#34;)
            otypeData = nodeFeatures[WARP[0]]
            if type(otypeData) is tuple:
                (otypeData, slotType, maxSlot, maxNode) = otypeData
            elif 1 in otypeData:
                slotType = otypeData[1]
                maxSlot = max(n for n in otypeData if otypeData[n] == slotType)
                maxNode = max(otypeData)
        if WARP[1] in edgeFeatures:
            self.tm.info(f&#34;VALIDATING {WARP[1]} feature&#34;)
            oslotsData = edgeFeatures[WARP[1]]
            if type(oslotsData) is tuple:
                (oslotsData, maxSlot, maxNode) = oslotsData
            if maxSlot is None or maxNode is None:
                self.tm.error(f&#34;ERROR: cannot check validity of {WARP[1]} feature&#34;)
                good = False
            else:
                self.tm.info(f&#34;maxSlot={maxSlot:&gt;11}&#34;)
                self.tm.info(f&#34;maxNode={maxNode:&gt;11}&#34;)
                maxNodeInData = max(oslotsData)
                minNodeInData = min(oslotsData)

                mappedSlotNodes = []
                unmappedNodes = []
                fakeNodes = []

                start = min((maxSlot + 1, minNodeInData))
                end = max((maxNode, maxNodeInData))
                for n in range(start, end + 1):
                    if n in oslotsData:
                        if n &lt;= maxSlot:
                            mappedSlotNodes.append(n)
                        elif n &gt; maxNode:
                            fakeNodes.append(n)
                    else:
                        if maxSlot &lt; n &lt;= maxNode:
                            unmappedNodes.append(n)

                if mappedSlotNodes:
                    self.tm.error(f&#34;ERROR: {WARP[1]} maps slot nodes&#34;)
                    self.tm.error(makeExamples(mappedSlotNodes), tm=False)
                    good = False
                if fakeNodes:
                    self.tm.error(
                        f&#34;ERROR: {WARP[1]} maps nodes that are not in {WARP[0]}&#34;
                    )
                    self.tm.error(makeExamples(fakeNodes), tm=False)
                    good = False
                if unmappedNodes:
                    self.tm.error(f&#34;ERROR: {WARP[1]} fails to map nodes:&#34;)
                    unmappedByType = {}
                    for n in unmappedNodes:
                        unmappedByType.setdefault(
                            otypeData.get(n, &#34;_UNKNOWN_&#34;), []
                        ).append(n)
                    for (nType, nodes) in sorted(
                        unmappedByType.items(), key=lambda x: (-len(x[1]), x[0]),
                    ):
                        self.tm.error(
                            f&#34;--- unmapped {nType:&lt;10} : {makeExamples(nodes)}&#34;
                        )
                    good = False

            if good:
                self.tm.info(f&#34;OK: {WARP[1]} is valid&#34;)

        for (fName, data, isEdge, isConfig) in todo:
            edgeValues = False
            fMeta = {}
            fMeta.update(metaData.get(&#34;&#34;, {}))
            fMeta.update(metaData.get(fName, {}))
            if fMeta.get(&#34;edgeValues&#34;, False):
                edgeValues = True
            if &#34;edgeValues&#34; in fMeta:
                del fMeta[&#34;edgeValues&#34;]
            fObj = Data(
                f&#34;{self.writeDir}/{fName}.tf&#34;,
                self.tm,
                data=data,
                metaData=fMeta,
                isEdge=isEdge,
                isConfig=isConfig,
                edgeValues=edgeValues,
            )
            tag = &#34;config&#34; if isConfig else &#34;edge&#34; if isEdge else &#34;node&#34;
            if fObj.save(nodeRanges=fName == WARP[0], overwrite=True):
                total[tag] += 1
            else:
                failed[tag] += 1
        self.tm.indent(level=0)
        self.tm.info(
            f&#34;&#34;&#34;Exported {total[&#34;node&#34;]} node features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;edge&#34;]} edge features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;config&#34;]} config features&#34;&#34;&#34;
            f&#34;&#34;&#34; to {self.writeDir}&#34;&#34;&#34;
        )
        if len(failed):
            for (tag, nf) in sorted(failed.items()):
                self.tm.error(f&#34;Failed to export {nf} {tag} features&#34;)
            good = False

        if silent is not None:
            self.tm.setSilent(wasSilent)
        return good

    def exportMQL(self, mqlName, mqlDir):
        self.tm.indent(level=0, reset=True)
        mqlDir = expandDir(self, mqlDir)

        mqlNameClean = cleanName(mqlName)
        mql = MQL(mqlDir, mqlNameClean, self.features, self.tm)
        mql.write()

    def importMQL(self, mqlFile, slotType=None, otext=None, meta=None):
        self.tm.indent(level=0, reset=True)
        (good, nodeFeatures, edgeFeatures, metaData) = tfFromMql(
            mqlFile, self.tm, slotType=slotType, otext=otext, meta=meta
        )
        if good:
            self.save(
                nodeFeatures=nodeFeatures, edgeFeatures=edgeFeatures, metaData=metaData
            )

    def _loadFeature(self, fName, optional=False):
        if not self.good:
            return False
        silent = self.tm.isSilent()
        if fName not in self.features:
            if not optional:
                self.tm.error(f&#39;Feature &#34;{fName}&#34; not available in\n{self.locationRep}&#39;)
                self.good = False
        else:
            # if not self.features[fName].load(silent=silent or (fName not in self.featuresRequested)):
            if not self.features[fName].load(silent=silent):
                self.good = False

    def _makeIndex(self):
        self.features = {}
        self.featuresIgnored = {}
        tfFiles = {}
        for loc in self.locations:
            for mod in self.modules:
                dirF = f&#34;{loc}/{mod}&#34;
                if not os.path.exists(dirF):
                    continue
                with os.scandir(dirF) as sd:
                    files = tuple(
                        e.name for e in sd if e.is_file() and e.name.endswith(&#34;.tf&#34;)
                    )
                for fileF in files:
                    (fName, ext) = os.path.splitext(fileF)
                    tfFiles.setdefault(fName, []).append(f&#34;{dirF}/{fileF}&#34;)
        for (fName, featurePaths) in sorted(tfFiles.items()):
            chosenFPath = featurePaths[-1]
            for featurePath in sorted(set(featurePaths[0:-1])):
                if featurePath != chosenFPath:
                    self.featuresIgnored.setdefault(fName, []).append(featurePath)
            self.features[fName] = Data(chosenFPath, self.tm)
        self._getWriteLoc()
        self.tm.info(
            &#34;{} features found and {} ignored&#34;.format(
                len(tfFiles), sum(len(x) for x in self.featuresIgnored.values()),
            ),
            tm=False,
        )

        good = True
        for fName in WARP:
            if fName not in self.features:
                if fName == WARP[2]:
                    self.tm.info(
                        (
                            f&#39;Warp feature &#34;{WARP[2]}&#34; not found. Working without Text-API\n&#39;
                        )
                    )
                    self.features[WARP[2]] = Data(
                        f&#34;{WARP[2]}.tf&#34;, self.tm, isConfig=True, metaData=WARP2_DEFAULT,
                    )
                    self.features[WARP[2]].dataLoaded = True
                else:
                    self.tm.info(
                        f&#39;Warp feature &#34;{fName}&#34; not found in\n{self.locationRep}&#39;
                    )
                    good = False
            elif fName == WARP[2]:
                self._loadFeature(fName, optional=True)
        if not good:
            return False
        self.warpDir = self.features[WARP[0]].dirName
        self.precomputeList = []
        for (dep2, fName, method, dependencies) in PRECOMPUTE:
            thisGood = True
            if dep2 and WARP[2] not in self.features:
                continue
            if dep2:
                otextMeta = self.features[WARP[2]].metaData
                sFeatures = f&#34;{KIND[fName]}Features&#34;
                sFeats = tuple(itemize(otextMeta.get(sFeatures, &#34;&#34;), &#34;,&#34;))
                dependencies = dependencies + sFeats
            for dep in dependencies:
                if dep not in self.features:
                    self.tm.info(
                        f&#39;Missing dependency for computed data feature &#34;{fName}&#34;: &#34;{dep}&#34;&#39;
                    )
                    thisGood = False
            if not thisGood:
                good = False
            self.features[fName] = Data(
                f&#34;{self.warpDir}/{fName}.x&#34;,
                self.tm,
                method=method,
                dependencies=[self.features.get(dep, None) for dep in dependencies],
            )
            self.precomputeList.append((fName, dep2))
        self.good = good

    def _getWriteLoc(self, location=None, module=None):
        writeLoc = (
            os.path.expanduser(location)
            if location is not None
            else &#34;&#34;
            if len(self.locations) == 0
            else self.locations[-1]
        )
        writeMod = (
            module
            if module is not None
            else &#34;&#34;
            if len(self.modules) == 0
            else self.modules[-1]
        )
        self.writeDir = (
            f&#34;{writeLoc}{writeMod}&#34;
            if writeLoc == &#34;&#34; or writeMod == &#34;&#34;
            else f&#34;{writeLoc}/{writeMod}&#34;
        )

    def _precompute(self):
        good = True
        for (fName, dep2) in self.precomputeList:
            ok = getattr(self, f&#39;{fName.strip(&#34;_&#34;)}OK&#39;, False)
            if dep2 and not ok:
                continue
            if not self.features[fName].load():
                good = False
                break
        self.good = good

    def _makeApi(self):
        if not self.good:
            return None

        silent = self.tm.isSilent()
        api = Api(self)

        w0info = self.features[WARP[0]]
        w1info = self.features[WARP[1]]

        setattr(api.F, WARP[0], OtypeFeature(api, w0info.metaData, w0info.data))
        setattr(api.E, WARP[1], OslotsFeature(api, w1info.metaData, w1info.data))

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if fObj.method:
                    feat = fName.strip(&#34;_&#34;)
                    ok = getattr(self, f&#34;{feat}OK&#34;, False)
                    ap = api.C
                    if fName in [x[0] for x in self.precomputeList if not x[1] or ok]:
                        setattr(ap, feat, Computed(api, fObj.data))
                    else:
                        fObj.unload()
                        if hasattr(ap, feat):
                            delattr(api.C, feat)
                else:
                    if fName in requestedSet | self.textFeatures:
                        if fName in WARP:
                            continue
                        elif fObj.isEdge:
                            setattr(
                                api.E,
                                fName,
                                EdgeFeature(
                                    api, fObj.metaData, fObj.data, fObj.edgeValues
                                ),
                            )
                        else:
                            setattr(
                                api.F, fName, NodeFeature(api, fObj.metaData, fObj.data)
                            )
                    else:
                        if fName in WARP or fName in self.textFeatures:
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        addSortKey(api)
        addOtype(api)
        addLocality(api)
        addRank(api)
        addText(api)
        addSearch(api, silent)
        self.tm.indent(level=0)
        self.tm.info(&#34;All features loaded/computed - for details use loadLog()&#34;)
        self.api = api
        return api

    def _updateApi(self):
        if not self.good:
            return None
        api = self.api

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if not fObj.method:
                    if fName in requestedSet | self.textFeatures:
                        if fName in WARP:
                            continue
                        elif fObj.isEdge:
                            if not hasattr(api.E, fName):
                                setattr(
                                    api.E,
                                    fName,
                                    EdgeFeature(
                                        api, fObj.metaData, fObj.data, fObj.edgeValues
                                    ),
                                )
                        else:
                            if not hasattr(api.F, fName):
                                setattr(
                                    api.F,
                                    fName,
                                    NodeFeature(api, fObj.metaData, fObj.data),
                                )
                    else:
                        if fName in WARP or fName in self.textFeatures:
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        self.tm.indent(level=0)
        self.tm.info(&#34;All additional features loaded - for details use loadLog()&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.fabric.Fabric.clearCache"><code class="name flex">
<span>def <span class="ident">clearCache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearCache(self):
    for (fName, fObj) in self.features.items():
        fObj.cleanDataBin()</code></pre>
</details>
</dd>
<dt id="tf.fabric.Fabric.explore"><code class="name flex">
<span>def <span class="ident">explore</span></span>(<span>self, silent=None, show=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explore(self, silent=None, show=True):
    if silent is not None:
        wasSilent = self.tm.isSilent()
        self.tm.setSilent(silent)
    nodes = set()
    edges = set()
    configs = set()
    computeds = set()
    for (fName, fObj) in self.features.items():
        fObj.load(metaOnly=True)
        dest = None
        if fObj.method:
            dest = computeds
        elif fObj.isConfig:
            dest = configs
        elif fObj.isEdge:
            dest = edges
        else:
            dest = nodes
        dest.add(fName)
    self.tm.info(
        &#34;Feature overview: {} for nodes; {} for edges; {} configs; {} computed&#34;.format(
            len(nodes), len(edges), len(configs), len(computeds),
        )
    )
    self.featureSets = dict(
        nodes=nodes, edges=edges, configs=configs, computeds=computeds
    )
    if silent is not None:
        self.tm.setSilent(wasSilent)
    if show:
        return dict(
            (kind, tuple(sorted(kindSet)))
            for (kind, kindSet) in sorted(
                self.featureSets.items(), key=lambda x: x[0]
            )
        )</code></pre>
</details>
</dd>
<dt id="tf.fabric.Fabric.exportMQL"><code class="name flex">
<span>def <span class="ident">exportMQL</span></span>(<span>self, mqlName, mqlDir)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exportMQL(self, mqlName, mqlDir):
    self.tm.indent(level=0, reset=True)
    mqlDir = expandDir(self, mqlDir)

    mqlNameClean = cleanName(mqlName)
    mql = MQL(mqlDir, mqlNameClean, self.features, self.tm)
    mql.write()</code></pre>
</details>
</dd>
<dt id="tf.fabric.Fabric.importMQL"><code class="name flex">
<span>def <span class="ident">importMQL</span></span>(<span>self, mqlFile, slotType=None, otext=None, meta=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importMQL(self, mqlFile, slotType=None, otext=None, meta=None):
    self.tm.indent(level=0, reset=True)
    (good, nodeFeatures, edgeFeatures, metaData) = tfFromMql(
        mqlFile, self.tm, slotType=slotType, otext=otext, meta=meta
    )
    if good:
        self.save(
            nodeFeatures=nodeFeatures, edgeFeatures=edgeFeatures, metaData=metaData
        )</code></pre>
</details>
</dd>
<dt id="tf.fabric.Fabric.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, features, add=False, silent=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, features, add=False, silent=None):
    if silent is not None:
        wasSilent = self.tm.isSilent()
        self.tm.setSilent(silent)
    self.tm.indent(level=0, reset=True)
    self.tm.info(&#34;loading features ...&#34;)
    self.sectionsOK = True
    self.structureOK = True
    self.good = True
    if self.good:
        featuresRequested = (
            itemize(features) if type(features) is str else sorted(features)
        )
        if add:
            self.featuresRequested += featuresRequested
        else:
            self.featuresRequested = featuresRequested
        for fName in list(WARP):
            self._loadFeature(fName, optional=fName == WARP[2])
    if self.good:
        self.textFeatures = set()
        if WARP[2] in self.features:
            otextMeta = self.features[WARP[2]].metaData
            for otextMod in self.features:
                if otextMod.startswith(WARP[2] + &#34;@&#34;):
                    self._loadFeature(otextMod)
                    otextMeta.update(self.features[otextMod].metaData)
            self.sectionFeats = itemize(otextMeta.get(&#34;sectionFeatures&#34;, &#34;&#34;), &#34;,&#34;)
            self.sectionTypes = itemize(otextMeta.get(&#34;sectionTypes&#34;, &#34;&#34;), &#34;,&#34;)
            self.structureFeats = itemize(
                otextMeta.get(&#34;structureFeatures&#34;, &#34;&#34;), &#34;,&#34;
            )
            self.structureTypes = itemize(otextMeta.get(&#34;structureTypes&#34;, &#34;&#34;), &#34;,&#34;)
            (self.cformats, self.formatFeats) = collectFormats(otextMeta)
            if not (0 &lt; len(self.sectionTypes) &lt;= 3) or not (
                0 &lt; len(self.sectionFeats) &lt;= 3
            ):
                if not add:
                    self.tm.warning(
                        f&#34;Dataset without sections in {WARP[2]}:&#34;
                        f&#34;no section functions in the T-API&#34;
                    )
                self.sectionsOK = False
            else:
                self.textFeatures |= set(self.sectionFeats)
                self.sectionFeatsWithLanguage = tuple(
                    f
                    for f in self.features
                    if f == self.sectionFeats[0]
                    or f.startswith(f&#34;{self.sectionFeats[0]}@&#34;)
                )
                self.textFeatures |= set(self.sectionFeatsWithLanguage)
            if not self.structureTypes or not self.structureFeats:
                if not add:
                    self.tm.warning(
                        f&#34;Dataset without structure sections in {WARP[2]}:&#34;
                        f&#34;no structure functions in the T-API&#34;
                    )
                self.structureOK = False
            else:
                self.textFeatures |= set(self.structureFeats)

            self.textFeatures |= set(self.formatFeats)

            for fName in self.textFeatures:
                self._loadFeature(fName)

        else:
            self.sectionsOK = False
            self.structureOK = False

    if self.good:
        self._precompute()
    if self.good:
        for fName in self.featuresRequested:
            self._loadFeature(fName)
    if not self.good:
        self.tm.indent(level=0)
        self.tm.error(&#34;Not all features could be loaded/computed&#34;)
        self.tm.cache()
        result = False
    elif add:
        try:
            self._updateApi()
        except MemoryError:
            console(MEM_MSG)
            result = False
    else:
        try:
            result = self._makeApi()
        except MemoryError:
            console(MEM_MSG)
            result = False
    if silent is not None:
        self.tm.setSilent(wasSilent)
    if not add:
        return result</code></pre>
</details>
</dd>
<dt id="tf.fabric.Fabric.loadAll"><code class="name flex">
<span>def <span class="ident">loadAll</span></span>(<span>self, silent=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadAll(self, silent=None):
    api = self.load(&#34;&#34;, silent=silent)
    allFeatures = self.explore(silent=silent or True, show=True)
    loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
    self.load(loadableFeatures, add=True, silent=silent)
    return api</code></pre>
</details>
</dd>
<dt id="tf.fabric.Fabric.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, nodeFeatures={}, edgeFeatures={}, metaData={}, location=None, module=None, silent=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(
    self,
    nodeFeatures={},
    edgeFeatures={},
    metaData={},
    location=None,
    module=None,
    silent=None,
):
    good = True
    if silent is not None:
        wasSilent = self.tm.isSilent()
        self.tm.setSilent(silent)
    self.tm.indent(level=0, reset=True)
    self._getWriteLoc(location=location, module=module)
    configFeatures = dict(
        f
        for f in metaData.items()
        if f[0] != &#34;&#34; and f[0] not in nodeFeatures and f[0] not in edgeFeatures
    )
    self.tm.info(
        &#34;Exporting {} node and {} edge and {} config features to {}:&#34;.format(
            len(nodeFeatures),
            len(edgeFeatures),
            len(configFeatures),
            self.writeDir,
        )
    )
    todo = []
    for (fName, data) in sorted(nodeFeatures.items()):
        todo.append((fName, data, False, False))
    for (fName, data) in sorted(edgeFeatures.items()):
        todo.append((fName, data, True, False))
    for (fName, data) in sorted(configFeatures.items()):
        todo.append((fName, data, None, True))
    total = collections.Counter()
    failed = collections.Counter()
    maxSlot = None
    maxNode = None
    slotType = None
    if WARP[0] in nodeFeatures:
        self.tm.info(f&#34;VALIDATING {WARP[1]} feature&#34;)
        otypeData = nodeFeatures[WARP[0]]
        if type(otypeData) is tuple:
            (otypeData, slotType, maxSlot, maxNode) = otypeData
        elif 1 in otypeData:
            slotType = otypeData[1]
            maxSlot = max(n for n in otypeData if otypeData[n] == slotType)
            maxNode = max(otypeData)
    if WARP[1] in edgeFeatures:
        self.tm.info(f&#34;VALIDATING {WARP[1]} feature&#34;)
        oslotsData = edgeFeatures[WARP[1]]
        if type(oslotsData) is tuple:
            (oslotsData, maxSlot, maxNode) = oslotsData
        if maxSlot is None or maxNode is None:
            self.tm.error(f&#34;ERROR: cannot check validity of {WARP[1]} feature&#34;)
            good = False
        else:
            self.tm.info(f&#34;maxSlot={maxSlot:&gt;11}&#34;)
            self.tm.info(f&#34;maxNode={maxNode:&gt;11}&#34;)
            maxNodeInData = max(oslotsData)
            minNodeInData = min(oslotsData)

            mappedSlotNodes = []
            unmappedNodes = []
            fakeNodes = []

            start = min((maxSlot + 1, minNodeInData))
            end = max((maxNode, maxNodeInData))
            for n in range(start, end + 1):
                if n in oslotsData:
                    if n &lt;= maxSlot:
                        mappedSlotNodes.append(n)
                    elif n &gt; maxNode:
                        fakeNodes.append(n)
                else:
                    if maxSlot &lt; n &lt;= maxNode:
                        unmappedNodes.append(n)

            if mappedSlotNodes:
                self.tm.error(f&#34;ERROR: {WARP[1]} maps slot nodes&#34;)
                self.tm.error(makeExamples(mappedSlotNodes), tm=False)
                good = False
            if fakeNodes:
                self.tm.error(
                    f&#34;ERROR: {WARP[1]} maps nodes that are not in {WARP[0]}&#34;
                )
                self.tm.error(makeExamples(fakeNodes), tm=False)
                good = False
            if unmappedNodes:
                self.tm.error(f&#34;ERROR: {WARP[1]} fails to map nodes:&#34;)
                unmappedByType = {}
                for n in unmappedNodes:
                    unmappedByType.setdefault(
                        otypeData.get(n, &#34;_UNKNOWN_&#34;), []
                    ).append(n)
                for (nType, nodes) in sorted(
                    unmappedByType.items(), key=lambda x: (-len(x[1]), x[0]),
                ):
                    self.tm.error(
                        f&#34;--- unmapped {nType:&lt;10} : {makeExamples(nodes)}&#34;
                    )
                good = False

        if good:
            self.tm.info(f&#34;OK: {WARP[1]} is valid&#34;)

    for (fName, data, isEdge, isConfig) in todo:
        edgeValues = False
        fMeta = {}
        fMeta.update(metaData.get(&#34;&#34;, {}))
        fMeta.update(metaData.get(fName, {}))
        if fMeta.get(&#34;edgeValues&#34;, False):
            edgeValues = True
        if &#34;edgeValues&#34; in fMeta:
            del fMeta[&#34;edgeValues&#34;]
        fObj = Data(
            f&#34;{self.writeDir}/{fName}.tf&#34;,
            self.tm,
            data=data,
            metaData=fMeta,
            isEdge=isEdge,
            isConfig=isConfig,
            edgeValues=edgeValues,
        )
        tag = &#34;config&#34; if isConfig else &#34;edge&#34; if isEdge else &#34;node&#34;
        if fObj.save(nodeRanges=fName == WARP[0], overwrite=True):
            total[tag] += 1
        else:
            failed[tag] += 1
    self.tm.indent(level=0)
    self.tm.info(
        f&#34;&#34;&#34;Exported {total[&#34;node&#34;]} node features&#34;&#34;&#34;
        f&#34;&#34;&#34; and {total[&#34;edge&#34;]} edge features&#34;&#34;&#34;
        f&#34;&#34;&#34; and {total[&#34;config&#34;]} config features&#34;&#34;&#34;
        f&#34;&#34;&#34; to {self.writeDir}&#34;&#34;&#34;
    )
    if len(failed):
        for (tag, nf) in sorted(failed.items()):
            self.tm.error(f&#34;Failed to export {nf} {tag} features&#34;)
        good = False

    if silent is not None:
        self.tm.setSilent(wasSilent)
    return good</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf" href="index.html">tf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="tf.fabric.PRECOMPUTE" href="#tf.fabric.PRECOMPUTE">PRECOMPUTE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.fabric.Fabric" href="#tf.fabric.Fabric">Fabric</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.fabric.Fabric.clearCache" href="#tf.fabric.Fabric.clearCache">clearCache</a></code></li>
<li><code><a title="tf.fabric.Fabric.explore" href="#tf.fabric.Fabric.explore">explore</a></code></li>
<li><code><a title="tf.fabric.Fabric.exportMQL" href="#tf.fabric.Fabric.exportMQL">exportMQL</a></code></li>
<li><code><a title="tf.fabric.Fabric.importMQL" href="#tf.fabric.Fabric.importMQL">importMQL</a></code></li>
<li><code><a title="tf.fabric.Fabric.load" href="#tf.fabric.Fabric.load">load</a></code></li>
<li><code><a title="tf.fabric.Fabric.loadAll" href="#tf.fabric.Fabric.loadAll">loadAll</a></code></li>
<li><code><a title="tf.fabric.Fabric.save" href="#tf.fabric.Fabric.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>