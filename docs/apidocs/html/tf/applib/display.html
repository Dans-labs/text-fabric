<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>tf.applib.display API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.applib.display</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import types
from collections import namedtuple

from ..parameters import DOWNLOADS, SERVER_DISPLAY, SERVER_DISPLAY_BASE
from ..core.text import DEFAULT_FORMAT
from ..core.helpers import mdEsc, htmlEsc, flattenToSet, console
from .helpers import tupleEnum, RESULT, dh, NB
from .condense import condense, condenseSet
from .highlight import getTupleHighlights, getHlAtt
from .displaysettings import DisplaySettings
from .settings import ORIG

LIMIT_SHOW = 100
LIMIT_TABLE = 2000
LIMIT_DISPLAY_DEPTH = 100

QUAD = &#34;  &#34;

__pdoc__ = {}

OuterContext = namedtuple(
    &#34;OuterContext&#34;,
    &#34;&#34;&#34;
    ltr
    textCls
    slots
    inTuple
    explain
&#34;&#34;&#34;.strip().split(),
)
OuterContext.__doc__ = (
    &#34;Outer node properties during plain() and pretty(). &#34;
    &#34;Only the properties of the node for which the outer call&#34;
    &#34; plain() or pretty() has been made, not the nodes encountered&#34;
    &#34; during recursion.&#34;
)
__pdoc__[&#34;OuterContext.ltr&#34;] = &#34;writing direction.&#34;
__pdoc__[&#34;OuterContext.textCls&#34;] = &#34;Css class for full text.&#34;
__pdoc__[&#34;OuterContext.slots&#34;] = &#34;Set of slots under the outer node.&#34;
__pdoc__[
    &#34;OuterContext.inTuple&#34;
] = &#34;Whether the outer node is displayed as part of a tuple of nodes.&#34;

NodeContext = namedtuple(
    &#34;NodeContext&#34;,
    &#34;&#34;&#34;
    slotType
    nType
    isSlot
    isSlotOrDescend
    descend
    isBaseNonSlot
    hasChunks
    children
    boundaryCls
    textCls
    hlCls
    hlStyle
    nodePart
    cls
    slots
    hidden
&#34;&#34;&#34;.strip().split(),
)
NodeContext.__doc__ = &#34;Node properties during plain() or pretty().&#34;
__pdoc__[&#34;NodeContext.slotType&#34;] = &#34;The slot type of the data set.&#34;
__pdoc__[&#34;NodeContext.nType&#34;] = &#34;The node type of the current node.&#34;
__pdoc__[&#34;NodeContext.isSlot&#34;] = &#34;Whether the current node is a slot node.&#34;
__pdoc__[&#34;NodeContext.isSlotOrDescend&#34;] = (
    &#34;Whether the current node is a slot node or&#34;
    &#34; has a type to which the current text format should descend.&#34;
    &#34; This type is determined by the current text format.&#34;
)
__pdoc__[&#34;NodeContext.descend&#34;] = (
    &#34;When calling T.text(n, descend=??) for this node, what should we&#34;
    &#34; substitute for the ?? ?&#34;
)
__pdoc__[&#34;NodeContext.isBaseNonSlot&#34;] = (
    &#34;Whether the current node has a type that is currently a baseType,&#34;
    &#34; i.e. a type where a pretty display should stop unfolding.&#34;
    &#34; No need to put the slot type in this set.&#34;
)
__pdoc__[&#34;NodeContext.hasChunks&#34;] = (
    &#34;Whether the current node has a type that has a related type that&#34;
    &#34; corresponds to contiguous chunks that build it. &#34;
    &#34; E.g. in the BHSA the type phrase has a chunk type phrase_atom.&#34;
)
__pdoc__[&#34;NodeContext.children&#34;] = &#34;The children of the current node.&#34;
__pdoc__[&#34;NodeContext.boundaryCls&#34;] = (
    &#34;Css class that represent the kinds of boundaries for this node.&#34;
    &#34; Nodes can have a firm of dotted left/right boundary, or no boundary at all.&#34;
)
__pdoc__[&#34;NodeContext.textCls&#34;] = &#34;The text Css class of the current node.&#34;
__pdoc__[&#34;NodeContext.hlCls&#34;] = &#34;The highlight Css class of the current node.&#34;
__pdoc__[&#34;NodeContext.hlStyle&#34;] = &#34;The highlight style attribute of the current node.&#34;
__pdoc__[
    &#34;NodeContext.nodePart&#34;
] = &#34;The node type/number insofar it has to be displayed for the current node&#34;
__pdoc__[&#34;NodeContext.cls&#34;] = (
    &#34;A dict of several classes for the display of the node:&#34;
    &#34; for the container, the label, and the children of the node;&#34;
    &#34; might be set by prettyCustom&#34;
)
__pdoc__[&#34;NodeContext.slots&#34;] = &#34;Set of slots that must be displayed for this node&#34;
__pdoc__[&#34;NodeContext.hidden&#34;] = (
    &#34;Whether the outer container and label of the current node&#34;
    &#34; should be hidden.&#34;
    &#34; This is used to reduce displays by hiding the chunk types of types&#34;
    &#34; that have chunks. E.g. in the BHSA: the phrase_atoms can be hidden.&#34;
)


def displayApi(app, silent):
    &#34;&#34;&#34;Produce the display API.

    The display API provides methods to generate styled representations
    of pieces of corpus texts in their relevant structures.
    The main end-user functions are `plain(node)` and `pretty(node)`.

    `plain()` focuses on the plain text, `pretty()` focuses on structure
    and feature display.

    Related are `plainTuple()` and `prettyTuple()` that work for tuples
    instead of nodes.

    And further there are `show()` and `table()`, that work
    with iterables of tuples of nodes (e.g. query results).

    Parameters
    ----------
    app: obj
        The high-level API object
    silent:
        The verbosity mode to perform this operation in.
        Normally it is the same as for the app, but when we do an `A.reuse()`
        we force `silent=True`.
    &#34;&#34;&#34;

    app.export = types.MethodType(export, app)
    app.table = types.MethodType(table, app)
    app.plainTuple = types.MethodType(plainTuple, app)
    app.plain = types.MethodType(plain, app)
    app.show = types.MethodType(show, app)
    app.prettyTuple = types.MethodType(prettyTuple, app)
    app.pretty = types.MethodType(pretty, app)
    app.loadCss = types.MethodType(loadCss, app)
    app.displaySetup = types.MethodType(displaySetup, app)
    app.displayReset = types.MethodType(displayReset, app)

    app.display = DisplaySettings(app)
    if not app._browse:
        app.loadCss()


def displaySetup(app, **options):
    &#34;&#34;&#34;Set up all display parameters.

    The display parameters are given default values, unless they are overriden
    by `options`.

    !!! hint &#34;corpus settings&#34;
        The defaults themselves come from the corpus settings, which are influenced
        by the `config.yaml` file, if it exists.

    Parameters
    ----------
    options: dict
        Explicit values for selected options that act as overrides of the defaults.
        A list of all available options is in
        `tf.applib.displaysettings.DisplaySettings`
        .
    &#34;&#34;&#34;

    display = app.display

    display.setup(**options)


def displayReset(app, *options):
    &#34;&#34;&#34;Restore display parameters to their defaults.

    Parameters
    ----------
    options: list, optional `[]`
        If present, only restore these options to their defaults.
    &#34;&#34;&#34;

    display = app.display

    display.reset(*options)
    # if not app._browse:
    #    app.loadCss()


def export(app, tuples, toDir=None, toFile=&#34;results.tsv&#34;, **options):
    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    fmt = dContext.fmt
    condenseType = dContext.condenseType
    tupleFeatures = dContext.tupleFeatures

    if toDir is None:
        toDir = os.path.expanduser(DOWNLOADS)
        if not os.path.exists(toDir):
            os.makedirs(toDir, exist_ok=True)
    toPath = f&#34;{toDir}/{toFile}&#34;

    resultsX = getResultsX(app, tuples, tupleFeatures, condenseType, fmt=fmt,)

    with open(toPath, &#34;w&#34;, encoding=&#34;utf_16_le&#34;) as fh:
        fh.write(
            &#34;\ufeff&#34;
            + &#34;&#34;.join(
                (&#34;\t&#34;.join(&#34;&#34; if t is None else str(t) for t in tup) + &#34;\n&#34;)
                for tup in resultsX
            )
        )


# PLAIN and FRIENDS


def table(app, tuples, _asString=False, **options):
    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    fOtype = F.otype.v

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    withPassage = dContext.withPassage
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;

    html = []
    one = True

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_TABLE, item):
        if one:
            heads = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
            html.append(
                f&#39;&lt;tr class=&#34;tf&#34;&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;{heads}&lt;/th&gt;&#39;
                f&#34;&lt;/tr&gt;&#34;
            )
            one = False
        html.append(
            plainTuple(
                app,
                tup,
                i,
                item=item,
                position=None,
                opened=False,
                _asString=True,
                skipCols=set(),
                **newOptions,
            )
        )
    html = &#34;&lt;table&gt;&#34; + &#34;\n&#34;.join(html) + &#34;&lt;/table&gt;&#34;
    if _asString:
        return html
    dh(html)


def plainTuple(
    app, tup, seq, item=RESULT, position=None, opened=False, _asString=False, **options
):
    display = app.display

    if not display.check(&#34;plainTuple&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    fOtype = F.otype.v
    _browse = app._browse

    dContext = display.get(options)
    condenseType = dContext.condenseType
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    withPassage = dContext.withPassage
    skipCols = dContext.skipCols

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if withPassage is True:
        passageNode = getRefMember(app, tup, dContext)
        passageRef = (
            &#34;&#34;
            if passageNode is None
            else app._sectionLink(passageNode)
            if _browse
            else app.webLink(passageNode, _asString=True)
        )
        passageRef = f&#39;&lt;span class=&#34;section ltr&#34;&gt;{passageRef}&lt;/span&gt;&#39;
    else:
        passageRef = &#34;&#34;

    newOptions = display.consume(options, &#34;withPassage&#34;)
    newOptionsH = display.consume(options, &#34;withPassage&#34;, &#34;highlights&#34;)

    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if _browse:
        prettyRep = (
            prettyTuple(app, tup, seq, withPassage=False, **newOptions)
            if opened
            else &#34;&#34;
        )
        current = &#34;focus&#34; if seq == position else &#34;&#34;
        attOpen = &#34;open &#34; if opened else &#34;&#34;
        tupSeq = &#34;,&#34;.join(str(n) for n in tup)
        if withPassage is True:
            sparts = T.sectionFromNode(passageNode, fillup=True)
            passageAtt = &#34; &#34;.join(
                f&#39;sec{i}=&#34;{sparts[i] if i &lt; len(sparts) else &#34;&#34;}&#34;&#39; for i in range(3)
            )
        else:
            passageAtt = &#34;&#34;

        plainRep = &#34;&#34;.join(
            &#34;&lt;span&gt;&#34;
            + mdEsc(
                app.plain(
                    n,
                    _inTuple=True,
                    withPassage=doPassage(dContext, i),
                    highlights=highlights,
                    **newOptionsH,
                )
            )
            + &#34;&lt;/span&gt;&#34;
            for (i, n) in enumerate(tup)
        )
        html = (
            f&#39;&lt;details class=&#34;pretty dtrow {current}&#34; seq=&#34;{seq}&#34; {attOpen}&gt;&#39;
            f&#34;&lt;summary&gt;&#34;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;pq fa fa-solar-panel fa-xs&#34;&#39;
            f&#39; title=&#34;show in context&#34; {passageAtt}&gt;&lt;/a&gt;&#39;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;sq&#34; tup=&#34;{tupSeq}&#34;&gt;{seq}&lt;/a&gt;&#39;
            f&#34; {passageRef} {plainRep}&#34;
            f&#34;&lt;/summary&gt;&#34;
            f&#39;&lt;div class=&#34;pretty&#34;&gt;{prettyRep}&lt;/div&gt;&#39;
            f&#34;&lt;/details&gt;&#34;
        )
        return html

    html = [str(seq)]
    if withPassage is True:
        html.append(passageRef)
    for (i, n) in enumerate(tup):
        html.append(
            app.plain(
                n,
                _inTuple=True,
                _asString=True,
                withPassage=doPassage(dContext, i),
                highlights=highlights,
                **newOptionsH,
            )
        )
    html = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;td class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/td&gt;&lt;td class=&#34;tf&#34;&gt;&#39;.join(html)
        + &#34;&lt;/td&gt;&lt;/tr&gt;&#34;
    )
    if _asString:
        return html

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;
    head = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
        + f&#34;&lt;/th&gt;&lt;/tr&gt;&#34;
    )
    html = f&#34;&lt;table&gt;&#34; + head + &#34;&#34;.join(html) + &#34;&lt;/table&gt;&#34;

    dh(html)


def plain(app, n, _inTuple=False, _asString=False, explain=False, **options):
    &#34;&#34;&#34;Display the plain text of a node.

    *Plain* is oppsed to *pretty*; `pretty` shows the underlying structure of the
    text material associated with a node, plain just shows the linear text.

    The result of plain is formatted text, the text is styled depending on
    the chosen text format. Text corresponding to sub nodes can be selectively
    highlighted.

    Parameters
    ----------
    app: object
        The application object, it is normally referenced by the variable `A`.
    n: integer
        Node
    options: dict
        Display options, see
        `tf.applib.displaysettings.DISPLAY_OPTIONS` and
        `tf.applib.displaysettings.INTERFACE_OPTIONS`.
    _inTuple: boolean, optional `False`
        Whether the result is meant too end up in a table cell produced by
        `plainTuple`. In that case some extra node types count as big and will
        not be displayed in full.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;plain&#34;, options):
        return &#34;&#34;

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml

    _browse = app._browse
    api = app.api

    ltr = getLtr(app, dContext)
    textCls = getTextCls(app, fmt)
    slots = getSlots(api, n)

    oContext = OuterContext(ltr, textCls, slots, _inTuple, not not explain)
    passage = getPassage(app, True, dContext, oContext, n)
    rep = _doPlain(
        app, dContext, oContext, None, n, True, True, True, 0, passage, [], {}, {}
    )
    sep = &#34; &#34; if passage and rep else &#34;&#34;

    result = passage + sep + rep

    if _browse or _asString:
        return result
    dh(result)


def note(isPretty, oContext, n, nType, first, last, level, *labels, **info):
    if not oContext.explain:
        return
    block = QUAD * level
    kindRep = &#34;pretty&#34; if isPretty else &#34;plain&#34;
    labelRep = &#34; &#34;.join(str(lab) for lab in labels)
    console(f&#34;{block}&lt;{level}&gt;{kindRep}({nType} {n}): {labelRep}&#34;, error=True)
    for (k, v) in info.items():
        console(f&#34;{block}&lt;{level}&gt;      {k:&lt;10} = {repr(v)}&#34;, error=True)


def depthExceeded(level):
    if level &gt; LIMIT_DISPLAY_DEPTH:
        console(&#34;DISPLAY: maximal depth exceeded: {LIMIT_DISPLAY_DEPTH}&#34;, error=True)
        return True
    return False


def _doPlain(
    app,
    dContext,
    oContext,
    pContext,
    n,
    outer,
    first,
    last,
    level,
    passage,
    html,
    done,
    called,
):
    if depthExceeded(level):
        return

    origOuter = outer
    if outer is None:
        outer = True

    nContext = _prepareDisplay(
        app, False, dContext, oContext, pContext, n, origOuter, done=done,
    )
    if type(nContext) is str:
        note(False, oContext, n, nContext, first, last, level, &#34;nothing to do&#34;)
        return &#34;&#34;.join(html) if outer else None

    nDone = done.setdefault(n, set())
    nCalled = called.setdefault(n, set())

    slots = nContext.slots

    finished = slots &lt;= nDone
    calledBefore = slots &lt;= nCalled
    if finished or calledBefore:
        note(
            False,
            oContext,
            n,
            nContext.nType,
            first,
            last,
            level,
            &#34;already &#34; + (&#34;finished&#34; if finished else &#34;called&#34;),
            task=slots,
            done=nDone,
            called=nCalled,
        )
        return &#34;&#34;.join(html) if outer else None

    aContext = app.context
    chunkedTypes = aContext.chunkedTypes

    ltr = oContext.ltr

    nType = nContext.nType
    hlCls = nContext.hlCls
    hlStyle = nContext.hlStyle
    boundaryCls = nContext.boundaryCls
    nodePart = nContext.nodePart
    children = nContext.children

    outerCls = f&#34;outer&#34; if outer else &#34;&#34;

    didChunkedType = False

    sdone = {}
    if not (outer and nType in chunkedTypes):
        snodeInfo = getChunkedType(app, nContext, n, outer)
        if snodeInfo:
            (sn, spContext) = snodeInfo
            snContext = _prepareDisplay(
                app,
                False,
                dContext,
                oContext,
                spContext,
                sn,
                False,
                chunk=n,
                done=sdone,
            )
            shlCls = snContext.hlCls
            shlStyle = snContext.hlStyle
            snodePart = snContext.nodePart
            sboundaryCls = snContext.boundaryCls

            if (type(snContext) is not str) and shlCls:
                sclses = f&#34;plain {sboundaryCls} {shlCls}&#34;
                html.append(f&#39;&lt;span class=&#34;{sclses}&#34; {shlStyle}&gt;&#39;)
                if snodePart:
                    html.append(snodePart)
                didChunkedType = True

        clses = (
            f&#34;plain {&#39;&#39; if didChunkedType else outerCls} {ltr} {boundaryCls} {hlCls}&#34;
        )
        html.append(f&#39;&lt;span class=&#34;{clses}&#34; {hlStyle}&gt;&#39;)

        if nodePart:
            html.append(nodePart)

        html.append(
            _doPlainNode(
                app,
                dContext,
                oContext,
                nContext,
                n,
                outer,
                first,
                last,
                level,
                passage,
                done=done,
            )
        )

    nCalled.update(nContext.slots)

    lastCh = len(children) - 1

    note(
        False,
        oContext,
        n,
        nContext.nType,
        first,
        last,
        level,
        &#34;start children&#34; if children else &#34;bottom node&#34;,
        children=children,
        task=slots,
        done=nDone,
        called=nCalled,
    )

    for (i, ch) in enumerate(children):
        thisFirst = first and i == 0
        thisLast = last and i == lastCh
        _doPlain(
            app,
            dContext,
            oContext,
            nContext,
            ch,
            False,
            thisFirst,
            thisLast,
            level + 1,
            &#34;&#34;,
            html,
            done,
            called,
        )
    if not (outer and nType in chunkedTypes):
        html.append(&#34;&lt;/span&gt;&#34;)
        if didChunkedType:
            html.append(&#34;&lt;/span&gt;&#34;)

    nDone = done.setdefault(n, set())
    nDone |= slots

    if children:
        note(
            False,
            oContext,
            n,
            nContext.nType,
            first,
            last,
            level,
            &#34;end children&#34;,
            done=nDone,
        )

    return &#34;&#34;.join(html) if outer else None


def _doPlainNode(
    app, dContext, oContext, nContext, n, outer, first, last, level, passage, done={}
):
    api = app.api
    T = api.T

    aContext = app.context
    plainCustom = aContext.plainCustom

    isHtml = dContext.isHtml
    fmt = dContext.fmt

    ltr = oContext.ltr
    textCls = nContext.textCls

    nType = nContext.nType

    isSlotOrDescend = nContext.isSlotOrDescend
    descend = nContext.descend

    if nType in plainCustom:
        method = plainCustom[nType]
        contrib = method(app, dContext, oContext, nContext, n, outer, done=done)
        return contrib
    if isSlotOrDescend:
        text = htmlSafe(
            T.text(
                n,
                fmt=fmt,
                descend=descend,
                outer=outer,
                first=first,
                last=last,
                level=level,
            ),
            isHtml,
        )
        contrib = f&#39;&lt;span class=&#34;{textCls}&#34;&gt;{text}&lt;/span&gt;&#39;
    else:
        tplFilled = getText(
            app,
            False,
            n,
            nType,
            outer,
            first,
            last,
            level,
            passage if outer else &#34;&#34;,
            descend,
            dContext=dContext,
        )
        contrib = f&#39;&lt;span class=&#34;plain {textCls} {ltr}&#34;&gt;{tplFilled}&lt;/span&gt;&#39;

    return contrib


# PRETTY and FRIENDS


def show(app, tuples, **options):
    display = app.display

    if not display.check(&#34;show&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    api = app.api
    F = api.F

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_SHOW, item):
        item = F.otype.v(tup[0]) if condensed and condenseType else RESULT
        prettyTuple(app, tup, i, item=item, skipCols=set(), **newOptions)


def prettyTuple(app, tup, seq, item=RESULT, **options):
    display = app.display

    if not display.check(&#34;prettyTuple&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    skipCols = dContext.skipCols

    _browse = app._browse

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if len(tup) == 0:
        if _browse:
            return &#34;&#34;
        else:
            return

    api = app.api
    sortKey = api.sortKey

    containers = {tup[0]} if condensed else condenseSet(api, tup, condenseType)
    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if not _browse:
        dh(f&#34;&lt;p&gt;&lt;b&gt;{item}&lt;/b&gt; &lt;i&gt;{seq}&lt;/i&gt;&lt;/p&gt;&#34;)
    if _browse:
        html = []
    for t in sorted(containers, key=sortKey):
        h = app.pretty(
            t, highlights=highlights, **display.consume(options, &#34;highlights&#34;),
        )
        if _browse:
            html.append(h)
    if _browse:
        return &#34;&#34;.join(html)


def pretty(app, n, explain=False, **options):
    &#34;&#34;&#34;Display the structure associated with a node.

    *Plain* is oppsed to *pretty*; `pretty` shows the underlying structure of the
    text material associated with a node, plain just shows the linear text.

    The result of pretty is a formatted display of pieces of text together with
    extra features and their values
    Text corresponding to sub nodes can be selectively highlighted.

    Parameters
    ----------
    app: object
        The application object, it is normally referenced by the variable `A`.
    n: integer
        Node
    options: dict
        Display options, see `tf.applib.displaysettings.DisplaySettings`
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;pretty&#34;, options):
        return &#34;&#34;

    _browse = app._browse

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    tupleFeatures = dContext.tupleFeatures
    extraFeatures = dContext.extraFeatures
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml
    dContext.features = sorted(
        flattenToSet(extraFeatures[0]) | flattenToSet(tupleFeatures)
    )
    dContext.featuresIndirect = extraFeatures[1]

    api = app.api
    F = api.F
    L = api.L
    otypeRank = api.otypeRank

    ltr = getLtr(app, dContext)
    textCls = getTextCls(app, fmt)

    containerN = None

    nType = F.otype.v(n)
    if condensed and condenseType:
        if nType == condenseType:
            containerN = n
        elif otypeRank[nType] &lt; otypeRank[condenseType]:
            ups = L.u(n, otype=condenseType)
            if ups:
                containerN = ups[0]

    slots = (
        getSlots(api, n)
        if not condensed or not condenseType or containerN is None
        else getSlots(api, containerN)
    )

    oContext = OuterContext(ltr, textCls, slots, False, not not explain)
    passage = getPassage(app, False, dContext, oContext, n)

    html = []

    _doPretty(app, dContext, oContext, None, n, True, True, True, 0, html, {}, {})

    htmlStr = passage + &#34;&#34;.join(html)
    if _browse:
        return htmlStr
    dh(htmlStr)


def _doPretty(
    app, dContext, oContext, pContext, n, outer, first, last, level, html, done, called,
):
    if depthExceeded(level):
        return

    nContext = _prepareDisplay(
        app, True, dContext, oContext, pContext, n, outer, done=done
    )
    if type(nContext) is str:
        note(True, oContext, n, nContext, first, last, level, &#34;nothing to do&#34;)
        return &#34;&#34;.join(html) if outer else None

    nDone = done.setdefault(n, set())
    nCalled = called.setdefault(n, set())

    slots = nContext.slots

    finished = slots &lt;= nDone
    calledBefore = slots &lt;= nCalled
    if finished or calledBefore:
        note(
            True,
            oContext,
            n,
            nContext.nType,
            first,
            last,
            level,
            &#34;already &#34; + (&#34;finished&#34; if finished else &#34;called&#34;),
            task=slots,
            done=nDone,
            called=nCalled,
        )
        return &#34;&#34;.join(html) if outer else None

    aContext = app.context
    afterChild = aContext.afterChild
    hasGraphics = aContext.hasGraphics

    showGraphics = dContext.showGraphics

    ltr = oContext.ltr

    isBaseNonSlot = nContext.isBaseNonSlot
    nType = nContext.nType
    hasChunks = nContext.hasChunks
    children = nContext.children
    cls = nContext.cls
    childCls = cls[&#34;children&#34;]

    nodePlain = None
    if isBaseNonSlot:
        nodePlain = _doPlain(
            app,
            dContext,
            oContext,
            nContext,
            n,
            None,
            first,
            last,
            level,
            &#34;&#34;,
            [],
            done,
            called,
        )

    didChunkedType = False

    snodeInfo = getChunkedType(app, nContext, n, outer)
    if snodeInfo:
        (sn, spContext) = snodeInfo
        snContext = _prepareDisplay(
            app, True, dContext, oContext, spContext, sn, False, chunk=n, done=done,
        )
        if type(snContext) is not str:
            sisBaseNonSlot = snContext.isBaseNonSlot
            scls = snContext.cls
            schildCls = scls[&#34;children&#34;]
            sslots = snContext.slots

            snodePlain = None
            if sisBaseNonSlot:
                snodePlain = _doPlain(
                    app,
                    dContext,
                    oContext,
                    spContext,
                    sn,
                    None,
                    first,
                    last,
                    level,
                    &#34;&#34;,
                    [],
                    done,
                    called,
                )
            (slabel, sfeaturePart) = _doPrettyNode(
                app,
                dContext,
                oContext,
                snContext,
                sn,
                False,
                first,
                last,
                level,
                snodePlain,
            )
            (scontainerB, scontainerE) = _doPrettyWrapPre(
                app,
                sn,
                False,
                slabel,
                sfeaturePart,
                html,
                snContext,
                showGraphics,
                hasGraphics,
                ltr,
            )
            done.setdefault(sn, set()).add(sslots)
            nDone = done.setdefault(sn, set())
            nDone |= sslots
            html.append(f&#39;&lt;div class=&#34;{schildCls} {ltr}&#34;&gt;&#39;)

            didChunkedType = True

    if not hasChunks or isBaseNonSlot:
        (label, featurePart) = _doPrettyNode(
            app, dContext, oContext, nContext, n, outer, first, last, level, nodePlain
        )
        (containerB, containerE) = _doPrettyWrapPre(
            app,
            n,
            outer,
            label,
            featurePart,
            html,
            nContext,
            showGraphics,
            hasGraphics,
            ltr,
        )

    nCalled.update(nContext.slots)

    if children:
        html.append(f&#39;&lt;div class=&#34;{childCls} {ltr}&#34;&gt;&#39;)

    lastCh = len(children) - 1

    note(
        True,
        oContext,
        n,
        nContext.nType,
        first,
        last,
        level,
        &#34;start children&#34; if children else &#34;bottom node&#34;,
        children=children,
        task=slots,
        done=nDone,
        called=nCalled,
    )

    for (i, ch) in enumerate(children):
        thisFirst = first and i == 0
        thisLast = last and i == lastCh
        _doPretty(
            app,
            dContext,
            oContext,
            nContext,
            ch,
            False,
            thisFirst,
            thisLast,
            level + 1,
            html,
            done,
            called,
        )
        after = afterChild.get(nType, None)
        if after:
            html.append(after(ch))

    nDone = done.setdefault(n, set())
    nDone |= slots

    if children:
        note(
            True,
            oContext,
            n,
            nContext.nType,
            first,
            last,
            level,
            &#34;end children&#34;,
            task=slots,
        )

    if children:
        html.append(&#34;&lt;/div&gt;&#34;)

    if not hasChunks or isBaseNonSlot:
        _doPrettyWrapPost(label, featurePart, html, containerB, containerE)

    if didChunkedType:
        _doPrettyWrapPost(slabel, sfeaturePart, html, scontainerB, scontainerE)
        html.append(&#34;&lt;/div&gt;&#34;)

    return &#34;&#34;.join(html) if outer else None


def _doPrettyWrapPre(
    app, n, outer, label, featurePart, html, nContext, showGraphics, hasGraphics, ltr,
):
    nType = nContext.nType
    hidden = nContext.hidden
    cls = nContext.cls
    contCls = &#34;contnr cnul&#34; if hidden else cls[&#34;container&#34;]
    hlCls = nContext.hlCls
    hlStyle = nContext.hlStyle
    boundaryCls = nContext.boundaryCls
    children = nContext.children
    label0 = label.get(&#34;&#34;, None)
    labelB = label.get(&#34;b&#34;, None)

    containerB = f&#39;&lt;div class=&#34;{contCls} {{}} {ltr} {boundaryCls} {hlCls}&#34; {hlStyle}&gt;&#39;
    containerE = f&#34;&lt;/div&gt;&#34;

    terminalCls = &#34;trm&#34;
    # if hidden:
    #    html.append(containerB.format(terminalCls))
    # else:
    material = &#34;&#34; if hidden else f&#34; {featurePart}&#34;
    if labelB is not None:
        trm = terminalCls
        html.append(f&#34;{containerB.format(trm)}{labelB}{material}{containerE}&#34;)
    if label0 is not None:
        trm = &#34;&#34; if children and not hidden else terminalCls
        html.append(f&#34;{containerB.format(trm)}{label0}{material}&#34;)

    if showGraphics and nType in hasGraphics:
        html.append(app.getGraphics(n, nType, outer))

    return (containerB, containerE)


def _doPrettyWrapPost(label, featurePart, html, containerB, containerE):
    label0 = label.get(&#34;&#34;, None)
    labelE = label.get(&#34;e&#34;, None)

    if label0 is not None:
        html.append(containerE)
    if labelE is not None:
        html.append(f&#34;{containerB}{labelE} {featurePart}{containerE}&#34;)


def _doPrettyNode(
    app, dContext, oContext, nContext, n, outer, first, last, level, nodePlain
):
    api = app.api
    L = api.L

    aContext = app.context
    lexTypes = aContext.lexTypes
    lexMap = aContext.lexMap

    textCls = nContext.textCls
    hidden = nContext.hidden

    nType = nContext.nType
    cls = nContext.cls
    hlCls = nContext.hlCls
    hlStyle = nContext.hlStyle
    descend = nContext.descend
    isBaseNonSlot = nContext.isBaseNonSlot
    children = nContext.children
    nodePart = nContext.nodePart

    labelHlCls = &#34;&#34;
    labelHlStyle = &#34;&#34;

    if isBaseNonSlot:
        heading = nodePlain
    else:
        labelHlCls = hlCls
        labelHlStyle = hlStyle
        heading = getText(
            app,
            True,
            n,
            nType,
            outer,
            first,
            last,
            level,
            &#34;&#34;,
            descend,
            dContext=dContext,
        )

    heading = f&#39;&lt;span class=&#34;{textCls}&#34;&gt;{heading}&lt;/span&gt;&#39; if heading else &#34;&#34;

    featurePart = getFeatures(app, dContext, n, nType)

    if nType in lexTypes:
        slots = getSlots(api, n)
        extremeOccs = (slots[0],) if len(slots) == 1 else (slots[0], slots[-1])
        linkOccs = &#34; - &#34;.join(app.webLink(lo, _asString=True) for lo in extremeOccs)
        featurePart += f&#39;&lt;div class=&#34;occs&#34;&gt;{linkOccs}&lt;/div&gt;&#39;
    if nType in lexMap:
        lx = L.u(n, otype=lexMap[nType])
        if lx:
            heading = app.webLink(lx[0], heading, _asString=True)

    label = {}
    for x in (&#34;&#34;, &#34;b&#34;, &#34;e&#34;):
        key = f&#34;label{x}&#34;
        if key in cls:
            val = cls[key]
            terminalCls = &#34;trm&#34; if x or not children else &#34;&#34;
            sep = &#34; &#34; if nodePart and heading else &#34;&#34;
            material = (
                (heading if nodePlain else &#34;&#34;)
                if hidden
                else f&#34;{nodePart}{sep}{heading}&#34;
                if nodePart or heading
                else &#34;&#34;
            )
            label[x] = (
                f&#39;&lt;div class=&#34;{val} {terminalCls} {labelHlCls}&#34; {labelHlStyle}&gt;&#39;
                f&#34;{material}&lt;/div&gt;&#34;
                if material
                else &#34;&#34;
            )

    return (label, featurePart)


def _prepareDisplay(
    app, isPretty, dContext, oContext, pContext, n, outer, chunk=None, done=set(),
):
    api = app.api
    F = api.F
    T = api.T
    slotType = F.otype.slotType
    nType = F.otype.v(n)

    aContext = app.context
    levelCls = aContext.levelCls
    noChildren = aContext.noChildren
    prettyCustom = aContext.prettyCustom
    isChunkOf = aContext.isChunkOf
    chunkedTypes = aContext.chunkedTypes
    lexTypes = aContext.lexTypes
    styles = aContext.styles

    fmt = dContext.fmt
    baseTypes = dContext.baseTypes
    setSubBaseTypes(aContext, dContext, slotType)

    highlights = dContext.highlights
    showChunks = dContext.showChunks

    descendType = T.formats.get(fmt, slotType)
    bottomTypes = baseTypes if isPretty else {descendType}

    isSlot = nType == slotType
    hasChunks = nType in chunkedTypes
    isHidden = not showChunks and nType in isChunkOf

    slots = (
        oContext.slots
        if pContext is None
        else frozenset()
        if type(pContext) is str
        else pContext.slots
    )
    nDone = done.get(n, set())
    slots -= nDone

    isBaseNonSlot = nType != slotType and nType in baseTypes

    children = (
        ()
        if isSlot
        or nType in bottomTypes
        or isChunkOf.get(nType, None) in bottomTypes
        or nType in lexTypes
        or (not isPretty and nType in noChildren)
        else getChildren(app, isPretty, dContext, oContext, n, nType)
    )

    boundaryResult = getBoundaryResult(
        isPretty, api, oContext, slots, n, nType, chunk=chunk
    )
    if boundaryResult is None:
        return nType

    (boundaryCls, slots) = boundaryResult
    if not slots:
        return nType

    (hlCls, hlStyle) = getHlAtt(app, n, highlights, baseTypes, not isPretty)

    isSlotOrDescend = isSlot or nType == descendType
    descend = False if descendType == slotType else None

    nodePart = getNodePart(
        app, isPretty, dContext, n, nType, isSlot, outer, hlCls != &#34;&#34;
    )
    cls = {}
    if isPretty:
        if nType in levelCls:
            cls.update(levelCls[nType])
        if nType in prettyCustom:
            prettyCustom[nType](app, n, nType, cls)

    textCls = styles.get(nType, oContext.textCls)

    return NodeContext(
        slotType,
        nType,
        isSlot,
        isSlotOrDescend,
        descend,
        isBaseNonSlot,
        hasChunks,
        children,
        boundaryCls,
        textCls,
        hlCls,
        hlStyle,
        nodePart,
        cls,
        slots,
        isHidden,
    )


def setSubBaseTypes(aContext, dContext, slotType):
    descendantType = aContext.descendantType
    isChunkOf = aContext.isChunkOf
    baseTypes = dContext.baseTypes

    chunkBaseTypes = {ct for (ct, t) in isChunkOf.items() if t in baseTypes}
    subBaseTypes = set()

    if baseTypes and baseTypes != {slotType}:
        for bt in baseTypes:
            if bt in descendantType:
                subBaseTypes |= descendantType[bt]
    dContext.subBaseTypes = subBaseTypes - baseTypes - chunkBaseTypes


def doPassage(dContext, i):
    withPassage = dContext.withPassage
    return withPassage is not True and withPassage and i + 1 in withPassage


def getPassage(app, isPretty, dContext, oContext, n):
    withPassage = dContext.withPassage

    if not withPassage:
        return &#34;&#34;

    passage = app.webLink(n, _asString=True)
    return f&#39;&lt;span class=&#34;section ltr&#34;&gt;{passage}{NB}&lt;/span&gt;&#39;


def getText(
    app, isPretty, n, nType, outer, first, last, level, passage, descend, dContext=None
):
    T = app.api.T
    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    aContext = app.context
    templates = aContext.labels if isPretty else aContext.templates

    fmt = None if dContext is None else dContext.fmt
    standardFeatures = True if dContext is None else dContext.standardFeatures
    isHtml = False if dContext is None else dContext.isHtml
    suppress = set() if dContext is None else dContext.suppress

    (tpl, feats) = templates[nType]

    tplFilled = (
        (
            (
                &#39;&lt;span class=&#34;section&#34;&gt;&#39;
                + (NB if passage else app.sectionStrFromNode(n))
                + &#34;&lt;/span&gt;&#34;
            )
            if nType in sectionTypeSet
            else f&#39;&lt;span class=&#34;structure&#34;&gt;{app.structureStrFromNode(n)}&lt;/span&gt;&#39;
            if nType in structureTypeSet
            else htmlSafe(
                T.text(
                    n,
                    fmt=fmt,
                    descend=descend,
                    outer=outer,
                    first=first,
                    last=last,
                    level=level,
                ),
                isHtml,
            )
        )
        if tpl is True
        else (
            tpl.format(
                **{feat: getValue(app, n, nType, feat, suppress) for feat in feats}
            )
            if standardFeatures
            else &#34;&#34;
        )
    )
    return tplFilled


def htmlSafe(text, isHtml):
    return text if isHtml else htmlEsc(text)


def getTextCls(app, fmt):
    aContext = app.context
    formatCls = aContext.formatCls
    defaultClsOrig = aContext.defaultClsOrig

    return formatCls.get(fmt or DEFAULT_FORMAT, defaultClsOrig)


def getValue(app, n, nType, feat, suppress):
    F = app.api.F
    Fs = app.api.Fs

    aContext = app.context
    transform = aContext.transform
    if feat in suppress:
        val = &#34;&#34;
    else:
        featObj = Fs(feat) if hasattr(F, feat) else None
        val = htmlEsc(featObj.v(n)) if featObj else None
        modifier = transform.get(nType, {}).get(feat, None)
        if modifier:
            val = modifier(n, val)
    return f&#39;&lt;span title=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#39;


def getLtr(app, dContext):
    aContext = app.context
    direction = aContext.direction

    fmt = dContext.fmt or DEFAULT_FORMAT

    return (
        &#34;rtl&#34;
        if direction == &#34;rtl&#34; and (f&#34;{ORIG}-&#34; in fmt or f&#34;-{ORIG}&#34; in fmt)
        else (&#34;&#34; if direction == &#34;ltr&#34; else &#34;ltr&#34;)
    )


def getBigType(app, dContext, nType, otypeRank):
    api = app.api
    T = api.T

    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    full = dContext.full
    condenseType = dContext.condenseType

    isBig = False
    if not full:
        if sectionTypeSet and nType in sectionTypeSet | structureTypeSet:
            if condenseType is None or otypeRank[nType] &gt; otypeRank[condenseType]:
                isBig = True
        elif condenseType is not None and otypeRank[nType] &gt; otypeRank[condenseType]:
            isBig = True
    return isBig


def getBoundaryResult(isPretty, api, oContext, inSlots, n, nType, chunk=None):
    ltr = oContext.ltr
    startCls = &#34;r&#34; if ltr == &#34;rtl&#34; else &#34;l&#34;
    endCls = &#34;l&#34; if ltr == &#34;rtl&#34; else &#34;r&#34;

    boundaryCls = &#34;&#34;

    nSlots = getSlots(api, n)

    chunkSlots = getSlots(api, chunk) &amp; nSlots if chunk else None

    slots = inSlots &amp; (chunkSlots if chunk else nSlots)

    if not slots:
        return None

    nStart = min(nSlots)
    nEnd = max(nSlots)
    tStart = min(slots)
    tEnd = max(slots)

    boundaryCls = &#34;&#34;

    if chunk:
        chStart = min(chunkSlots)
        chEnd = max(chunkSlots)

    kind = &#34;&#34;
    if nStart &lt; tStart:
        kind = (
            &#34;&#34;
            if ((tStart - 1 not in nSlots) or (chunk and chStart == tStart))
            else &#34;no&#34;
        )
        boundaryCls += f&#34; {startCls}{kind}&#34;
    if nEnd &gt; tEnd:
        kind = &#34;&#34; if ((tEnd + 1 not in nSlots) or (chunk and chEnd == tEnd)) else &#34;no&#34;
        boundaryCls += f&#34; {endCls}{kind}&#34;

    return (boundaryCls, slots)


def getChunkedType(app, nContext, n, outer):

    aContext = app.context
    isChunkOf = aContext.isChunkOf
    chunkedTypes = aContext.chunkedTypes

    nType = nContext.nType

    if not outer and nType not in chunkedTypes and nType in isChunkOf:
        api = app.api
        L = api.L
        chunkedType = isChunkOf[nType]
        sn = L.u(n, otype=chunkedType)
        if sn:
            E = api.E
            nSlots = nContext.slots
            sownSlots = frozenset(E.oslots.s(sn[0]))
            return (
                sn[0],
                nContext._replace(slots=nSlots &amp; sownSlots),
            )

    return None


def getChildren(app, isPretty, dContext, oContext, n, nType):
    api = app.api
    L = api.L
    F = api.F
    otypeRank = api.otypeRank
    sortNodes = api.sortNodes
    slotType = F.otype.slotType
    fOtypev = F.otype.v

    aContext = app.context
    verseTypes = aContext.verseTypes
    childType = aContext.childType
    baseTypes = dContext.baseTypes
    subBaseTypes = dContext.subBaseTypes
    childrenCustom = aContext.childrenCustom
    showVerseInTuple = aContext.showVerseInTuple

    inTuple = oContext.inTuple

    full = dContext.full

    isBigType = (
        inTuple
        if not isPretty and nType in verseTypes and not showVerseInTuple
        else getBigType(app, dContext, nType, otypeRank)
    )

    if isBigType and not full:
        children = ()
    elif nType in childType:
        childType = childType[nType]
        children = L.i(n, otype=childType)
        if nType in childrenCustom:
            (condition, method, add) = childrenCustom[nType]
            if condition(n):
                others = method(n)
                if add:
                    children += others
                else:
                    children = others

            children = sortNodes(set(children) - {n})
    else:
        children = L.i(n)
    if isPretty and baseTypes and baseTypes != {slotType}:
        refSet = set(children)
        children = tuple(
            ch
            for ch in children
            if (fOtypev(ch) not in subBaseTypes)
            and not (set(L.u(ch, otype=baseTypes)) &amp; refSet)
        )
    return children


def getNodePart(app, isPretty, dContext, n, nType, isSlot, outer, isHl):
    _browse = app._browse

    Fs = app.api.Fs

    aContext = app.context
    lineNumberFeature = aContext.lineNumberFeature
    allowInfo = isPretty or outer is None or outer or isHl

    withNodes = dContext.withNodes and outer is not None
    withTypes = dContext.withTypes and outer is not None
    prettyTypes = dContext.prettyTypes and outer is not None
    lineNumbers = dContext.lineNumbers and outer is not None

    num = &#34;&#34;
    if withNodes and allowInfo:
        num = n

    ntp = &#34;&#34;
    if (withTypes or isPretty and prettyTypes) and not isSlot and allowInfo:
        ntp = nType

    line = &#34;&#34;
    if lineNumbers and allowInfo:
        feat = lineNumberFeature.get(nType, None)
        if feat:
            line = Fs(feat).v(n)
        if line:
            line = f&#34;@{line}&#34; if line else &#34;&#34;

    elemb = &#39;a href=&#34;#&#34;&#39; if _browse else &#34;span&#34;
    eleme = &#34;a&#34; if _browse else &#34;span&#34;
    sep = &#34;:&#34; if ntp and num else &#34;&#34;

    return (
        f&#39;&lt;{elemb} class=&#34;nd&#34;&gt;{ntp}{sep}{num}{line}&lt;/{eleme}&gt;&#39;
        if ntp or num or line
        else &#34;&#34;
    )


# COMPOSE TABLES FOR CSV EXPORT


def getResultsX(app, results, features, condenseType, fmt=None):
    api = app.api
    F = api.F
    Fs = api.Fs
    T = api.T
    fOtype = F.otype.v
    otypeRank = api.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()
    firstResult = results[0]
    nTuple = len(firstResult)
    refColumns = [
        i for (i, n) in enumerate(firstResult) if fOtype(n) not in sectionTypeSet
    ]
    refColumn = refColumns[0] if refColumns else nTuple - 1
    header = [&#34;R&#34;] + [f&#34;S{i}&#34; for i in range(1, sectionDepth + 1)]
    emptyA = []

    featureDict = {i: tuple(f.split()) if type(f) is str else f for (i, f) in features}

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    for j in range(nTuple):
        i = j + 1
        n = firstResult[j]
        nType = fOtype(n)
        header.extend([f&#34;NODE{i}&#34;, f&#34;TYPE{i}&#34;])
        if withText(nType):
            header.append(f&#34;TEXT{i}&#34;)
        header.extend(f&#34;{feature}{i}&#34; for feature in featureDict.get(j, emptyA))
    rows = [tuple(header)]
    for (rm, r) in enumerate(results):
        rn = rm + 1
        row = [rn]
        refN = r[refColumn]
        sparts = T.sectionFromNode(refN)
        nParts = len(sparts)
        section = sparts + ((None,) * (sectionDepth - nParts))
        row.extend(section)
        for j in range(nTuple):
            n = r[j]
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
            row.extend(Fs(feature).v(n) for feature in featureDict.get(j, emptyA))
        rows.append(tuple(row))
    return tuple(rows)


def getSlots(api, n):
    F = api.F
    fOtype = F.otype.v
    slotType = F.otype.slotType
    if fOtype(n) == slotType:
        return frozenset((n,))
    E = api.E
    maxSlot = F.otype.maxSlot
    return frozenset(E.oslots.data[n - maxSlot - 1])


def getFeatures(app, dContext, n, nType):
    api = app.api
    L = api.L
    Fs = api.Fs

    aContext = app.context
    featuresBare = aContext.featuresBare
    features = aContext.features

    dFeatures = dContext.features
    dFeaturesIndirect = dContext.featuresIndirect
    queryFeatures = dContext.queryFeatures
    standardFeatures = dContext.standardFeatures
    suppress = dContext.suppress
    noneValues = dContext.noneValues

    (theseFeatures, indirect) = features.get(nType, ((), {}))
    (theseFeaturesBare, indirectBare) = featuresBare.get(nType, ((), {}))

    # a feature can be nType:feature
    # do a L.u(n, otype=nType)[0] and take the feature from there

    givenFeatureSet = set(theseFeatures) | set(theseFeaturesBare)
    xFeatures = tuple(
        f for f in dFeatures if not standardFeatures or f not in givenFeatureSet
    )
    featureList = tuple(theseFeaturesBare + theseFeatures) + xFeatures
    bFeatures = len(theseFeaturesBare)
    nbFeatures = len(theseFeaturesBare) + len(theseFeatures)

    featurePart = &#34;&#34;

    if standardFeatures or queryFeatures:
        for (i, name) in enumerate(featureList):
            if name not in suppress:
                fsName = Fs(name)
                if fsName is None:
                    continue
                fsNamev = fsName.v

                value = None
                if (
                    name in dFeaturesIndirect
                    or name in indirectBare
                    or name in indirect
                ):
                    refType = (
                        dFeaturesIndirect[name]
                        if name in dFeaturesIndirect
                        else indirectBare[name]
                        if name in indirectBare
                        else indirect[name]
                    )
                    refNode = L.u(n, otype=refType)
                    refNode = refNode[0] if refNode else None
                else:
                    refNode = n
                if refNode is not None:
                    value = fsNamev(refNode)

                value = None if value in noneValues else htmlEsc(value or &#34;&#34;)
                if value is not None:
                    value = value.replace(&#34;\n&#34;, &#34;&lt;br/&gt;&#34;)
                    isBare = i &lt; bFeatures
                    isExtra = i &gt;= nbFeatures
                    if (
                        isExtra
                        and not queryFeatures
                        or not isExtra
                        and not standardFeatures
                    ):
                        continue
                    nameRep = &#34;&#34; if isBare else f&#39;&lt;span class=&#34;f&#34;&gt;{name}=&lt;/span&gt;&#39;
                    titleRep = f&#39;title=&#34;{name}&#34;&#39; if isBare else &#34;&#34;
                    xCls = &#34;xft&#34; if isExtra else &#34;&#34;
                    featurePart += (
                        f&#39;&lt;span class=&#34;{name.lower()} {xCls}&#34; {titleRep}&gt;&#39;
                        f&#34;{nameRep}{value}&lt;/span&gt;&#34;
                    )
    if not featurePart:
        return &#34;&#34;

    return f&#34;&lt;div class=&#39;features&#39;&gt;{featurePart}&lt;/div&gt;&#34;


def loadCss(app):
    &#34;&#34;&#34;The CSS is looked up and then loaded into a notebook if we are not
    running in the TF browser,
    else the CSS is returned.
    &#34;&#34;&#34;

    _browse = app._browse
    aContext = app.context
    css = aContext.css

    if _browse:
        return css

    cssPath = (
        f&#34;{os.path.dirname(os.path.dirname(os.path.abspath(__file__)))}&#34;
        f&#34;{SERVER_DISPLAY_BASE}&#34;
    )
    genericCss = &#34;&#34;
    for cssFile in SERVER_DISPLAY:
        with open(f&#34;{cssPath}/{cssFile}&#34;, encoding=&#34;utf8&#34;) as fh:
            genericCss += fh.read()

    tableCss = &#34;tr.tf, td.tf, th.tf { text-align: left ! important;}&#34;
    dh(f&#34;&lt;style&gt;&#34; + tableCss + genericCss + css + &#34;&lt;/style&gt;&#34;)


def getRefMember(app, tup, dContext):
    api = app.api
    otypeRank = api.otypeRank
    fOtypev = api.F.otype.v

    minRank = None
    minN = None
    for n in tup:
        nType = fOtypev(n)
        rank = otypeRank[nType]
        if minRank is None or rank &lt; minRank:
            minRank = rank
            minN = n
            if minRank == 0:
                break

    return (tup[0] if tup else None) if minN is None else minN</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.applib.display.depthExceeded"><code class="name flex">
<span>def <span class="ident">depthExceeded</span></span>(<span>level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depthExceeded(level):
    if level &gt; LIMIT_DISPLAY_DEPTH:
        console(&#34;DISPLAY: maximal depth exceeded: {LIMIT_DISPLAY_DEPTH}&#34;, error=True)
        return True
    return False</code></pre>
</details>
</dd>
<dt id="tf.applib.display.displayApi"><code class="name flex">
<span>def <span class="ident">displayApi</span></span>(<span>app, silent)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the display API.</p>
<p>The display API provides methods to generate styled representations
of pieces of corpus texts in their relevant structures.
The main end-user functions are <code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a>(node)</code> and <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a>(node)</code>.</p>
<p><code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain()</a></code> focuses on the plain text, <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code> focuses on structure
and feature display.</p>
<p>Related are <code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple()</a></code> and <code><a title="tf.applib.display.prettyTuple" href="#tf.applib.display.prettyTuple">prettyTuple()</a></code> that work for tuples
instead of nodes.</p>
<p>And further there are <code><a title="tf.applib.display.show" href="#tf.applib.display.show">show()</a></code> and <code><a title="tf.applib.display.table" href="#tf.applib.display.table">table()</a></code>, that work
with iterables of tuples of nodes (e.g. query results).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>obj</code></dt>
<dd>The high-level API object</dd>
</dl>
<p>silent:
The verbosity mode to perform this operation in.
Normally it is the same as for the app, but when we do an <code>A.reuse()</code>
we force <code>silent=True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displayApi(app, silent):
    &#34;&#34;&#34;Produce the display API.

    The display API provides methods to generate styled representations
    of pieces of corpus texts in their relevant structures.
    The main end-user functions are `plain(node)` and `pretty(node)`.

    `plain()` focuses on the plain text, `pretty()` focuses on structure
    and feature display.

    Related are `plainTuple()` and `prettyTuple()` that work for tuples
    instead of nodes.

    And further there are `show()` and `table()`, that work
    with iterables of tuples of nodes (e.g. query results).

    Parameters
    ----------
    app: obj
        The high-level API object
    silent:
        The verbosity mode to perform this operation in.
        Normally it is the same as for the app, but when we do an `A.reuse()`
        we force `silent=True`.
    &#34;&#34;&#34;

    app.export = types.MethodType(export, app)
    app.table = types.MethodType(table, app)
    app.plainTuple = types.MethodType(plainTuple, app)
    app.plain = types.MethodType(plain, app)
    app.show = types.MethodType(show, app)
    app.prettyTuple = types.MethodType(prettyTuple, app)
    app.pretty = types.MethodType(pretty, app)
    app.loadCss = types.MethodType(loadCss, app)
    app.displaySetup = types.MethodType(displaySetup, app)
    app.displayReset = types.MethodType(displayReset, app)

    app.display = DisplaySettings(app)
    if not app._browse:
        app.loadCss()</code></pre>
</details>
</dd>
<dt id="tf.applib.display.displayReset"><code class="name flex">
<span>def <span class="ident">displayReset</span></span>(<span>app, *options)</span>
</code></dt>
<dd>
<div class="desc"><p>Restore display parameters to their defaults.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>list</code>, optional <code>[]</code></dt>
<dd>If present, only restore these options to their defaults.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displayReset(app, *options):
    &#34;&#34;&#34;Restore display parameters to their defaults.

    Parameters
    ----------
    options: list, optional `[]`
        If present, only restore these options to their defaults.
    &#34;&#34;&#34;

    display = app.display

    display.reset(*options)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.displaySetup"><code class="name flex">
<span>def <span class="ident">displaySetup</span></span>(<span>app, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up all display parameters.</p>
<p>The display parameters are given default values, unless they are overriden
by <code>options</code>.</p>
<div class="admonition hint">
<p class="admonition-title">corpus settings</p>
<p>The defaults themselves come from the corpus settings, which are influenced
by the <code>config.yaml</code> file, if it exists.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Explicit values for selected options that act as overrides of the defaults.
A list of all available options is in
<code><a title="tf.applib.displaysettings.DisplaySettings" href="displaysettings.html#tf.applib.displaysettings.DisplaySettings">DisplaySettings</a></code>
.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displaySetup(app, **options):
    &#34;&#34;&#34;Set up all display parameters.

    The display parameters are given default values, unless they are overriden
    by `options`.

    !!! hint &#34;corpus settings&#34;
        The defaults themselves come from the corpus settings, which are influenced
        by the `config.yaml` file, if it exists.

    Parameters
    ----------
    options: dict
        Explicit values for selected options that act as overrides of the defaults.
        A list of all available options is in
        `tf.applib.displaysettings.DisplaySettings`
        .
    &#34;&#34;&#34;

    display = app.display

    display.setup(**options)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.doPassage"><code class="name flex">
<span>def <span class="ident">doPassage</span></span>(<span>dContext, i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doPassage(dContext, i):
    withPassage = dContext.withPassage
    return withPassage is not True and withPassage and i + 1 in withPassage</code></pre>
</details>
</dd>
<dt id="tf.applib.display.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>app, tuples, toDir=None, toFile='results.tsv', **options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(app, tuples, toDir=None, toFile=&#34;results.tsv&#34;, **options):
    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    fmt = dContext.fmt
    condenseType = dContext.condenseType
    tupleFeatures = dContext.tupleFeatures

    if toDir is None:
        toDir = os.path.expanduser(DOWNLOADS)
        if not os.path.exists(toDir):
            os.makedirs(toDir, exist_ok=True)
    toPath = f&#34;{toDir}/{toFile}&#34;

    resultsX = getResultsX(app, tuples, tupleFeatures, condenseType, fmt=fmt,)

    with open(toPath, &#34;w&#34;, encoding=&#34;utf_16_le&#34;) as fh:
        fh.write(
            &#34;\ufeff&#34;
            + &#34;&#34;.join(
                (&#34;\t&#34;.join(&#34;&#34; if t is None else str(t) for t in tup) + &#34;\n&#34;)
                for tup in resultsX
            )
        )</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getBigType"><code class="name flex">
<span>def <span class="ident">getBigType</span></span>(<span>app, dContext, nType, otypeRank)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBigType(app, dContext, nType, otypeRank):
    api = app.api
    T = api.T

    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    full = dContext.full
    condenseType = dContext.condenseType

    isBig = False
    if not full:
        if sectionTypeSet and nType in sectionTypeSet | structureTypeSet:
            if condenseType is None or otypeRank[nType] &gt; otypeRank[condenseType]:
                isBig = True
        elif condenseType is not None and otypeRank[nType] &gt; otypeRank[condenseType]:
            isBig = True
    return isBig</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getBoundaryResult"><code class="name flex">
<span>def <span class="ident">getBoundaryResult</span></span>(<span>isPretty, api, oContext, inSlots, n, nType, chunk=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBoundaryResult(isPretty, api, oContext, inSlots, n, nType, chunk=None):
    ltr = oContext.ltr
    startCls = &#34;r&#34; if ltr == &#34;rtl&#34; else &#34;l&#34;
    endCls = &#34;l&#34; if ltr == &#34;rtl&#34; else &#34;r&#34;

    boundaryCls = &#34;&#34;

    nSlots = getSlots(api, n)

    chunkSlots = getSlots(api, chunk) &amp; nSlots if chunk else None

    slots = inSlots &amp; (chunkSlots if chunk else nSlots)

    if not slots:
        return None

    nStart = min(nSlots)
    nEnd = max(nSlots)
    tStart = min(slots)
    tEnd = max(slots)

    boundaryCls = &#34;&#34;

    if chunk:
        chStart = min(chunkSlots)
        chEnd = max(chunkSlots)

    kind = &#34;&#34;
    if nStart &lt; tStart:
        kind = (
            &#34;&#34;
            if ((tStart - 1 not in nSlots) or (chunk and chStart == tStart))
            else &#34;no&#34;
        )
        boundaryCls += f&#34; {startCls}{kind}&#34;
    if nEnd &gt; tEnd:
        kind = &#34;&#34; if ((tEnd + 1 not in nSlots) or (chunk and chEnd == tEnd)) else &#34;no&#34;
        boundaryCls += f&#34; {endCls}{kind}&#34;

    return (boundaryCls, slots)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getChildren"><code class="name flex">
<span>def <span class="ident">getChildren</span></span>(<span>app, isPretty, dContext, oContext, n, nType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getChildren(app, isPretty, dContext, oContext, n, nType):
    api = app.api
    L = api.L
    F = api.F
    otypeRank = api.otypeRank
    sortNodes = api.sortNodes
    slotType = F.otype.slotType
    fOtypev = F.otype.v

    aContext = app.context
    verseTypes = aContext.verseTypes
    childType = aContext.childType
    baseTypes = dContext.baseTypes
    subBaseTypes = dContext.subBaseTypes
    childrenCustom = aContext.childrenCustom
    showVerseInTuple = aContext.showVerseInTuple

    inTuple = oContext.inTuple

    full = dContext.full

    isBigType = (
        inTuple
        if not isPretty and nType in verseTypes and not showVerseInTuple
        else getBigType(app, dContext, nType, otypeRank)
    )

    if isBigType and not full:
        children = ()
    elif nType in childType:
        childType = childType[nType]
        children = L.i(n, otype=childType)
        if nType in childrenCustom:
            (condition, method, add) = childrenCustom[nType]
            if condition(n):
                others = method(n)
                if add:
                    children += others
                else:
                    children = others

            children = sortNodes(set(children) - {n})
    else:
        children = L.i(n)
    if isPretty and baseTypes and baseTypes != {slotType}:
        refSet = set(children)
        children = tuple(
            ch
            for ch in children
            if (fOtypev(ch) not in subBaseTypes)
            and not (set(L.u(ch, otype=baseTypes)) &amp; refSet)
        )
    return children</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getChunkedType"><code class="name flex">
<span>def <span class="ident">getChunkedType</span></span>(<span>app, nContext, n, outer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getChunkedType(app, nContext, n, outer):

    aContext = app.context
    isChunkOf = aContext.isChunkOf
    chunkedTypes = aContext.chunkedTypes

    nType = nContext.nType

    if not outer and nType not in chunkedTypes and nType in isChunkOf:
        api = app.api
        L = api.L
        chunkedType = isChunkOf[nType]
        sn = L.u(n, otype=chunkedType)
        if sn:
            E = api.E
            nSlots = nContext.slots
            sownSlots = frozenset(E.oslots.s(sn[0]))
            return (
                sn[0],
                nContext._replace(slots=nSlots &amp; sownSlots),
            )

    return None</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getFeatures"><code class="name flex">
<span>def <span class="ident">getFeatures</span></span>(<span>app, dContext, n, nType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFeatures(app, dContext, n, nType):
    api = app.api
    L = api.L
    Fs = api.Fs

    aContext = app.context
    featuresBare = aContext.featuresBare
    features = aContext.features

    dFeatures = dContext.features
    dFeaturesIndirect = dContext.featuresIndirect
    queryFeatures = dContext.queryFeatures
    standardFeatures = dContext.standardFeatures
    suppress = dContext.suppress
    noneValues = dContext.noneValues

    (theseFeatures, indirect) = features.get(nType, ((), {}))
    (theseFeaturesBare, indirectBare) = featuresBare.get(nType, ((), {}))

    # a feature can be nType:feature
    # do a L.u(n, otype=nType)[0] and take the feature from there

    givenFeatureSet = set(theseFeatures) | set(theseFeaturesBare)
    xFeatures = tuple(
        f for f in dFeatures if not standardFeatures or f not in givenFeatureSet
    )
    featureList = tuple(theseFeaturesBare + theseFeatures) + xFeatures
    bFeatures = len(theseFeaturesBare)
    nbFeatures = len(theseFeaturesBare) + len(theseFeatures)

    featurePart = &#34;&#34;

    if standardFeatures or queryFeatures:
        for (i, name) in enumerate(featureList):
            if name not in suppress:
                fsName = Fs(name)
                if fsName is None:
                    continue
                fsNamev = fsName.v

                value = None
                if (
                    name in dFeaturesIndirect
                    or name in indirectBare
                    or name in indirect
                ):
                    refType = (
                        dFeaturesIndirect[name]
                        if name in dFeaturesIndirect
                        else indirectBare[name]
                        if name in indirectBare
                        else indirect[name]
                    )
                    refNode = L.u(n, otype=refType)
                    refNode = refNode[0] if refNode else None
                else:
                    refNode = n
                if refNode is not None:
                    value = fsNamev(refNode)

                value = None if value in noneValues else htmlEsc(value or &#34;&#34;)
                if value is not None:
                    value = value.replace(&#34;\n&#34;, &#34;&lt;br/&gt;&#34;)
                    isBare = i &lt; bFeatures
                    isExtra = i &gt;= nbFeatures
                    if (
                        isExtra
                        and not queryFeatures
                        or not isExtra
                        and not standardFeatures
                    ):
                        continue
                    nameRep = &#34;&#34; if isBare else f&#39;&lt;span class=&#34;f&#34;&gt;{name}=&lt;/span&gt;&#39;
                    titleRep = f&#39;title=&#34;{name}&#34;&#39; if isBare else &#34;&#34;
                    xCls = &#34;xft&#34; if isExtra else &#34;&#34;
                    featurePart += (
                        f&#39;&lt;span class=&#34;{name.lower()} {xCls}&#34; {titleRep}&gt;&#39;
                        f&#34;{nameRep}{value}&lt;/span&gt;&#34;
                    )
    if not featurePart:
        return &#34;&#34;

    return f&#34;&lt;div class=&#39;features&#39;&gt;{featurePart}&lt;/div&gt;&#34;</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getLtr"><code class="name flex">
<span>def <span class="ident">getLtr</span></span>(<span>app, dContext)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLtr(app, dContext):
    aContext = app.context
    direction = aContext.direction

    fmt = dContext.fmt or DEFAULT_FORMAT

    return (
        &#34;rtl&#34;
        if direction == &#34;rtl&#34; and (f&#34;{ORIG}-&#34; in fmt or f&#34;-{ORIG}&#34; in fmt)
        else (&#34;&#34; if direction == &#34;ltr&#34; else &#34;ltr&#34;)
    )</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getNodePart"><code class="name flex">
<span>def <span class="ident">getNodePart</span></span>(<span>app, isPretty, dContext, n, nType, isSlot, outer, isHl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNodePart(app, isPretty, dContext, n, nType, isSlot, outer, isHl):
    _browse = app._browse

    Fs = app.api.Fs

    aContext = app.context
    lineNumberFeature = aContext.lineNumberFeature
    allowInfo = isPretty or outer is None or outer or isHl

    withNodes = dContext.withNodes and outer is not None
    withTypes = dContext.withTypes and outer is not None
    prettyTypes = dContext.prettyTypes and outer is not None
    lineNumbers = dContext.lineNumbers and outer is not None

    num = &#34;&#34;
    if withNodes and allowInfo:
        num = n

    ntp = &#34;&#34;
    if (withTypes or isPretty and prettyTypes) and not isSlot and allowInfo:
        ntp = nType

    line = &#34;&#34;
    if lineNumbers and allowInfo:
        feat = lineNumberFeature.get(nType, None)
        if feat:
            line = Fs(feat).v(n)
        if line:
            line = f&#34;@{line}&#34; if line else &#34;&#34;

    elemb = &#39;a href=&#34;#&#34;&#39; if _browse else &#34;span&#34;
    eleme = &#34;a&#34; if _browse else &#34;span&#34;
    sep = &#34;:&#34; if ntp and num else &#34;&#34;

    return (
        f&#39;&lt;{elemb} class=&#34;nd&#34;&gt;{ntp}{sep}{num}{line}&lt;/{eleme}&gt;&#39;
        if ntp or num or line
        else &#34;&#34;
    )</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getPassage"><code class="name flex">
<span>def <span class="ident">getPassage</span></span>(<span>app, isPretty, dContext, oContext, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassage(app, isPretty, dContext, oContext, n):
    withPassage = dContext.withPassage

    if not withPassage:
        return &#34;&#34;

    passage = app.webLink(n, _asString=True)
    return f&#39;&lt;span class=&#34;section ltr&#34;&gt;{passage}{NB}&lt;/span&gt;&#39;</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getRefMember"><code class="name flex">
<span>def <span class="ident">getRefMember</span></span>(<span>app, tup, dContext)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRefMember(app, tup, dContext):
    api = app.api
    otypeRank = api.otypeRank
    fOtypev = api.F.otype.v

    minRank = None
    minN = None
    for n in tup:
        nType = fOtypev(n)
        rank = otypeRank[nType]
        if minRank is None or rank &lt; minRank:
            minRank = rank
            minN = n
            if minRank == 0:
                break

    return (tup[0] if tup else None) if minN is None else minN</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getResultsX"><code class="name flex">
<span>def <span class="ident">getResultsX</span></span>(<span>app, results, features, condenseType, fmt=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getResultsX(app, results, features, condenseType, fmt=None):
    api = app.api
    F = api.F
    Fs = api.Fs
    T = api.T
    fOtype = F.otype.v
    otypeRank = api.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()
    firstResult = results[0]
    nTuple = len(firstResult)
    refColumns = [
        i for (i, n) in enumerate(firstResult) if fOtype(n) not in sectionTypeSet
    ]
    refColumn = refColumns[0] if refColumns else nTuple - 1
    header = [&#34;R&#34;] + [f&#34;S{i}&#34; for i in range(1, sectionDepth + 1)]
    emptyA = []

    featureDict = {i: tuple(f.split()) if type(f) is str else f for (i, f) in features}

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    for j in range(nTuple):
        i = j + 1
        n = firstResult[j]
        nType = fOtype(n)
        header.extend([f&#34;NODE{i}&#34;, f&#34;TYPE{i}&#34;])
        if withText(nType):
            header.append(f&#34;TEXT{i}&#34;)
        header.extend(f&#34;{feature}{i}&#34; for feature in featureDict.get(j, emptyA))
    rows = [tuple(header)]
    for (rm, r) in enumerate(results):
        rn = rm + 1
        row = [rn]
        refN = r[refColumn]
        sparts = T.sectionFromNode(refN)
        nParts = len(sparts)
        section = sparts + ((None,) * (sectionDepth - nParts))
        row.extend(section)
        for j in range(nTuple):
            n = r[j]
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
            row.extend(Fs(feature).v(n) for feature in featureDict.get(j, emptyA))
        rows.append(tuple(row))
    return tuple(rows)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getSlots"><code class="name flex">
<span>def <span class="ident">getSlots</span></span>(<span>api, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSlots(api, n):
    F = api.F
    fOtype = F.otype.v
    slotType = F.otype.slotType
    if fOtype(n) == slotType:
        return frozenset((n,))
    E = api.E
    maxSlot = F.otype.maxSlot
    return frozenset(E.oslots.data[n - maxSlot - 1])</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getText"><code class="name flex">
<span>def <span class="ident">getText</span></span>(<span>app, isPretty, n, nType, outer, first, last, level, passage, descend, dContext=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getText(
    app, isPretty, n, nType, outer, first, last, level, passage, descend, dContext=None
):
    T = app.api.T
    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    aContext = app.context
    templates = aContext.labels if isPretty else aContext.templates

    fmt = None if dContext is None else dContext.fmt
    standardFeatures = True if dContext is None else dContext.standardFeatures
    isHtml = False if dContext is None else dContext.isHtml
    suppress = set() if dContext is None else dContext.suppress

    (tpl, feats) = templates[nType]

    tplFilled = (
        (
            (
                &#39;&lt;span class=&#34;section&#34;&gt;&#39;
                + (NB if passage else app.sectionStrFromNode(n))
                + &#34;&lt;/span&gt;&#34;
            )
            if nType in sectionTypeSet
            else f&#39;&lt;span class=&#34;structure&#34;&gt;{app.structureStrFromNode(n)}&lt;/span&gt;&#39;
            if nType in structureTypeSet
            else htmlSafe(
                T.text(
                    n,
                    fmt=fmt,
                    descend=descend,
                    outer=outer,
                    first=first,
                    last=last,
                    level=level,
                ),
                isHtml,
            )
        )
        if tpl is True
        else (
            tpl.format(
                **{feat: getValue(app, n, nType, feat, suppress) for feat in feats}
            )
            if standardFeatures
            else &#34;&#34;
        )
    )
    return tplFilled</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getTextCls"><code class="name flex">
<span>def <span class="ident">getTextCls</span></span>(<span>app, fmt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTextCls(app, fmt):
    aContext = app.context
    formatCls = aContext.formatCls
    defaultClsOrig = aContext.defaultClsOrig

    return formatCls.get(fmt or DEFAULT_FORMAT, defaultClsOrig)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>app, n, nType, feat, suppress)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValue(app, n, nType, feat, suppress):
    F = app.api.F
    Fs = app.api.Fs

    aContext = app.context
    transform = aContext.transform
    if feat in suppress:
        val = &#34;&#34;
    else:
        featObj = Fs(feat) if hasattr(F, feat) else None
        val = htmlEsc(featObj.v(n)) if featObj else None
        modifier = transform.get(nType, {}).get(feat, None)
        if modifier:
            val = modifier(n, val)
    return f&#39;&lt;span title=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#39;</code></pre>
</details>
</dd>
<dt id="tf.applib.display.htmlSafe"><code class="name flex">
<span>def <span class="ident">htmlSafe</span></span>(<span>text, isHtml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def htmlSafe(text, isHtml):
    return text if isHtml else htmlEsc(text)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.loadCss"><code class="name flex">
<span>def <span class="ident">loadCss</span></span>(<span>app)</span>
</code></dt>
<dd>
<div class="desc"><p>The CSS is looked up and then loaded into a notebook if we are not
running in the TF browser,
else the CSS is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadCss(app):
    &#34;&#34;&#34;The CSS is looked up and then loaded into a notebook if we are not
    running in the TF browser,
    else the CSS is returned.
    &#34;&#34;&#34;

    _browse = app._browse
    aContext = app.context
    css = aContext.css

    if _browse:
        return css

    cssPath = (
        f&#34;{os.path.dirname(os.path.dirname(os.path.abspath(__file__)))}&#34;
        f&#34;{SERVER_DISPLAY_BASE}&#34;
    )
    genericCss = &#34;&#34;
    for cssFile in SERVER_DISPLAY:
        with open(f&#34;{cssPath}/{cssFile}&#34;, encoding=&#34;utf8&#34;) as fh:
            genericCss += fh.read()

    tableCss = &#34;tr.tf, td.tf, th.tf { text-align: left ! important;}&#34;
    dh(f&#34;&lt;style&gt;&#34; + tableCss + genericCss + css + &#34;&lt;/style&gt;&#34;)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.note"><code class="name flex">
<span>def <span class="ident">note</span></span>(<span>isPretty, oContext, n, nType, first, last, level, *labels, **info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def note(isPretty, oContext, n, nType, first, last, level, *labels, **info):
    if not oContext.explain:
        return
    block = QUAD * level
    kindRep = &#34;pretty&#34; if isPretty else &#34;plain&#34;
    labelRep = &#34; &#34;.join(str(lab) for lab in labels)
    console(f&#34;{block}&lt;{level}&gt;{kindRep}({nType} {n}): {labelRep}&#34;, error=True)
    for (k, v) in info.items():
        console(f&#34;{block}&lt;{level}&gt;      {k:&lt;10} = {repr(v)}&#34;, error=True)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.plain"><code class="name flex">
<span>def <span class="ident">plain</span></span>(<span>app, n, explain=False, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the plain text of a node.</p>
<p><em>Plain</em> is oppsed to <em>pretty</em>; <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code> shows the underlying structure of the
text material associated with a node, plain just shows the linear text.</p>
<p>The result of plain is formatted text, the text is styled depending on
the chosen text format. Text corresponding to sub nodes can be selectively
highlighted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The application object, it is normally referenced by the variable <code>A</code>.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>Node</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see
<code>tf.applib.displaysettings.DISPLAY_OPTIONS</code> and
<code>tf.applib.displaysettings.INTERFACE_OPTIONS</code>.</dd>
<dt><strong><code>_inTuple</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the result is meant too end up in a table cell produced by
<code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple()</a></code>. In that case some extra node types count as big and will
not be displayed in full.</dd>
<dt><strong><code>_asString</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to deliver the result as a HTML string or to display it directly
inside a notebook. When the TF-browser uses this function it needs the
HTML string.</dd>
<dt><strong><code>explain</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to print a trace of which nodes have been visited and how these
calls have contributed to the end result.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plain(app, n, _inTuple=False, _asString=False, explain=False, **options):
    &#34;&#34;&#34;Display the plain text of a node.

    *Plain* is oppsed to *pretty*; `pretty` shows the underlying structure of the
    text material associated with a node, plain just shows the linear text.

    The result of plain is formatted text, the text is styled depending on
    the chosen text format. Text corresponding to sub nodes can be selectively
    highlighted.

    Parameters
    ----------
    app: object
        The application object, it is normally referenced by the variable `A`.
    n: integer
        Node
    options: dict
        Display options, see
        `tf.applib.displaysettings.DISPLAY_OPTIONS` and
        `tf.applib.displaysettings.INTERFACE_OPTIONS`.
    _inTuple: boolean, optional `False`
        Whether the result is meant too end up in a table cell produced by
        `plainTuple`. In that case some extra node types count as big and will
        not be displayed in full.
    _asString: boolean, optional `False`
        Whether to deliver the result as a HTML string or to display it directly
        inside a notebook. When the TF-browser uses this function it needs the
        HTML string.
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;plain&#34;, options):
        return &#34;&#34;

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml

    _browse = app._browse
    api = app.api

    ltr = getLtr(app, dContext)
    textCls = getTextCls(app, fmt)
    slots = getSlots(api, n)

    oContext = OuterContext(ltr, textCls, slots, _inTuple, not not explain)
    passage = getPassage(app, True, dContext, oContext, n)
    rep = _doPlain(
        app, dContext, oContext, None, n, True, True, True, 0, passage, [], {}, {}
    )
    sep = &#34; &#34; if passage and rep else &#34;&#34;

    result = passage + sep + rep

    if _browse or _asString:
        return result
    dh(result)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.plainTuple"><code class="name flex">
<span>def <span class="ident">plainTuple</span></span>(<span>app, tup, seq, item='result', position=None, opened=False, **options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plainTuple(
    app, tup, seq, item=RESULT, position=None, opened=False, _asString=False, **options
):
    display = app.display

    if not display.check(&#34;plainTuple&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    fOtype = F.otype.v
    _browse = app._browse

    dContext = display.get(options)
    condenseType = dContext.condenseType
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    withPassage = dContext.withPassage
    skipCols = dContext.skipCols

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if withPassage is True:
        passageNode = getRefMember(app, tup, dContext)
        passageRef = (
            &#34;&#34;
            if passageNode is None
            else app._sectionLink(passageNode)
            if _browse
            else app.webLink(passageNode, _asString=True)
        )
        passageRef = f&#39;&lt;span class=&#34;section ltr&#34;&gt;{passageRef}&lt;/span&gt;&#39;
    else:
        passageRef = &#34;&#34;

    newOptions = display.consume(options, &#34;withPassage&#34;)
    newOptionsH = display.consume(options, &#34;withPassage&#34;, &#34;highlights&#34;)

    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if _browse:
        prettyRep = (
            prettyTuple(app, tup, seq, withPassage=False, **newOptions)
            if opened
            else &#34;&#34;
        )
        current = &#34;focus&#34; if seq == position else &#34;&#34;
        attOpen = &#34;open &#34; if opened else &#34;&#34;
        tupSeq = &#34;,&#34;.join(str(n) for n in tup)
        if withPassage is True:
            sparts = T.sectionFromNode(passageNode, fillup=True)
            passageAtt = &#34; &#34;.join(
                f&#39;sec{i}=&#34;{sparts[i] if i &lt; len(sparts) else &#34;&#34;}&#34;&#39; for i in range(3)
            )
        else:
            passageAtt = &#34;&#34;

        plainRep = &#34;&#34;.join(
            &#34;&lt;span&gt;&#34;
            + mdEsc(
                app.plain(
                    n,
                    _inTuple=True,
                    withPassage=doPassage(dContext, i),
                    highlights=highlights,
                    **newOptionsH,
                )
            )
            + &#34;&lt;/span&gt;&#34;
            for (i, n) in enumerate(tup)
        )
        html = (
            f&#39;&lt;details class=&#34;pretty dtrow {current}&#34; seq=&#34;{seq}&#34; {attOpen}&gt;&#39;
            f&#34;&lt;summary&gt;&#34;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;pq fa fa-solar-panel fa-xs&#34;&#39;
            f&#39; title=&#34;show in context&#34; {passageAtt}&gt;&lt;/a&gt;&#39;
            f&#39;&lt;a href=&#34;#&#34; class=&#34;sq&#34; tup=&#34;{tupSeq}&#34;&gt;{seq}&lt;/a&gt;&#39;
            f&#34; {passageRef} {plainRep}&#34;
            f&#34;&lt;/summary&gt;&#34;
            f&#39;&lt;div class=&#34;pretty&#34;&gt;{prettyRep}&lt;/div&gt;&#39;
            f&#34;&lt;/details&gt;&#34;
        )
        return html

    html = [str(seq)]
    if withPassage is True:
        html.append(passageRef)
    for (i, n) in enumerate(tup):
        html.append(
            app.plain(
                n,
                _inTuple=True,
                _asString=True,
                withPassage=doPassage(dContext, i),
                highlights=highlights,
                **newOptionsH,
            )
        )
    html = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;td class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/td&gt;&lt;td class=&#34;tf&#34;&gt;&#39;.join(html)
        + &#34;&lt;/td&gt;&lt;/tr&gt;&#34;
    )
    if _asString:
        return html

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;
    head = (
        f&#39;&lt;tr class=&#34;tf&#34;&gt;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;
        + &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
        + f&#34;&lt;/th&gt;&lt;/tr&gt;&#34;
    )
    html = f&#34;&lt;table&gt;&#34; + head + &#34;&#34;.join(html) + &#34;&lt;/table&gt;&#34;

    dh(html)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.pretty"><code class="name flex">
<span>def <span class="ident">pretty</span></span>(<span>app, n, explain=False, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the structure associated with a node.</p>
<p><em>Plain</em> is oppsed to <em>pretty</em>; <code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty()</a></code> shows the underlying structure of the
text material associated with a node, plain just shows the linear text.</p>
<p>The result of pretty is a formatted display of pieces of text together with
extra features and their values
Text corresponding to sub nodes can be selectively highlighted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The application object, it is normally referenced by the variable <code>A</code>.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>Node</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Display options, see <code><a title="tf.applib.displaysettings.DisplaySettings" href="displaysettings.html#tf.applib.displaysettings.DisplaySettings">DisplaySettings</a></code></dd>
<dt><strong><code>explain</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to print a trace of which nodes have been visited and how these
calls have contributed to the end result.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty(app, n, explain=False, **options):
    &#34;&#34;&#34;Display the structure associated with a node.

    *Plain* is oppsed to *pretty*; `pretty` shows the underlying structure of the
    text material associated with a node, plain just shows the linear text.

    The result of pretty is a formatted display of pieces of text together with
    extra features and their values
    Text corresponding to sub nodes can be selectively highlighted.

    Parameters
    ----------
    app: object
        The application object, it is normally referenced by the variable `A`.
    n: integer
        Node
    options: dict
        Display options, see `tf.applib.displaysettings.DisplaySettings`
    explain: boolean, optional `False`
        Whether to print a trace of which nodes have been visited and how these
        calls have contributed to the end result.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;pretty&#34;, options):
        return &#34;&#34;

    _browse = app._browse

    aContext = app.context
    formatHtml = aContext.formatHtml

    dContext = display.get(options)
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    tupleFeatures = dContext.tupleFeatures
    extraFeatures = dContext.extraFeatures
    fmt = dContext.fmt

    dContext.isHtml = fmt in formatHtml
    dContext.features = sorted(
        flattenToSet(extraFeatures[0]) | flattenToSet(tupleFeatures)
    )
    dContext.featuresIndirect = extraFeatures[1]

    api = app.api
    F = api.F
    L = api.L
    otypeRank = api.otypeRank

    ltr = getLtr(app, dContext)
    textCls = getTextCls(app, fmt)

    containerN = None

    nType = F.otype.v(n)
    if condensed and condenseType:
        if nType == condenseType:
            containerN = n
        elif otypeRank[nType] &lt; otypeRank[condenseType]:
            ups = L.u(n, otype=condenseType)
            if ups:
                containerN = ups[0]

    slots = (
        getSlots(api, n)
        if not condensed or not condenseType or containerN is None
        else getSlots(api, containerN)
    )

    oContext = OuterContext(ltr, textCls, slots, False, not not explain)
    passage = getPassage(app, False, dContext, oContext, n)

    html = []

    _doPretty(app, dContext, oContext, None, n, True, True, True, 0, html, {}, {})

    htmlStr = passage + &#34;&#34;.join(html)
    if _browse:
        return htmlStr
    dh(htmlStr)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.prettyTuple"><code class="name flex">
<span>def <span class="ident">prettyTuple</span></span>(<span>app, tup, seq, item='result', **options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prettyTuple(app, tup, seq, item=RESULT, **options):
    display = app.display

    if not display.check(&#34;prettyTuple&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    colorMap = dContext.colorMap
    highlights = dContext.highlights
    condenseType = dContext.condenseType
    condensed = dContext.condensed
    skipCols = dContext.skipCols

    _browse = app._browse

    if skipCols:
        tup = tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)

    if len(tup) == 0:
        if _browse:
            return &#34;&#34;
        else:
            return

    api = app.api
    sortKey = api.sortKey

    containers = {tup[0]} if condensed else condenseSet(api, tup, condenseType)
    highlights = getTupleHighlights(api, tup, highlights, colorMap, condenseType)

    if not _browse:
        dh(f&#34;&lt;p&gt;&lt;b&gt;{item}&lt;/b&gt; &lt;i&gt;{seq}&lt;/i&gt;&lt;/p&gt;&#34;)
    if _browse:
        html = []
    for t in sorted(containers, key=sortKey):
        h = app.pretty(
            t, highlights=highlights, **display.consume(options, &#34;highlights&#34;),
        )
        if _browse:
            html.append(h)
    if _browse:
        return &#34;&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.setSubBaseTypes"><code class="name flex">
<span>def <span class="ident">setSubBaseTypes</span></span>(<span>aContext, dContext, slotType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSubBaseTypes(aContext, dContext, slotType):
    descendantType = aContext.descendantType
    isChunkOf = aContext.isChunkOf
    baseTypes = dContext.baseTypes

    chunkBaseTypes = {ct for (ct, t) in isChunkOf.items() if t in baseTypes}
    subBaseTypes = set()

    if baseTypes and baseTypes != {slotType}:
        for bt in baseTypes:
            if bt in descendantType:
                subBaseTypes |= descendantType[bt]
    dContext.subBaseTypes = subBaseTypes - baseTypes - chunkBaseTypes</code></pre>
</details>
</dd>
<dt id="tf.applib.display.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>app, tuples, **options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(app, tuples, **options):
    display = app.display

    if not display.check(&#34;show&#34;, options):
        return &#34;&#34;

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    api = app.api
    F = api.F

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_SHOW, item):
        item = F.otype.v(tup[0]) if condensed and condenseType else RESULT
        prettyTuple(app, tup, i, item=item, skipCols=set(), **newOptions)</code></pre>
</details>
</dd>
<dt id="tf.applib.display.table"><code class="name flex">
<span>def <span class="ident">table</span></span>(<span>app, tuples, **options)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def table(app, tuples, _asString=False, **options):
    display = app.display

    if not display.check(&#34;table&#34;, options):
        return &#34;&#34;

    api = app.api
    F = api.F
    fOtype = F.otype.v

    dContext = display.get(options)
    end = dContext.end
    start = dContext.start
    withPassage = dContext.withPassage
    condensed = dContext.condensed
    condenseType = dContext.condenseType
    skipCols = dContext.skipCols

    if skipCols:
        tuples = tuple(
            tuple(x for (i, x) in enumerate(tup) if i + 1 not in skipCols)
            for tup in tuples
        )

    item = condenseType if condensed else RESULT

    if condensed:
        tuples = condense(api, tuples, condenseType, multiple=True)

    passageHead = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;p&#39; if withPassage is True else &#34;&#34;

    html = []
    one = True

    newOptions = display.consume(options, &#34;skipCols&#34;)

    for (i, tup) in tupleEnum(tuples, start, end, LIMIT_TABLE, item):
        if one:
            heads = &#39;&lt;/th&gt;&lt;th class=&#34;tf&#34;&gt;&#39;.join(fOtype(n) for n in tup)
            html.append(
                f&#39;&lt;tr class=&#34;tf&#34;&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;n{passageHead}&lt;/th&gt;&#39;
                f&#39;&lt;th class=&#34;tf&#34;&gt;{heads}&lt;/th&gt;&#39;
                f&#34;&lt;/tr&gt;&#34;
            )
            one = False
        html.append(
            plainTuple(
                app,
                tup,
                i,
                item=item,
                position=None,
                opened=False,
                _asString=True,
                skipCols=set(),
                **newOptions,
            )
        )
    html = &#34;&lt;table&gt;&#34; + &#34;\n&#34;.join(html) + &#34;&lt;/table&gt;&#34;
    if _asString:
        return html
    dh(html)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.applib.display.NodeContext"><code class="flex name class">
<span>class <span class="ident">NodeContext</span></span>
<span>(</span><span>slotType, nType, isSlot, isSlotOrDescend, descend, isBaseNonSlot, hasChunks, children, boundaryCls, textCls, hlCls, hlStyle, nodePart, cls, slots, hidden)</span>
</code></dt>
<dd>
<div class="desc"><p>Node properties during plain() or pretty().</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tf.applib.display.NodeContext.boundaryCls"><code class="name">var <span class="ident">boundaryCls</span></code></dt>
<dd>
<div class="desc"><p>Css class that represent the kinds of boundaries for this node. Nodes can have a firm of dotted left/right boundary, or no boundary at all.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><p>The children of the current node.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.cls"><code class="name">var <span class="ident">cls</span></code></dt>
<dd>
<div class="desc"><p>A dict of several classes for the display of the node: for the container, the label, and the children of the node; might be set by prettyCustom</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.descend"><code class="name">var <span class="ident">descend</span></code></dt>
<dd>
<div class="desc"><p>When calling T.text(n, descend=??) for this node, what should we substitute for the ?? ?</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.hasChunks"><code class="name">var <span class="ident">hasChunks</span></code></dt>
<dd>
<div class="desc"><p>Whether the current node has a type that has a related type that corresponds to contiguous chunks that build it.
E.g. in the BHSA the type phrase has a chunk type phrase_atom.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.hidden"><code class="name">var <span class="ident">hidden</span></code></dt>
<dd>
<div class="desc"><p>Whether the outer container and label of the current node should be hidden. This is used to reduce displays by hiding the chunk types of types that have chunks. E.g. in the BHSA: the phrase_atoms can be hidden.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.hlCls"><code class="name">var <span class="ident">hlCls</span></code></dt>
<dd>
<div class="desc"><p>The highlight Css class of the current node.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.hlStyle"><code class="name">var <span class="ident">hlStyle</span></code></dt>
<dd>
<div class="desc"><p>The highlight style attribute of the current node.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.isBaseNonSlot"><code class="name">var <span class="ident">isBaseNonSlot</span></code></dt>
<dd>
<div class="desc"><p>Whether the current node has a type that is currently a baseType, i.e. a type where a pretty display should stop unfolding. No need to put the slot type in this set.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.isSlot"><code class="name">var <span class="ident">isSlot</span></code></dt>
<dd>
<div class="desc"><p>Whether the current node is a slot node.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.isSlotOrDescend"><code class="name">var <span class="ident">isSlotOrDescend</span></code></dt>
<dd>
<div class="desc"><p>Whether the current node is a slot node or has a type to which the current text format should descend. This type is determined by the current text format.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.nType"><code class="name">var <span class="ident">nType</span></code></dt>
<dd>
<div class="desc"><p>The node type of the current node.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.nodePart"><code class="name">var <span class="ident">nodePart</span></code></dt>
<dd>
<div class="desc"><p>The node type/number insofar it has to be displayed for the current node</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.slotType"><code class="name">var <span class="ident">slotType</span></code></dt>
<dd>
<div class="desc"><p>The slot type of the data set.</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.slots"><code class="name">var <span class="ident">slots</span></code></dt>
<dd>
<div class="desc"><p>Set of slots that must be displayed for this node</p></div>
</dd>
<dt id="tf.applib.display.NodeContext.textCls"><code class="name">var <span class="ident">textCls</span></code></dt>
<dd>
<div class="desc"><p>The text Css class of the current node.</p></div>
</dd>
</dl>
</dd>
<dt id="tf.applib.display.OuterContext"><code class="flex name class">
<span>class <span class="ident">OuterContext</span></span>
<span>(</span><span>ltr, textCls, slots, inTuple, explain)</span>
</code></dt>
<dd>
<div class="desc"><p>Outer node properties during plain() and pretty(). Only the properties of the node for which the outer call plain() or pretty() has been made, not the nodes encountered during recursion.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tf.applib.display.OuterContext.explain"><code class="name">var <span class="ident">explain</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="tf.applib.display.OuterContext.inTuple"><code class="name">var <span class="ident">inTuple</span></code></dt>
<dd>
<div class="desc"><p>Whether the outer node is displayed as part of a tuple of nodes.</p></div>
</dd>
<dt id="tf.applib.display.OuterContext.ltr"><code class="name">var <span class="ident">ltr</span></code></dt>
<dd>
<div class="desc"><p>writing direction.</p></div>
</dd>
<dt id="tf.applib.display.OuterContext.slots"><code class="name">var <span class="ident">slots</span></code></dt>
<dd>
<div class="desc"><p>Set of slots under the outer node.</p></div>
</dd>
<dt id="tf.applib.display.OuterContext.textCls"><code class="name">var <span class="ident">textCls</span></code></dt>
<dd>
<div class="desc"><p>Css class for full text.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.applib" href="index.html">tf.applib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.applib.display.depthExceeded" href="#tf.applib.display.depthExceeded">depthExceeded</a></code></li>
<li><code><a title="tf.applib.display.displayApi" href="#tf.applib.display.displayApi">displayApi</a></code></li>
<li><code><a title="tf.applib.display.displayReset" href="#tf.applib.display.displayReset">displayReset</a></code></li>
<li><code><a title="tf.applib.display.displaySetup" href="#tf.applib.display.displaySetup">displaySetup</a></code></li>
<li><code><a title="tf.applib.display.doPassage" href="#tf.applib.display.doPassage">doPassage</a></code></li>
<li><code><a title="tf.applib.display.export" href="#tf.applib.display.export">export</a></code></li>
<li><code><a title="tf.applib.display.getBigType" href="#tf.applib.display.getBigType">getBigType</a></code></li>
<li><code><a title="tf.applib.display.getBoundaryResult" href="#tf.applib.display.getBoundaryResult">getBoundaryResult</a></code></li>
<li><code><a title="tf.applib.display.getChildren" href="#tf.applib.display.getChildren">getChildren</a></code></li>
<li><code><a title="tf.applib.display.getChunkedType" href="#tf.applib.display.getChunkedType">getChunkedType</a></code></li>
<li><code><a title="tf.applib.display.getFeatures" href="#tf.applib.display.getFeatures">getFeatures</a></code></li>
<li><code><a title="tf.applib.display.getLtr" href="#tf.applib.display.getLtr">getLtr</a></code></li>
<li><code><a title="tf.applib.display.getNodePart" href="#tf.applib.display.getNodePart">getNodePart</a></code></li>
<li><code><a title="tf.applib.display.getPassage" href="#tf.applib.display.getPassage">getPassage</a></code></li>
<li><code><a title="tf.applib.display.getRefMember" href="#tf.applib.display.getRefMember">getRefMember</a></code></li>
<li><code><a title="tf.applib.display.getResultsX" href="#tf.applib.display.getResultsX">getResultsX</a></code></li>
<li><code><a title="tf.applib.display.getSlots" href="#tf.applib.display.getSlots">getSlots</a></code></li>
<li><code><a title="tf.applib.display.getText" href="#tf.applib.display.getText">getText</a></code></li>
<li><code><a title="tf.applib.display.getTextCls" href="#tf.applib.display.getTextCls">getTextCls</a></code></li>
<li><code><a title="tf.applib.display.getValue" href="#tf.applib.display.getValue">getValue</a></code></li>
<li><code><a title="tf.applib.display.htmlSafe" href="#tf.applib.display.htmlSafe">htmlSafe</a></code></li>
<li><code><a title="tf.applib.display.loadCss" href="#tf.applib.display.loadCss">loadCss</a></code></li>
<li><code><a title="tf.applib.display.note" href="#tf.applib.display.note">note</a></code></li>
<li><code><a title="tf.applib.display.plain" href="#tf.applib.display.plain">plain</a></code></li>
<li><code><a title="tf.applib.display.plainTuple" href="#tf.applib.display.plainTuple">plainTuple</a></code></li>
<li><code><a title="tf.applib.display.pretty" href="#tf.applib.display.pretty">pretty</a></code></li>
<li><code><a title="tf.applib.display.prettyTuple" href="#tf.applib.display.prettyTuple">prettyTuple</a></code></li>
<li><code><a title="tf.applib.display.setSubBaseTypes" href="#tf.applib.display.setSubBaseTypes">setSubBaseTypes</a></code></li>
<li><code><a title="tf.applib.display.show" href="#tf.applib.display.show">show</a></code></li>
<li><code><a title="tf.applib.display.table" href="#tf.applib.display.table">table</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.applib.display.NodeContext" href="#tf.applib.display.NodeContext">NodeContext</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.applib.display.NodeContext.boundaryCls" href="#tf.applib.display.NodeContext.boundaryCls">boundaryCls</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.children" href="#tf.applib.display.NodeContext.children">children</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.cls" href="#tf.applib.display.NodeContext.cls">cls</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.descend" href="#tf.applib.display.NodeContext.descend">descend</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.hasChunks" href="#tf.applib.display.NodeContext.hasChunks">hasChunks</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.hidden" href="#tf.applib.display.NodeContext.hidden">hidden</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.hlCls" href="#tf.applib.display.NodeContext.hlCls">hlCls</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.hlStyle" href="#tf.applib.display.NodeContext.hlStyle">hlStyle</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.isBaseNonSlot" href="#tf.applib.display.NodeContext.isBaseNonSlot">isBaseNonSlot</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.isSlot" href="#tf.applib.display.NodeContext.isSlot">isSlot</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.isSlotOrDescend" href="#tf.applib.display.NodeContext.isSlotOrDescend">isSlotOrDescend</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.nType" href="#tf.applib.display.NodeContext.nType">nType</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.nodePart" href="#tf.applib.display.NodeContext.nodePart">nodePart</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.slotType" href="#tf.applib.display.NodeContext.slotType">slotType</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.slots" href="#tf.applib.display.NodeContext.slots">slots</a></code></li>
<li><code><a title="tf.applib.display.NodeContext.textCls" href="#tf.applib.display.NodeContext.textCls">textCls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.applib.display.OuterContext" href="#tf.applib.display.OuterContext">OuterContext</a></code></h4>
<ul class="">
<li><code><a title="tf.applib.display.OuterContext.explain" href="#tf.applib.display.OuterContext.explain">explain</a></code></li>
<li><code><a title="tf.applib.display.OuterContext.inTuple" href="#tf.applib.display.OuterContext.inTuple">inTuple</a></code></li>
<li><code><a title="tf.applib.display.OuterContext.ltr" href="#tf.applib.display.OuterContext.ltr">ltr</a></code></li>
<li><code><a title="tf.applib.display.OuterContext.slots" href="#tf.applib.display.OuterContext.slots">slots</a></code></li>
<li><code><a title="tf.applib.display.OuterContext.textCls" href="#tf.applib.display.OuterContext.textCls">textCls</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>